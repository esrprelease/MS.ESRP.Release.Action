/**
 * ESRP Gateway API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

 import localVarRequest = require('request');
 import http = require('http');
 import Promise = require('bluebird');
 
 let defaultBasePath = 'https://localhost';
 
 // ===============================================
 // This file is autogenerated - Please do not edit
 // ===============================================
 
 /* tslint:disable:no-unused-variable */
 let primitives = [
                     "string",
                     "boolean",
                     "double",
                     "integer",
                     "long",
                     "float",
                     "number",
                     "any"
                  ];
 
 class ObjectSerializer {
 
     public static findCorrectType(data: any, expectedType: string) {
         if (data == undefined) {
             return expectedType;
         } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
             return expectedType;
         } else if (expectedType === "Date") {
             return expectedType;
         } else {
             if (enumsMap[expectedType]) {
                 return expectedType;
             }
 
             if (!typeMap[expectedType]) {
                 return expectedType; // w/e we don't know the type
             }
 
             // Check the discriminator
             let discriminatorProperty = typeMap[expectedType].discriminator;
             if (discriminatorProperty == null) {
                 return expectedType; // the type does not have a discriminator. use it.
             } else {
                 if (data[discriminatorProperty]) {
                     return data[discriminatorProperty]; // use the type given in the discriminator
                 } else {
                     return expectedType; // discriminator was not present (or an empty string)
                 }
             }
         }
     }
 
     public static serialize(data: any, type: string) {
         if (data == undefined) {
             return data;
         } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
             return data;
         } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
             let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
             subType = subType.substring(0, subType.length - 1); // Type> => Type
             let transformedData: any[] = [];
             for (let index in data) {
                 let date = data[index];
                 transformedData.push(ObjectSerializer.serialize(date, subType));
             }
             return transformedData;
         } else if (type === "Date") {
             return data.toString();
         } else {
             if (enumsMap[type]) {
                 return data;
             }
             if (!typeMap[type]) { // in case we dont know the type
                 return data;
             }
 
             // get the map for the correct type.
             let attributeTypes = typeMap[type].getAttributeTypeMap();
             let instance: {[index: string]: any} = {};
             for (let index in attributeTypes) {
                 let attributeType = attributeTypes[index];
                 instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
             }
             return instance;
         }
     }
 
     public static deserialize(data: any, type: string) {
         // polymorphism may change the actual type.
         type = ObjectSerializer.findCorrectType(data, type);
         if (data == undefined) {
             return data;
         } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
             return data;
         } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
             let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
             subType = subType.substring(0, subType.length - 1); // Type> => Type
             let transformedData: any[] = [];
             for (let index in data) {
                 let date = data[index];
                 transformedData.push(ObjectSerializer.deserialize(date, subType));
             }
             return transformedData;
         } else if (type === "Date") {
             return new Date(data);
         } else {
             if (enumsMap[type]) {// is Enum
                 return data;
             }
 
             if (!typeMap[type]) { // dont know the type
                 return data;
             }
             let instance = new typeMap[type]();
             let attributeTypes = typeMap[type].getAttributeTypeMap();
             for (let index in attributeTypes) {
                 let attributeType = attributeTypes[index];
                 instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
             }
             return instance;
         }
     }
 }
 
 export class MSEssGatewayClientContractsCipherDetailsMessage {
     'clientId'?: string;
     'clusterRegion'?: string;
     'correlationVector'?: string;
     'releaseCompletedAt'?: Date;
     'releaseInfo'?: MSEssGatewayClientContractsReleaseReleaseInfo;
     'productInfo'?: MSEssGatewayClientContractsReleaseProductInfo;
     'createdBy'?: MSEssGatewayClientContractsReleaseUserInfo;
     'owners'?: Array<MSEssGatewayClientContractsReleaseOwnerInfo>;
     'approvers'?: Array<MSEssGatewayClientContractsReleaseResponseApproverInfoDetails>;
     'authorizedDownloadUsers'?: Array<MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo>;
     'accessPermissionsInfo'?: MSEssGatewayClientContractsReleaseAccessPermissionsInfo;
     'files'?: Array<MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo>;
     'comments'?: Array<string>;
     'cancellationReason'?: string;
     'totalReleaseSize'?: number;
     'totalFileCount'?: number;
     'version'?: string;
     'activities'?: Array<MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo>;
     'releaseError'?: MSEssGatewayClientContractsReleaseResponseReleaseError;
     'childworkflowType'?: string;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsCipherDetailsMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "clusterRegion",
             "baseName": "clusterRegion",
             "type": "string"
         },
         {
             "name": "correlationVector",
             "baseName": "correlationVector",
             "type": "string"
         },
         {
             "name": "releaseCompletedAt",
             "baseName": "releaseCompletedAt",
             "type": "Date"
         },
         {
             "name": "releaseInfo",
             "baseName": "releaseInfo",
             "type": "MSEssGatewayClientContractsReleaseReleaseInfo"
         },
         {
             "name": "productInfo",
             "baseName": "productInfo",
             "type": "MSEssGatewayClientContractsReleaseProductInfo"
         },
         {
             "name": "createdBy",
             "baseName": "createdBy",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         },
         {
             "name": "owners",
             "baseName": "owners",
             "type": "Array<MSEssGatewayClientContractsReleaseOwnerInfo>"
         },
         {
             "name": "approvers",
             "baseName": "approvers",
             "type": "Array<MSEssGatewayClientContractsReleaseResponseApproverInfoDetails>"
         },
         {
             "name": "authorizedDownloadUsers",
             "baseName": "authorizedDownloadUsers",
             "type": "Array<MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo>"
         },
         {
             "name": "accessPermissionsInfo",
             "baseName": "accessPermissionsInfo",
             "type": "MSEssGatewayClientContractsReleaseAccessPermissionsInfo"
         },
         {
             "name": "files",
             "baseName": "files",
             "type": "Array<MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo>"
         },
         {
             "name": "comments",
             "baseName": "comments",
             "type": "Array<string>"
         },
         {
             "name": "cancellationReason",
             "baseName": "cancellationReason",
             "type": "string"
         },
         {
             "name": "totalReleaseSize",
             "baseName": "totalReleaseSize",
             "type": "number"
         },
         {
             "name": "totalFileCount",
             "baseName": "totalFileCount",
             "type": "number"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "activities",
             "baseName": "activities",
             "type": "Array<MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo>"
         },
         {
             "name": "releaseError",
             "baseName": "releaseError",
             "type": "MSEssGatewayClientContractsReleaseResponseReleaseError"
         },
         {
             "name": "childworkflowType",
             "baseName": "childworkflowType",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsCipherDetailsMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsCipherDetailsMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsCipherDetailsMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsCipherInfo {
     'cipherType'?: MSEssGatewayClientContractsCipherInfo.CipherTypeEnum;
     'algorithm'?: string;
     'parameters'?: { [key: string]: string; };
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "cipherType",
             "baseName": "cipherType",
             "type": "MSEssGatewayClientContractsCipherInfo.CipherTypeEnum"
         },
         {
             "name": "algorithm",
             "baseName": "algorithm",
             "type": "string"
         },
         {
             "name": "parameters",
             "baseName": "parameters",
             "type": "{ [key: string]: string; }"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsCipherInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsCipherInfo {
     export enum CipherTypeEnum {
         Encryption = <any> 'encryption',
         Decryption = <any> 'decryption'
     }
 }
 export class MSEssGatewayClientContractsCipherResultMessage {
     'version'?: string;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsCipherResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsCipherResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsCipherResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsCipherResultMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsCryptoFileInfo {
     'destinationLocation'?: MSEssGatewayClientContractsFileLocation;
     'cryptoOperations'?: Array<MSEssGatewayClientContractsCryptoOperation>;
     'name'?: string;
     'hash'?: string;
     'sourceLocation'?: MSEssGatewayClientContractsFileLocation;
     'sizeInBytes'?: number;
     'hashType'?: MSEssGatewayClientContractsCryptoFileInfo.HashTypeEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "destinationLocation",
             "baseName": "destinationLocation",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "cryptoOperations",
             "baseName": "cryptoOperations",
             "type": "Array<MSEssGatewayClientContractsCryptoOperation>"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "hash",
             "baseName": "hash",
             "type": "string"
         },
         {
             "name": "sourceLocation",
             "baseName": "sourceLocation",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "sizeInBytes",
             "baseName": "sizeInBytes",
             "type": "number"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsCryptoFileInfo.HashTypeEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsCryptoFileInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsCryptoFileInfo {
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
 }
 export class MSEssGatewayClientContractsCryptoOperation {
     'primitive'?: MSEssGatewayClientContractsCryptoOperation.PrimitiveEnum;
     'parameters'?: Array<MSEssGatewayClientContractsCryptoParameter>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "primitive",
             "baseName": "primitive",
             "type": "MSEssGatewayClientContractsCryptoOperation.PrimitiveEnum"
         },
         {
             "name": "parameters",
             "baseName": "parameters",
             "type": "Array<MSEssGatewayClientContractsCryptoParameter>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsCryptoOperation.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsCryptoOperation {
     export enum PrimitiveEnum {
         KeyDerivation = <any> 'keyDerivation',
         ReDerivation = <any> 'reDerivation',
         InPlaceEncryption = <any> 'inPlaceEncryption',
         InPlaceDecryption = <any> 'inPlaceDecryption',
         Encryption = <any> 'encryption'
     }
 }
 export class MSEssGatewayClientContractsCryptoParameter {
     'parameterName'?: string;
     'parameterValue'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "parameterName",
             "baseName": "parameterName",
             "type": "string"
         },
         {
             "name": "parameterValue",
             "baseName": "parameterValue",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsCryptoParameter.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsCryptoRequestMessage {
     'cryptoOperations'?: Array<MSEssGatewayClientContractsCryptoOperation>;
     'file'?: MSEssGatewayClientContractsCryptoFileInfo;
     'jwsToken'?: string;
     'clientId'?: string;
     'region'?: MSEssGatewayClientContractsCryptoRequestMessage.RegionEnum;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'requestExpiresAt'?: Date;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "cryptoOperations",
             "baseName": "cryptoOperations",
             "type": "Array<MSEssGatewayClientContractsCryptoOperation>"
         },
         {
             "name": "file",
             "baseName": "file",
             "type": "MSEssGatewayClientContractsCryptoFileInfo"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "region",
             "baseName": "region",
             "type": "MSEssGatewayClientContractsCryptoRequestMessage.RegionEnum"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "requestExpiresAt",
             "baseName": "requestExpiresAt",
             "type": "Date"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsCryptoRequestMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsCryptoRequestMessage {
     export enum RegionEnum {
         None = <any> 'none',
         PuertoRico = <any> 'puertoRico',
         Us = <any> 'us',
         Dublin = <any> 'dublin',
         Singapore = <any> 'singapore'
     }
 }
 export class MSEssGatewayClientContractsCryptoResultMessage {
     'sourceFileHash'?: string;
     'destinationFileHash'?: string;
     'destinationFileLocationType'?: MSEssGatewayClientContractsFileLocation;
     'hashType'?: MSEssGatewayClientContractsCryptoResultMessage.HashTypeEnum;
     'fileName'?: string;
     'fileSize'?: number;
     'destinationFileLocation'?: string;
     'cryptoOperations'?: Array<MSEssGatewayClientContractsCryptoOperation>;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsCryptoResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "sourceFileHash",
             "baseName": "sourceFileHash",
             "type": "string"
         },
         {
             "name": "destinationFileHash",
             "baseName": "destinationFileHash",
             "type": "string"
         },
         {
             "name": "destinationFileLocationType",
             "baseName": "destinationFileLocationType",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsCryptoResultMessage.HashTypeEnum"
         },
         {
             "name": "fileName",
             "baseName": "fileName",
             "type": "string"
         },
         {
             "name": "fileSize",
             "baseName": "fileSize",
             "type": "number"
         },
         {
             "name": "destinationFileLocation",
             "baseName": "destinationFileLocation",
             "type": "string"
         },
         {
             "name": "cryptoOperations",
             "baseName": "cryptoOperations",
             "type": "Array<MSEssGatewayClientContractsCryptoOperation>"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsCryptoResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsCryptoResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsCryptoResultMessage {
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsDigestSignCertificateRequestMessage {
     'clientId'?: string;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'certificateSubjectName'?: string;
     'certificateTemplateName'?: string;
     'jwsToken'?: string;
     'requestExpiresAt'?: Date;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "certificateSubjectName",
             "baseName": "certificateSubjectName",
             "type": "string"
         },
         {
             "name": "certificateTemplateName",
             "baseName": "certificateTemplateName",
             "type": "string"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "requestExpiresAt",
             "baseName": "requestExpiresAt",
             "type": "Date"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsDigestSignCertificateRequestMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsDigestSignCertificateResultMessage {
     'certificate'?: string;
     'keyCode'?: string;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsDigestSignCertificateResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "certificate",
             "baseName": "certificate",
             "type": "string"
         },
         {
             "name": "keyCode",
             "baseName": "keyCode",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsDigestSignCertificateResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsDigestSignCertificateResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsDigestSignCertificateResultMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsDigestSignMapping {
     'operationTemplates'?: Array<MSEssGatewayClientContractsOperationTemplate>;
     'keyCodes'?: Array<string>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "operationTemplates",
             "baseName": "operationTemplates",
             "type": "Array<MSEssGatewayClientContractsOperationTemplate>"
         },
         {
             "name": "keyCodes",
             "baseName": "keyCodes",
             "type": "Array<string>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsDigestSignMapping.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsDigestSignOperationErrorPatterns {
     'id'?: number;
     'operationCodes'?: Array<string>;
     'signtoolOutputRegexPattern'?: string;
     'statusCode'?: MSEssGatewayClientContractsDigestSignOperationErrorPatterns.StatusCodeEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "id",
             "baseName": "id",
             "type": "number"
         },
         {
             "name": "operationCodes",
             "baseName": "operationCodes",
             "type": "Array<string>"
         },
         {
             "name": "signtoolOutputRegexPattern",
             "baseName": "signtoolOutputRegexPattern",
             "type": "string"
         },
         {
             "name": "statusCode",
             "baseName": "statusCode",
             "type": "MSEssGatewayClientContractsDigestSignOperationErrorPatterns.StatusCodeEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsDigestSignOperationErrorPatterns.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsDigestSignOperationErrorPatterns {
     export enum StatusCodeEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsDynamicSigningOperation {
     'certificateSubjectName'?: string;
     'certificateTemplateName'?: string;
     'keyCode'?: string;
     'operationSetCode'?: string;
     'parameters'?: Array<MSEssGatewayClientContractsSigningParameter>;
     'toolName'?: string;
     'toolVersion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "certificateSubjectName",
             "baseName": "certificateSubjectName",
             "type": "string"
         },
         {
             "name": "certificateTemplateName",
             "baseName": "certificateTemplateName",
             "type": "string"
         },
         {
             "name": "keyCode",
             "baseName": "keyCode",
             "type": "string"
         },
         {
             "name": "operationSetCode",
             "baseName": "operationSetCode",
             "type": "string"
         },
         {
             "name": "parameters",
             "baseName": "parameters",
             "type": "Array<MSEssGatewayClientContractsSigningParameter>"
         },
         {
             "name": "toolName",
             "baseName": "toolName",
             "type": "string"
         },
         {
             "name": "toolVersion",
             "baseName": "toolVersion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsDynamicSigningOperation.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsEsrpClientConfigInfo3 {
     'eventHubTelemetryConnectionShard'?: Array<MSEssGatewayClientContractsEventHubTelemetryConnectionShard>;
     'apiBaseUri'?: string;
     'sessionTimeout'?: string;
     'maxDegreeOfParallelism'?: number;
     'servicePointManagerDefaultConnectionLimit'?: number;
     'exponentialFirstFastRetry'?: boolean;
     'exponentialRetryCount'?: number;
     'exponentialRetryMinBackOff'?: string;
     'exponentialRetryMaxBackOff'?: string;
     'exponentialRetryDeltaBackOff'?: string;
     'slaFor0MbTo5Mb'?: string;
     'slaFor5MbTo50Mb'?: string;
     'slaFor50MbTo250Mb'?: string;
     'slaFor250MbTo500Mb'?: string;
     'slaFor500MbTo1Gb'?: string;
     'slaFor1GbTo4Gb'?: string;
     'slaFor4GbTo16Gb'?: string;
     'slaFor16GbTo32Gb'?: string;
     'slaFor32GbTo50Gb'?: string;
     'slaFor50GbTo100Gb'?: string;
     'slaFor100GbTo150Gb'?: string;
     'exitOnFlaggedFile'?: boolean;
     'flaggedFileClientWaitTimeout'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "eventHubTelemetryConnectionShard",
             "baseName": "eventHubTelemetryConnectionShard",
             "type": "Array<MSEssGatewayClientContractsEventHubTelemetryConnectionShard>"
         },
         {
             "name": "apiBaseUri",
             "baseName": "apiBaseUri",
             "type": "string"
         },
         {
             "name": "sessionTimeout",
             "baseName": "sessionTimeout",
             "type": "string"
         },
         {
             "name": "maxDegreeOfParallelism",
             "baseName": "maxDegreeOfParallelism",
             "type": "number"
         },
         {
             "name": "servicePointManagerDefaultConnectionLimit",
             "baseName": "servicePointManagerDefaultConnectionLimit",
             "type": "number"
         },
         {
             "name": "exponentialFirstFastRetry",
             "baseName": "exponentialFirstFastRetry",
             "type": "boolean"
         },
         {
             "name": "exponentialRetryCount",
             "baseName": "exponentialRetryCount",
             "type": "number"
         },
         {
             "name": "exponentialRetryMinBackOff",
             "baseName": "exponentialRetryMinBackOff",
             "type": "string"
         },
         {
             "name": "exponentialRetryMaxBackOff",
             "baseName": "exponentialRetryMaxBackOff",
             "type": "string"
         },
         {
             "name": "exponentialRetryDeltaBackOff",
             "baseName": "exponentialRetryDeltaBackOff",
             "type": "string"
         },
         {
             "name": "slaFor0MbTo5Mb",
             "baseName": "slaFor0MbTo5Mb",
             "type": "string"
         },
         {
             "name": "slaFor5MbTo50Mb",
             "baseName": "slaFor5MbTo50Mb",
             "type": "string"
         },
         {
             "name": "slaFor50MbTo250Mb",
             "baseName": "slaFor50MbTo250Mb",
             "type": "string"
         },
         {
             "name": "slaFor250MbTo500Mb",
             "baseName": "slaFor250MbTo500Mb",
             "type": "string"
         },
         {
             "name": "slaFor500MbTo1Gb",
             "baseName": "slaFor500MbTo1Gb",
             "type": "string"
         },
         {
             "name": "slaFor1GbTo4Gb",
             "baseName": "slaFor1GbTo4Gb",
             "type": "string"
         },
         {
             "name": "slaFor4GbTo16Gb",
             "baseName": "slaFor4GbTo16Gb",
             "type": "string"
         },
         {
             "name": "slaFor16GbTo32Gb",
             "baseName": "slaFor16GbTo32Gb",
             "type": "string"
         },
         {
             "name": "slaFor32GbTo50Gb",
             "baseName": "slaFor32GbTo50Gb",
             "type": "string"
         },
         {
             "name": "slaFor50GbTo100Gb",
             "baseName": "slaFor50GbTo100Gb",
             "type": "string"
         },
         {
             "name": "slaFor100GbTo150Gb",
             "baseName": "slaFor100GbTo150Gb",
             "type": "string"
         },
         {
             "name": "exitOnFlaggedFile",
             "baseName": "exitOnFlaggedFile",
             "type": "boolean"
         },
         {
             "name": "flaggedFileClientWaitTimeout",
             "baseName": "flaggedFileClientWaitTimeout",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsEsrpClientConfigInfo3.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsEventHubTelemetryConnectionShard {
     'connectionString'?: string;
     'lowKey'?: number;
     'highKey'?: number;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "connectionString",
             "baseName": "connectionString",
             "type": "string"
         },
         {
             "name": "lowKey",
             "baseName": "lowKey",
             "type": "number"
         },
         {
             "name": "highKey",
             "baseName": "highKey",
             "type": "number"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsEventHubTelemetryConnectionShard.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsFileLocation {
     'type'?: MSEssGatewayClientContractsFileLocation.TypeEnum;
     'blobUrl'?: string;
     'uncPath'?: string;
     'bloburl'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "type",
             "baseName": "type",
             "type": "MSEssGatewayClientContractsFileLocation.TypeEnum"
         },
         {
             "name": "blobUrl",
             "baseName": "blobUrl",
             "type": "string"
         },
         {
            "name": "bloburl",
            "baseName": "bloburl",
            "type": "string"
        },
         {
             "name": "uncPath",
             "baseName": "uncPath",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsFileLocation.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsFileLocation {
     export enum TypeEnum {
         AzureBlob = <any> 'azureBlob',
         Unc = <any> 'unc'
     }
 }
 export class MSEssGatewayClientContractsFileTransferFileTransferResultMessage {
     'fileName'?: string;
     'sizeInBytes'?: number;
     'hashType'?: MSEssGatewayClientContractsFileTransferFileTransferResultMessage.HashTypeEnum;
     'sourceFileHash'?: string;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsFileTransferFileTransferResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "fileName",
             "baseName": "fileName",
             "type": "string"
         },
         {
             "name": "sizeInBytes",
             "baseName": "sizeInBytes",
             "type": "number"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsFileTransferFileTransferResultMessage.HashTypeEnum"
         },
         {
             "name": "sourceFileHash",
             "baseName": "sourceFileHash",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsFileTransferFileTransferResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsFileTransferFileTransferResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsFileTransferFileTransferResultMessage {
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult {
     'fileId'?: string;
     'fileSizeInBytes'?: number;
     'fileHash'?: string;
     'fileStatus'?: MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.FileStatusEnum;
     'hashOfHashes'?: string;
     'fileErrorInfo'?: MSEssGatewayClientContractsInnerServiceError;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "fileId",
             "baseName": "fileId",
             "type": "string"
         },
         {
             "name": "fileSizeInBytes",
             "baseName": "fileSizeInBytes",
             "type": "number"
         },
         {
             "name": "fileHash",
             "baseName": "fileHash",
             "type": "string"
         },
         {
             "name": "fileStatus",
             "baseName": "fileStatus",
             "type": "MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.FileStatusEnum"
         },
         {
             "name": "hashOfHashes",
             "baseName": "hashOfHashes",
             "type": "string"
         },
         {
             "name": "fileErrorInfo",
             "baseName": "fileErrorInfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult {
     export enum FileStatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage {
     'sourceFileName'?: string;
     'destinationHashType'?: MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.DestinationHashTypeEnum;
     'pieceHashFileResults'?: Array<MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult>;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "sourceFileName",
             "baseName": "sourceFileName",
             "type": "string"
         },
         {
             "name": "destinationHashType",
             "baseName": "destinationHashType",
             "type": "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.DestinationHashTypeEnum"
         },
         {
             "name": "pieceHashFileResults",
             "baseName": "pieceHashFileResults",
             "type": "Array<MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult>"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage {
     export enum DestinationHashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsGatewayError {
     'code'?: string;
     'message'?: string;
     'target'?: string;
     'innerError'?: MSEssGatewayClientContractsInnerServiceError;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "code",
             "baseName": "code",
             "type": "string"
         },
         {
             "name": "message",
             "baseName": "message",
             "type": "string"
         },
         {
             "name": "target",
             "baseName": "target",
             "type": "string"
         },
         {
             "name": "innerError",
             "baseName": "innerError",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsGatewayError.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsIFeature {
     'featureType'?: MSEssGatewayClientContractsIFeature.FeatureTypeEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "featureType",
             "baseName": "featureType",
             "type": "MSEssGatewayClientContractsIFeature.FeatureTypeEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsIFeature.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsIFeature {
     export enum FeatureTypeEnum {
         None = <any> 'None',
         Callback = <any> 'Callback'
     }
 }
 export class MSEssGatewayClientContractsInnerServiceError {
     'code'?: string;
     'details'?: { [key: string]: string; };
     'innerError'?: MSEssGatewayClientContractsInnerServiceError;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "code",
             "baseName": "code",
             "type": "string"
         },
         {
             "name": "details",
             "baseName": "details",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "innerError",
             "baseName": "innerError",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsInnerServiceError.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsLegacyCopsMappingData {
     'copsId'?: string;
     'staticOperations'?: Array<MSEssGatewayClientContractsStaticSigningOperation>;
     'dynamicOperations'?: Array<MSEssGatewayClientContractsDynamicSigningOperation>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "copsId",
             "baseName": "copsId",
             "type": "string"
         },
         {
             "name": "staticOperations",
             "baseName": "staticOperations",
             "type": "Array<MSEssGatewayClientContractsStaticSigningOperation>"
         },
         {
             "name": "dynamicOperations",
             "baseName": "dynamicOperations",
             "type": "Array<MSEssGatewayClientContractsDynamicSigningOperation>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsLegacyCopsMappingData.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsOperationResponse {
     'operationId'?: string;
     'esrpCorrelationId'?: string;
     'error'?: MSEssGatewayClientContractsGatewayError;
     'statusLocation'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "error",
             "baseName": "error",
             "type": "MSEssGatewayClientContractsGatewayError"
         },
         {
             "name": "statusLocation",
             "baseName": "statusLocation",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsOperationResponse.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsOperationTemplate {
     'operationCode'?: string;
     'toolFilename'?: string;
     'toolArgumentTemplate'?: string;
     'isCertificateRequired'?: boolean;
     'requiredVerifyOperationCode'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "operationCode",
             "baseName": "operationCode",
             "type": "string"
         },
         {
             "name": "toolFilename",
             "baseName": "toolFilename",
             "type": "string"
         },
         {
             "name": "toolArgumentTemplate",
             "baseName": "toolArgumentTemplate",
             "type": "string"
         },
         {
             "name": "isCertificateRequired",
             "baseName": "isCertificateRequired",
             "type": "boolean"
         },
         {
             "name": "requiredVerifyOperationCode",
             "baseName": "requiredVerifyOperationCode",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsOperationTemplate.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsPKITACertificateClmApprovalInfo {
     'user'?: string;
     'approverType'?: MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApproverTypeEnum;
     'approvalStatus'?: MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApprovalStatusEnum;
     'approvalDateTime'?: Date;
     'comment'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "user",
             "baseName": "user",
             "type": "string"
         },
         {
             "name": "approverType",
             "baseName": "approverType",
             "type": "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApproverTypeEnum"
         },
         {
             "name": "approvalStatus",
             "baseName": "approvalStatus",
             "type": "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApprovalStatusEnum"
         },
         {
             "name": "approvalDateTime",
             "baseName": "approvalDateTime",
             "type": "Date"
         },
         {
             "name": "comment",
             "baseName": "comment",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsPKITACertificateClmApprovalInfo {
     export enum ApproverTypeEnum {
         PreApprover = <any> 'preApprover',
         ProductGroupApprover = <any> 'productGroupApprover',
         PkiAdminApprover = <any> 'pkiAdminApprover',
         System = <any> 'system'
     }
     export enum ApprovalStatusEnum {
         Approved = <any> 'approved',
         Rejected = <any> 'rejected'
     }
 }
 export class MSEssGatewayClientContractsPKITACertificateCsrFile {
     'csrId'?: string;
     'content'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "csrId",
             "baseName": "csrId",
             "type": "string"
         },
         {
             "name": "content",
             "baseName": "content",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPKITACertificateCsrFile.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsPKITACertificateFailedCsrFile {
     'csrId'?: string;
     'errorMessage'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "csrId",
             "baseName": "csrId",
             "type": "string"
         },
         {
             "name": "errorMessage",
             "baseName": "errorMessage",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPKITACertificateFailedCsrFile.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage {
     'certificateAuthorityGroupId'?: string;
     'certificateTemplateId'?: string;
     'csrFiles'?: Array<MSEssGatewayClientContractsPKITACertificateCsrFile>;
     'certificateFileType'?: string;
     'certificateOwnerIds'?: Array<string>;
     'usageStatement'?: string;
     'validityToPeriod'?: Date;
     'description'?: string;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'jwsToken'?: string;
     'clientId'?: string;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "certificateAuthorityGroupId",
             "baseName": "certificateAuthorityGroupId",
             "type": "string"
         },
         {
             "name": "certificateTemplateId",
             "baseName": "certificateTemplateId",
             "type": "string"
         },
         {
             "name": "csrFiles",
             "baseName": "csrFiles",
             "type": "Array<MSEssGatewayClientContractsPKITACertificateCsrFile>"
         },
         {
             "name": "certificateFileType",
             "baseName": "certificateFileType",
             "type": "string"
         },
         {
             "name": "certificateOwnerIds",
             "baseName": "certificateOwnerIds",
             "type": "Array<string>"
         },
         {
             "name": "usageStatement",
             "baseName": "usageStatement",
             "type": "string"
         },
         {
             "name": "validityToPeriod",
             "baseName": "validityToPeriod",
             "type": "Date"
         },
         {
             "name": "description",
             "baseName": "description",
             "type": "string"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage {
     'certificates'?: Array<MSEssGatewayClientContractsPkitaCertificateCertificateInfo>;
     'description'?: string;
     'failedCsrFiles'?: Array<MSEssGatewayClientContractsPKITACertificateFailedCsrFile>;
     'istrusted'?: boolean;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "certificates",
             "baseName": "certificates",
             "type": "Array<MSEssGatewayClientContractsPkitaCertificateCertificateInfo>"
         },
         {
             "name": "description",
             "baseName": "description",
             "type": "string"
         },
         {
             "name": "failedCsrFiles",
             "baseName": "failedCsrFiles",
             "type": "Array<MSEssGatewayClientContractsPKITACertificateFailedCsrFile>"
         },
         {
             "name": "istrusted",
             "baseName": "istrusted",
             "type": "boolean"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage {
     'pkitaCertificateRequestMessageJwtToken'?: string;
     'submissionOperationId'?: string;
     'approvalStatus'?: MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.ApprovalStatusEnum;
     'approvalInfo'?: Array<MSEssGatewayClientContractsPKITACertificateClmApprovalInfo>;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'jwsToken'?: string;
     'clientId'?: string;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "pkitaCertificateRequestMessageJwtToken",
             "baseName": "pkitaCertificateRequestMessageJwtToken",
             "type": "string"
         },
         {
             "name": "submissionOperationId",
             "baseName": "submissionOperationId",
             "type": "string"
         },
         {
             "name": "approvalStatus",
             "baseName": "approvalStatus",
             "type": "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.ApprovalStatusEnum"
         },
         {
             "name": "approvalInfo",
             "baseName": "approvalInfo",
             "type": "Array<MSEssGatewayClientContractsPKITACertificateClmApprovalInfo>"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage {
     export enum ApprovalStatusEnum {
         Approved = <any> 'approved',
         Rejected = <any> 'rejected'
     }
 }
 export class MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage {
     'approvalInfo'?: Array<MSEssGatewayClientContractsPKITACertificateClmApprovalInfo>;
     'clmClientId'?: string;
     'policyResponseJwt'?: string;
     'validityDuration'?: MSEssGatewayClientContractsPKITACertificateValidityDuration;
     'policyExtensions'?: Array<MSEssGatewayClientContractsPKITACertificatePolicyExtension>;
     'previousOperationIds'?: Array<string>;
     'certificateAuthorityGroupId'?: string;
     'certificateTemplateId'?: string;
     'csrFiles'?: Array<MSEssGatewayClientContractsPKITACertificateCsrFile>;
     'certificateFileType'?: string;
     'certificateOwnerIds'?: Array<string>;
     'usageStatement'?: string;
     'validityToPeriod'?: Date;
     'description'?: string;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'jwsToken'?: string;
     'clientId'?: string;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "approvalInfo",
             "baseName": "approvalInfo",
             "type": "Array<MSEssGatewayClientContractsPKITACertificateClmApprovalInfo>"
         },
         {
             "name": "clmClientId",
             "baseName": "clmClientId",
             "type": "string"
         },
         {
             "name": "policyResponseJwt",
             "baseName": "policyResponseJwt",
             "type": "string"
         },
         {
             "name": "validityDuration",
             "baseName": "validityDuration",
             "type": "MSEssGatewayClientContractsPKITACertificateValidityDuration"
         },
         {
             "name": "policyExtensions",
             "baseName": "policyExtensions",
             "type": "Array<MSEssGatewayClientContractsPKITACertificatePolicyExtension>"
         },
         {
             "name": "previousOperationIds",
             "baseName": "previousOperationIds",
             "type": "Array<string>"
         },
         {
             "name": "certificateAuthorityGroupId",
             "baseName": "certificateAuthorityGroupId",
             "type": "string"
         },
         {
             "name": "certificateTemplateId",
             "baseName": "certificateTemplateId",
             "type": "string"
         },
         {
             "name": "csrFiles",
             "baseName": "csrFiles",
             "type": "Array<MSEssGatewayClientContractsPKITACertificateCsrFile>"
         },
         {
             "name": "certificateFileType",
             "baseName": "certificateFileType",
             "type": "string"
         },
         {
             "name": "certificateOwnerIds",
             "baseName": "certificateOwnerIds",
             "type": "Array<string>"
         },
         {
             "name": "usageStatement",
             "baseName": "usageStatement",
             "type": "string"
         },
         {
             "name": "validityToPeriod",
             "baseName": "validityToPeriod",
             "type": "Date"
         },
         {
             "name": "description",
             "baseName": "description",
             "type": "string"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsPKITACertificatePolicyExtension {
     'extensionType'?: string;
     'extensionValue'?: string;
     'isCritical'?: boolean;
     'oid'?: string;
     'asnBlob'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "extensionType",
             "baseName": "extensionType",
             "type": "string"
         },
         {
             "name": "extensionValue",
             "baseName": "extensionValue",
             "type": "string"
         },
         {
             "name": "isCritical",
             "baseName": "isCritical",
             "type": "boolean"
         },
         {
             "name": "oid",
             "baseName": "oid",
             "type": "string"
         },
         {
             "name": "asnBlob",
             "baseName": "asnBlob",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPKITACertificatePolicyExtension.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsPKITACertificateValidityDuration {
     'years'?: number;
     'months'?: number;
     'days'?: number;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "years",
             "baseName": "years",
             "type": "number"
         },
         {
             "name": "months",
             "baseName": "months",
             "type": "number"
         },
         {
             "name": "days",
             "baseName": "days",
             "type": "number"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPKITACertificateValidityDuration.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsPkitaCertificateCertificateInfo {
     'csrId'?: string;
     'certificateBlob'?: string;
     'certificateP7BBlob'?: string;
     'isMisIssue'?: boolean;
     'notes'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "csrId",
             "baseName": "csrId",
             "type": "string"
         },
         {
             "name": "certificateBlob",
             "baseName": "certificateBlob",
             "type": "string"
         },
         {
             "name": "certificateP7BBlob",
             "baseName": "certificateP7BBlob",
             "type": "string"
         },
         {
             "name": "isMisIssue",
             "baseName": "isMisIssue",
             "type": "boolean"
         },
         {
             "name": "notes",
             "baseName": "notes",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPkitaCertificateCertificateInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsPolicy {
     'id'?: string;
     'workflowExecutionType'?: MSEssGatewayClientContractsPolicy.WorkflowExecutionTypeEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "id",
             "baseName": "id",
             "type": "string"
         },
         {
             "name": "workflowExecutionType",
             "baseName": "workflowExecutionType",
             "type": "MSEssGatewayClientContractsPolicy.WorkflowExecutionTypeEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPolicy.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsPolicy {
     export enum WorkflowExecutionTypeEnum {
         EmbedSign = <any> 'embedSign',
         DigestSignAndLazyScan = <any> 'digestSignAndLazyScan',
         EmbedSignAndLazyScan = <any> 'embedSignAndLazyScan',
         DigestSign = <any> 'digestSign',
         AdtDigestSign = <any> 'adtDigestSign'
     }
 }
 export class MSEssGatewayClientContractsPolicyResultMessage {
     'policy'?: MSEssGatewayClientContractsPolicy;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "policy",
             "baseName": "policy",
             "type": "MSEssGatewayClientContractsPolicy"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsPolicyResultMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsProvisionStorageRequest {
     'expiresAfter'?: string;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'partitionCount'?: number;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "expiresAfter",
             "baseName": "expiresAfter",
             "type": "string"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "partitionCount",
             "baseName": "partitionCount",
             "type": "number"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsProvisionStorageRequest.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsProvisionStorageResultMessage {
     'storageShards'?: Array<MSEssGatewayClientContractsStorageShard>;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsProvisionStorageResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "storageShards",
             "baseName": "storageShards",
             "type": "Array<MSEssGatewayClientContractsStorageShard>"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsProvisionStorageResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsProvisionStorageResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsProvisionStorageResultMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsReleaseAccessPermissionsInfo {
     'mainPublisher'?: string;
     'releasePublishers'?: Array<string>;
     'channelDownloadEntityDetails'?: { [key: string]: Array<string>; };
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "mainPublisher",
             "baseName": "mainPublisher",
             "type": "string"
         },
         {
             "name": "releasePublishers",
             "baseName": "releasePublishers",
             "type": "Array<string>"
         },
         {
             "name": "channelDownloadEntityDetails",
             "baseName": "channelDownloadEntityDetails",
             "type": "{ [key: string]: Array<string>; }"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseAccessPermissionsInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseApproverInfo {
     'approver'?: MSEssGatewayClientContractsReleaseUserInfo;
     'isAutoApproved'?: boolean;
     'isMandatory'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "approver",
             "baseName": "approver",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         },
         {
             "name": "isAutoApproved",
             "baseName": "isAutoApproved",
             "type": "boolean"
         },
         {
             "name": "isMandatory",
             "baseName": "isMandatory",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseApproverInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo {
     'authorizedDownloadUser'?: MSEssGatewayClientContractsReleaseUserInfo;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "authorizedDownloadUser",
             "baseName": "authorizedDownloadUser",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseEditApproverInfo {
     'action'?: MSEssGatewayClientContractsReleaseEditApproverInfo.ActionEnum;
     'approver'?: MSEssGatewayClientContractsReleaseUserInfo;
     'isAutoApproved'?: boolean;
     'isMandatory'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "action",
             "baseName": "action",
             "type": "MSEssGatewayClientContractsReleaseEditApproverInfo.ActionEnum"
         },
         {
             "name": "approver",
             "baseName": "approver",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         },
         {
             "name": "isAutoApproved",
             "baseName": "isAutoApproved",
             "type": "boolean"
         },
         {
             "name": "isMandatory",
             "baseName": "isMandatory",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseEditApproverInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseEditApproverInfo {
     export enum ActionEnum {
         Add = <any> 'add',
         Remove = <any> 'remove'
     }
 }
 export class MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo {
     'action'?: MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.ActionEnum;
     'authorizedDownloadUser'?: MSEssGatewayClientContractsReleaseUserInfo;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "action",
             "baseName": "action",
             "type": "MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.ActionEnum"
         },
         {
             "name": "authorizedDownloadUser",
             "baseName": "authorizedDownloadUser",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo {
     export enum ActionEnum {
         Add = <any> 'add',
         Remove = <any> 'remove'
     }
 }
 export class MSEssGatewayClientContractsReleaseEditChannelDownloadEntity {
     'channelDownloadEntityDetails'?: { [key: string]: Array<string>; };
     'action'?: MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.ActionEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "channelDownloadEntityDetails",
             "baseName": "channelDownloadEntityDetails",
             "type": "{ [key: string]: Array<string>; }"
         },
         {
             "name": "action",
             "baseName": "action",
             "type": "MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.ActionEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseEditChannelDownloadEntity {
     export enum ActionEnum {
         Add = <any> 'add',
         Remove = <any> 'remove'
     }
 }
 export class MSEssGatewayClientContractsReleaseEditOwnerInfo {
     'action'?: MSEssGatewayClientContractsReleaseEditOwnerInfo.ActionEnum;
     'owner'?: MSEssGatewayClientContractsReleaseUserInfo;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "action",
             "baseName": "action",
             "type": "MSEssGatewayClientContractsReleaseEditOwnerInfo.ActionEnum"
         },
         {
             "name": "owner",
             "baseName": "owner",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseEditOwnerInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseEditOwnerInfo {
     export enum ActionEnum {
         Add = <any> 'add',
         Remove = <any> 'remove'
     }
 }
 export class MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus {
     'statusCode'?: MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.StatusCodeEnum;
     'errorCode'?: number;
     'errorInfo'?: string;
     'cipherType'?: MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.CipherTypeEnum;
     'algorithmName'?: string;
     'sizeInBytes'?: number;
     'destinationLocation'?: string;
     'hashType'?: MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.HashTypeEnum;
     'destinationHash'?: string;
     'parameters'?: { [key: string]: string; };
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "statusCode",
             "baseName": "statusCode",
             "type": "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.StatusCodeEnum"
         },
         {
             "name": "errorCode",
             "baseName": "errorCode",
             "type": "number"
         },
         {
             "name": "errorInfo",
             "baseName": "errorInfo",
             "type": "string"
         },
         {
             "name": "cipherType",
             "baseName": "cipherType",
             "type": "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.CipherTypeEnum"
         },
         {
             "name": "algorithmName",
             "baseName": "algorithmName",
             "type": "string"
         },
         {
             "name": "sizeInBytes",
             "baseName": "sizeInBytes",
             "type": "number"
         },
         {
             "name": "destinationLocation",
             "baseName": "destinationLocation",
             "type": "string"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.HashTypeEnum"
         },
         {
             "name": "destinationHash",
             "baseName": "destinationHash",
             "type": "string"
         },
         {
             "name": "parameters",
             "baseName": "parameters",
             "type": "{ [key: string]: string; }"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus {
     export enum StatusCodeEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
     export enum CipherTypeEnum {
         Encryption = <any> 'encryption',
         Decryption = <any> 'decryption'
     }
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
 }
 export class MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus {
     'statusCode'?: MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.StatusCodeEnum;
     'errorCode'?: number;
     'errorInfo'?: string;
     'destinationLocation'?: string;
     'destinationHash'?: string;
     'hashType'?: MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.HashTypeEnum;
     'secondaryDistributionHashType'?: MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.SecondaryDistributionHashTypeEnum;
     'secondaryDistributionHash'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "statusCode",
             "baseName": "statusCode",
             "type": "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.StatusCodeEnum"
         },
         {
             "name": "errorCode",
             "baseName": "errorCode",
             "type": "number"
         },
         {
             "name": "errorInfo",
             "baseName": "errorInfo",
             "type": "string"
         },
         {
             "name": "destinationLocation",
             "baseName": "destinationLocation",
             "type": "string"
         },
         {
             "name": "destinationHash",
             "baseName": "destinationHash",
             "type": "string"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.HashTypeEnum"
         },
         {
             "name": "secondaryDistributionHashType",
             "baseName": "secondaryDistributionHashType",
             "type": "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.SecondaryDistributionHashTypeEnum"
         },
         {
             "name": "secondaryDistributionHash",
             "baseName": "secondaryDistributionHash",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus {
     export enum StatusCodeEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
     export enum SecondaryDistributionHashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
 }
 export class MSEssGatewayClientContractsReleaseFileScanStatus {
     'statusCode'?: MSEssGatewayClientContractsReleaseFileScanStatus.StatusCodeEnum;
     'errorCode'?: number;
     'errorInfo'?: string;
     'fileCopyState'?: string;
     'fileCopyResult'?: string;
     'decompressionState'?: string;
     'decompressionResult'?: string;
     'decompressedFileCount'?: number;
     'scanningState'?: string;
     'scanningResult'?: string;
     'scanOperationId'?: string;
     'links'?: { [key: string]: string; };
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "statusCode",
             "baseName": "statusCode",
             "type": "MSEssGatewayClientContractsReleaseFileScanStatus.StatusCodeEnum"
         },
         {
             "name": "errorCode",
             "baseName": "errorCode",
             "type": "number"
         },
         {
             "name": "errorInfo",
             "baseName": "errorInfo",
             "type": "string"
         },
         {
             "name": "fileCopyState",
             "baseName": "fileCopyState",
             "type": "string"
         },
         {
             "name": "fileCopyResult",
             "baseName": "fileCopyResult",
             "type": "string"
         },
         {
             "name": "decompressionState",
             "baseName": "decompressionState",
             "type": "string"
         },
         {
             "name": "decompressionResult",
             "baseName": "decompressionResult",
             "type": "string"
         },
         {
             "name": "decompressedFileCount",
             "baseName": "decompressedFileCount",
             "type": "number"
         },
         {
             "name": "scanningState",
             "baseName": "scanningState",
             "type": "string"
         },
         {
             "name": "scanningResult",
             "baseName": "scanningResult",
             "type": "string"
         },
         {
             "name": "scanOperationId",
             "baseName": "scanOperationId",
             "type": "string"
         },
         {
             "name": "links",
             "baseName": "links",
             "type": "{ [key: string]: string; }"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseFileScanStatus.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseFileScanStatus {
     export enum StatusCodeEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsReleaseFileSignStatus {
     'statusCode'?: MSEssGatewayClientContractsReleaseFileSignStatus.StatusCodeEnum;
     'errorCode'?: number;
     'errorInfo'?: string;
     'destinationLocation'?: string;
     'hashType'?: MSEssGatewayClientContractsReleaseFileSignStatus.HashTypeEnum;
     'destinationHash'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "statusCode",
             "baseName": "statusCode",
             "type": "MSEssGatewayClientContractsReleaseFileSignStatus.StatusCodeEnum"
         },
         {
             "name": "errorCode",
             "baseName": "errorCode",
             "type": "number"
         },
         {
             "name": "errorInfo",
             "baseName": "errorInfo",
             "type": "string"
         },
         {
             "name": "destinationLocation",
             "baseName": "destinationLocation",
             "type": "string"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsReleaseFileSignStatus.HashTypeEnum"
         },
         {
             "name": "destinationHash",
             "baseName": "destinationHash",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseFileSignStatus.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseFileSignStatus {
     export enum StatusCodeEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
 }
 export class MSEssGatewayClientContractsReleaseFileVaultStatusInfo {
     'publisherCode'?: string;
     'publisherKey'?: string;
     'vaultRegion'?: string;
     'status'?: MSEssGatewayClientContractsReleaseFileVaultStatusInfo.StatusEnum;
     'comments'?: string;
     'timestamp'?: Date;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "publisherCode",
             "baseName": "publisherCode",
             "type": "string"
         },
         {
             "name": "publisherKey",
             "baseName": "publisherKey",
             "type": "string"
         },
         {
             "name": "vaultRegion",
             "baseName": "vaultRegion",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsReleaseFileVaultStatusInfo.StatusEnum"
         },
         {
             "name": "comments",
             "baseName": "comments",
             "type": "string"
         },
         {
             "name": "timestamp",
             "baseName": "timestamp",
             "type": "Date"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseFileVaultStatusInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseFileVaultStatusInfo {
     export enum StatusEnum {
         NotStarted = <any> 'notStarted',
         InProgress = <any> 'inProgress',
         Completed = <any> 'completed',
         Failed = <any> 'failed'
     }
 }
 export class MSEssGatewayClientContractsReleaseOwnerInfo {
     'owner'?: MSEssGatewayClientContractsReleaseUserInfo;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "owner",
             "baseName": "owner",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseOwnerInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseProductInfo {
     'name'?: string;
     'version'?: string;
     'description'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "description",
             "baseName": "description",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseProductInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo {
     'signStatus'?: MSEssGatewayClientContractsReleaseFileSignStatus;
     'encryptedDistributionBlobStatus'?: MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus;
     'scanStatus'?: MSEssGatewayClientContractsReleaseFileScanStatus;
     'preEncryptedDistributionBlobStatus'?: MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus;
     'vaultStatus'?: MSEssGatewayClientContractsReleaseFileVaultStatusInfo;
     'fileId'?: string;
     'distributionRelativePath'?: string;
     'partNumber'?: string;
     'friendlyFileName'?: string;
     'tenantFileLocationType'?: string;
     'tenantFileLocation'?: string;
     'signedEngineeringCopyLocation'?: string;
     'encryptedDistributionBlobLocation'?: string;
     'preEncryptedDistributionBlobLocation'?: string;
     'secondaryDistributionHashRequired'?: boolean;
     'secondaryDistributionHashType'?: MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.SecondaryDistributionHashTypeEnum;
     'lastModifiedAt'?: Date;
     'name'?: string;
     'hash'?: string;
     'sourceLocation'?: MSEssGatewayClientContractsFileLocation;
     'sizeInBytes'?: number;
     'hashType'?: MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.HashTypeEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "signStatus",
             "baseName": "signStatus",
             "type": "MSEssGatewayClientContractsReleaseFileSignStatus"
         },
         {
             "name": "encryptedDistributionBlobStatus",
             "baseName": "encryptedDistributionBlobStatus",
             "type": "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus"
         },
         {
             "name": "scanStatus",
             "baseName": "scanStatus",
             "type": "MSEssGatewayClientContractsReleaseFileScanStatus"
         },
         {
             "name": "preEncryptedDistributionBlobStatus",
             "baseName": "preEncryptedDistributionBlobStatus",
             "type": "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus"
         },
         {
             "name": "vaultStatus",
             "baseName": "vaultStatus",
             "type": "MSEssGatewayClientContractsReleaseFileVaultStatusInfo"
         },
         {
             "name": "fileId",
             "baseName": "fileId",
             "type": "string"
         },
         {
             "name": "distributionRelativePath",
             "baseName": "distributionRelativePath",
             "type": "string"
         },
         {
             "name": "partNumber",
             "baseName": "partNumber",
             "type": "string"
         },
         {
             "name": "friendlyFileName",
             "baseName": "friendlyFileName",
             "type": "string"
         },
         {
             "name": "tenantFileLocationType",
             "baseName": "tenantFileLocationType",
             "type": "string"
         },
         {
             "name": "tenantFileLocation",
             "baseName": "tenantFileLocation",
             "type": "string"
         },
         {
             "name": "signedEngineeringCopyLocation",
             "baseName": "signedEngineeringCopyLocation",
             "type": "string"
         },
         {
             "name": "encryptedDistributionBlobLocation",
             "baseName": "encryptedDistributionBlobLocation",
             "type": "string"
         },
         {
             "name": "preEncryptedDistributionBlobLocation",
             "baseName": "preEncryptedDistributionBlobLocation",
             "type": "string"
         },
         {
             "name": "secondaryDistributionHashRequired",
             "baseName": "secondaryDistributionHashRequired",
             "type": "boolean"
         },
         {
             "name": "secondaryDistributionHashType",
             "baseName": "secondaryDistributionHashType",
             "type": "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.SecondaryDistributionHashTypeEnum"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "hash",
             "baseName": "hash",
             "type": "string"
         },
         {
             "name": "sourceLocation",
             "baseName": "sourceLocation",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "sizeInBytes",
             "baseName": "sizeInBytes",
             "type": "number"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.HashTypeEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo {
     export enum SecondaryDistributionHashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
 }
 export class MSEssGatewayClientContractsReleaseReleaseFileInfo {
     'fileId'?: string;
     'distributionRelativePath'?: string;
     'partNumber'?: string;
     'friendlyFileName'?: string;
     'tenantFileLocationType'?: string;
     'tenantFileLocation'?: string;
     'signedEngineeringCopyLocation'?: string;
     'encryptedDistributionBlobLocation'?: string;
     'preEncryptedDistributionBlobLocation'?: string;
     'secondaryDistributionHashRequired'?: boolean;
     'secondaryDistributionHashType'?: MSEssGatewayClientContractsReleaseReleaseFileInfo.SecondaryDistributionHashTypeEnum;
     'lastModifiedAt'?: Date;
     'name'?: string;
     'hash'?: string;
     'sourceLocation'?: MSEssGatewayClientContractsFileLocation;
     'sizeInBytes'?: number;
     'hashType'?: MSEssGatewayClientContractsReleaseReleaseFileInfo.HashTypeEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "fileId",
             "baseName": "fileId",
             "type": "string"
         },
         {
             "name": "distributionRelativePath",
             "baseName": "distributionRelativePath",
             "type": "string"
         },
         {
             "name": "partNumber",
             "baseName": "partNumber",
             "type": "string"
         },
         {
             "name": "friendlyFileName",
             "baseName": "friendlyFileName",
             "type": "string"
         },
         {
             "name": "tenantFileLocationType",
             "baseName": "tenantFileLocationType",
             "type": "string"
         },
         {
             "name": "tenantFileLocation",
             "baseName": "tenantFileLocation",
             "type": "string"
         },
         {
             "name": "signedEngineeringCopyLocation",
             "baseName": "signedEngineeringCopyLocation",
             "type": "string"
         },
         {
             "name": "encryptedDistributionBlobLocation",
             "baseName": "encryptedDistributionBlobLocation",
             "type": "string"
         },
         {
             "name": "preEncryptedDistributionBlobLocation",
             "baseName": "preEncryptedDistributionBlobLocation",
             "type": "string"
         },
         {
             "name": "secondaryDistributionHashRequired",
             "baseName": "secondaryDistributionHashRequired",
             "type": "boolean"
         },
         {
             "name": "secondaryDistributionHashType",
             "baseName": "secondaryDistributionHashType",
             "type": "MSEssGatewayClientContractsReleaseReleaseFileInfo.SecondaryDistributionHashTypeEnum"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "hash",
             "baseName": "hash",
             "type": "string"
         },
         {
             "name": "sourceLocation",
             "baseName": "sourceLocation",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "sizeInBytes",
             "baseName": "sizeInBytes",
             "type": "number"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsReleaseReleaseFileInfo.HashTypeEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseReleaseFileInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseReleaseFileInfo {
     export enum SecondaryDistributionHashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
 }
 export class MSEssGatewayClientContractsReleaseReleaseInfo {
     'title'?: string;
     'minimumNumberOfApprovers'?: number;
     'properties'?: MSEssGatewayClientContractsReleaseReleaseInfoProperties;
     'isRevision'?: boolean;
     'revisionNumber'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "title",
             "baseName": "title",
             "type": "string"
         },
         {
             "name": "minimumNumberOfApprovers",
             "baseName": "minimumNumberOfApprovers",
             "type": "number"
         },
         {
             "name": "properties",
             "baseName": "properties",
             "type": "MSEssGatewayClientContractsReleaseReleaseInfoProperties"
         },
         {
             "name": "isRevision",
             "baseName": "isRevision",
             "type": "boolean"
         },
         {
             "name": "revisionNumber",
             "baseName": "revisionNumber",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseReleaseInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseReleaseInfoProperties {
     'releaseContentType'?: string;
     'isRsm'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "releaseContentType",
             "baseName": "releaseContentType",
             "type": "string"
         },
         {
             "name": "isRsm",
             "baseName": "isRsm",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseReleaseInfoProperties.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo {
     'publisherCode'?: string;
     'publisherKey'?: string;
     'vaultRegion'?: string;
     'status'?: MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.StatusEnum;
     'comments'?: string;
     'timestamp'?: Date;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "publisherCode",
             "baseName": "publisherCode",
             "type": "string"
         },
         {
             "name": "publisherKey",
             "baseName": "publisherKey",
             "type": "string"
         },
         {
             "name": "vaultRegion",
             "baseName": "vaultRegion",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.StatusEnum"
         },
         {
             "name": "comments",
             "baseName": "comments",
             "type": "string"
         },
         {
             "name": "timestamp",
             "baseName": "timestamp",
             "type": "Date"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo {
     export enum StatusEnum {
         NotStarted = <any> 'notStarted',
         InProgress = <any> 'inProgress',
         Completed = <any> 'completed',
         Failed = <any> 'failed'
     }
 }
 export class MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage {
     'operationId'?: string;
     'actionTakenBy'?: MSEssGatewayClientContractsReleaseUserInfo;
     'comments'?: string;
     'publisherId'?: string;
     'jwsToken'?: string;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "actionTakenBy",
             "baseName": "actionTakenBy",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         },
         {
             "name": "comments",
             "baseName": "comments",
             "type": "string"
         },
         {
             "name": "publisherId",
             "baseName": "publisherId",
             "type": "string"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage {
     'publisherId'?: string;
     'jwsToken'?: string;
     'operationId'?: string;
     'actionTakenBy'?: MSEssGatewayClientContractsReleaseUserInfo;
     'owners'?: Array<MSEssGatewayClientContractsReleaseEditOwnerInfo>;
     'approvers'?: Array<MSEssGatewayClientContractsReleaseEditApproverInfo>;
     'authorizedDownloadUsers'?: Array<MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo>;
     'channelDownloadEntities'?: Array<MSEssGatewayClientContractsReleaseEditChannelDownloadEntity>;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "publisherId",
             "baseName": "publisherId",
             "type": "string"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "actionTakenBy",
             "baseName": "actionTakenBy",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         },
         {
             "name": "owners",
             "baseName": "owners",
             "type": "Array<MSEssGatewayClientContractsReleaseEditOwnerInfo>"
         },
         {
             "name": "approvers",
             "baseName": "approvers",
             "type": "Array<MSEssGatewayClientContractsReleaseEditApproverInfo>"
         },
         {
             "name": "authorizedDownloadUsers",
             "baseName": "authorizedDownloadUsers",
             "type": "Array<MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo>"
         },
         {
             "name": "channelDownloadEntities",
             "baseName": "channelDownloadEntities",
             "type": "Array<MSEssGatewayClientContractsReleaseEditChannelDownloadEntity>"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage {
     'releaseInfo'?: MSEssGatewayClientContractsReleaseReleaseInfo;
     'productInfo'?: MSEssGatewayClientContractsReleaseProductInfo;
     'files'?: Array<MSEssGatewayClientContractsReleaseReleaseFileInfo>;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'createdBy'?: MSEssGatewayClientContractsReleaseUserInfo;
     'owners'?: Array<MSEssGatewayClientContractsReleaseOwnerInfo>;
     'approvers'?: Array<MSEssGatewayClientContractsReleaseApproverInfo>;
     'authorizedDownloadUsers'?: Array<MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo>;
     'accessPermissionsInfo'?: MSEssGatewayClientContractsReleaseAccessPermissionsInfo;
     'jwsToken'?: string;
     'publisherId'?: string;
     'signingInfo'?: MSEssGatewayClientContractsSignFileInfo;
     'cipherInfo'?: MSEssGatewayClientContractsCipherInfo;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "releaseInfo",
             "baseName": "releaseInfo",
             "type": "MSEssGatewayClientContractsReleaseReleaseInfo"
         },
         {
             "name": "productInfo",
             "baseName": "productInfo",
             "type": "MSEssGatewayClientContractsReleaseProductInfo"
         },
         {
             "name": "files",
             "baseName": "files",
             "type": "Array<MSEssGatewayClientContractsReleaseReleaseFileInfo>"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "createdBy",
             "baseName": "createdBy",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         },
         {
             "name": "owners",
             "baseName": "owners",
             "type": "Array<MSEssGatewayClientContractsReleaseOwnerInfo>"
         },
         {
             "name": "approvers",
             "baseName": "approvers",
             "type": "Array<MSEssGatewayClientContractsReleaseApproverInfo>"
         },
         {
             "name": "authorizedDownloadUsers",
             "baseName": "authorizedDownloadUsers",
             "type": "Array<MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo>"
         },
         {
             "name": "accessPermissionsInfo",
             "baseName": "accessPermissionsInfo",
             "type": "MSEssGatewayClientContractsReleaseAccessPermissionsInfo"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "publisherId",
             "baseName": "publisherId",
             "type": "string"
         },
         {
             "name": "signingInfo",
             "baseName": "signingInfo",
             "type": "MSEssGatewayClientContractsSignFileInfo"
         },
         {
             "name": "cipherInfo",
             "baseName": "cipherInfo",
             "type": "MSEssGatewayClientContractsCipherInfo"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage {
     'operationId'?: string;
     'actionTakenBy'?: MSEssGatewayClientContractsReleaseUserInfo;
     'approvalStatus'?: MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.ApprovalStatusEnum;
     'comments'?: string;
     'publisherId'?: string;
     'jwsToken'?: string;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "actionTakenBy",
             "baseName": "actionTakenBy",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         },
         {
             "name": "approvalStatus",
             "baseName": "approvalStatus",
             "type": "MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.ApprovalStatusEnum"
         },
         {
             "name": "comments",
             "baseName": "comments",
             "type": "string"
         },
         {
             "name": "publisherId",
             "baseName": "publisherId",
             "type": "string"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage {
     export enum ApprovalStatusEnum {
         Pending = <any> 'pending',
         Approved = <any> 'approved',
         Rejected = <any> 'rejected'
     }
 }
 export class MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage {
     'operationId'?: string;
     'clusterRegion'?: string;
     'notificationMessages'?: Array<MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo>;
     'jwsToken'?: string;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "clusterRegion",
             "baseName": "clusterRegion",
             "type": "string"
         },
         {
             "name": "notificationMessages",
             "baseName": "notificationMessages",
             "type": "Array<MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo>"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseResponseApproverInfoDetails {
     'approvalStatus'?: MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.ApprovalStatusEnum;
     'comments'?: string;
     'actionTakenAt'?: Date;
     'approver'?: MSEssGatewayClientContractsReleaseUserInfo;
     'isAutoApproved'?: boolean;
     'isMandatory'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "approvalStatus",
             "baseName": "approvalStatus",
             "type": "MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.ApprovalStatusEnum"
         },
         {
             "name": "comments",
             "baseName": "comments",
             "type": "string"
         },
         {
             "name": "actionTakenAt",
             "baseName": "actionTakenAt",
             "type": "Date"
         },
         {
             "name": "approver",
             "baseName": "approver",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         },
         {
             "name": "isAutoApproved",
             "baseName": "isAutoApproved",
             "type": "boolean"
         },
         {
             "name": "isMandatory",
             "baseName": "isMandatory",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseResponseApproverInfoDetails {
     export enum ApprovalStatusEnum {
         Pending = <any> 'pending',
         Approved = <any> 'approved',
         Rejected = <any> 'rejected'
     }
 }
 export class MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo {
     'activityId'?: string;
     'activityType'?: string;
     'name'?: string;
     'status'?: string;
     'errorCode'?: number;
     'errorMessages'?: Array<string>;
     'beginTime'?: Date;
     'endTime'?: Date;
     'lastModifiedAt'?: Date;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "activityId",
             "baseName": "activityId",
             "type": "string"
         },
         {
             "name": "activityType",
             "baseName": "activityType",
             "type": "string"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "string"
         },
         {
             "name": "errorCode",
             "baseName": "errorCode",
             "type": "number"
         },
         {
             "name": "errorMessages",
             "baseName": "errorMessages",
             "type": "Array<string>"
         },
         {
             "name": "beginTime",
             "baseName": "beginTime",
             "type": "Date"
         },
         {
             "name": "endTime",
             "baseName": "endTime",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage {
     'clientId'?: string;
     'clusterRegion'?: string;
     'correlationVector'?: string;
     'releaseCompletedAt'?: Date;
     'releaseInfo'?: MSEssGatewayClientContractsReleaseReleaseInfo;
     'productInfo'?: MSEssGatewayClientContractsReleaseProductInfo;
     'createdBy'?: MSEssGatewayClientContractsReleaseUserInfo;
     'owners'?: Array<MSEssGatewayClientContractsReleaseOwnerInfo>;
     'approvers'?: Array<MSEssGatewayClientContractsReleaseResponseApproverInfoDetails>;
     'authorizedDownloadUsers'?: Array<MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo>;
     'accessPermissionsInfo'?: MSEssGatewayClientContractsReleaseAccessPermissionsInfo;
     'files'?: Array<MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo>;
     'comments'?: Array<string>;
     'cancellationReason'?: string;
     'totalReleaseSize'?: number;
     'totalFileCount'?: number;
     'version'?: string;
     'activities'?: Array<MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo>;
     'releaseError'?: MSEssGatewayClientContractsReleaseResponseReleaseError;
     'childworkflowType'?: string;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "clusterRegion",
             "baseName": "clusterRegion",
             "type": "string"
         },
         {
             "name": "correlationVector",
             "baseName": "correlationVector",
             "type": "string"
         },
         {
             "name": "releaseCompletedAt",
             "baseName": "releaseCompletedAt",
             "type": "Date"
         },
         {
             "name": "releaseInfo",
             "baseName": "releaseInfo",
             "type": "MSEssGatewayClientContractsReleaseReleaseInfo"
         },
         {
             "name": "productInfo",
             "baseName": "productInfo",
             "type": "MSEssGatewayClientContractsReleaseProductInfo"
         },
         {
             "name": "createdBy",
             "baseName": "createdBy",
             "type": "MSEssGatewayClientContractsReleaseUserInfo"
         },
         {
             "name": "owners",
             "baseName": "owners",
             "type": "Array<MSEssGatewayClientContractsReleaseOwnerInfo>"
         },
         {
             "name": "approvers",
             "baseName": "approvers",
             "type": "Array<MSEssGatewayClientContractsReleaseResponseApproverInfoDetails>"
         },
         {
             "name": "authorizedDownloadUsers",
             "baseName": "authorizedDownloadUsers",
             "type": "Array<MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo>"
         },
         {
             "name": "accessPermissionsInfo",
             "baseName": "accessPermissionsInfo",
             "type": "MSEssGatewayClientContractsReleaseAccessPermissionsInfo"
         },
         {
             "name": "files",
             "baseName": "files",
             "type": "Array<MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo>"
         },
         {
             "name": "comments",
             "baseName": "comments",
             "type": "Array<string>"
         },
         {
             "name": "cancellationReason",
             "baseName": "cancellationReason",
             "type": "string"
         },
         {
             "name": "totalReleaseSize",
             "baseName": "totalReleaseSize",
             "type": "number"
         },
         {
             "name": "totalFileCount",
             "baseName": "totalFileCount",
             "type": "number"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "activities",
             "baseName": "activities",
             "type": "Array<MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo>"
         },
         {
             "name": "releaseError",
             "baseName": "releaseError",
             "type": "MSEssGatewayClientContractsReleaseResponseReleaseError"
         },
         {
             "name": "childworkflowType",
             "baseName": "childworkflowType",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsReleaseResponseReleaseEditResponse {
     'requestId'?: string;
     'operationId'?: string;
     'esrpCorrelationId'?: string;
     'error'?: MSEssGatewayClientContractsGatewayError;
     'statusLocation'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "requestId",
             "baseName": "requestId",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "error",
             "baseName": "error",
             "type": "MSEssGatewayClientContractsGatewayError"
         },
         {
             "name": "statusLocation",
             "baseName": "statusLocation",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseResponseReleaseEditResponse.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage {
     'version'?: string;
     'requestId'?: string;
     'releaseEditSections'?: Array<MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo>;
     'releaseError'?: MSEssGatewayClientContractsReleaseResponseReleaseError;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "requestId",
             "baseName": "requestId",
             "type": "string"
         },
         {
             "name": "releaseEditSections",
             "baseName": "releaseEditSections",
             "type": "Array<MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo>"
         },
         {
             "name": "releaseError",
             "baseName": "releaseError",
             "type": "MSEssGatewayClientContractsReleaseResponseReleaseError"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo {
     'name'?: string;
     'statusCode'?: string;
     'errorCode'?: number;
     'errorInfo'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "statusCode",
             "baseName": "statusCode",
             "type": "string"
         },
         {
             "name": "errorCode",
             "baseName": "errorCode",
             "type": "number"
         },
         {
             "name": "errorInfo",
             "baseName": "errorInfo",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseResponseReleaseError {
     'errorCode'?: number;
     'errorMessages'?: Array<string>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "errorCode",
             "baseName": "errorCode",
             "type": "number"
         },
         {
             "name": "errorMessages",
             "baseName": "errorMessages",
             "type": "Array<string>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseResponseReleaseError.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsReleaseResponseReleaseResultMessage {
     'version'?: string;
     'activities'?: Array<MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo>;
     'releaseError'?: MSEssGatewayClientContractsReleaseResponseReleaseError;
     'totalReleaseSize'?: number;
     'totalFileCount'?: number;
     'childworkflowType'?: string;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "activities",
             "baseName": "activities",
             "type": "Array<MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo>"
         },
         {
             "name": "releaseError",
             "baseName": "releaseError",
             "type": "MSEssGatewayClientContractsReleaseResponseReleaseError"
         },
         {
             "name": "totalReleaseSize",
             "baseName": "totalReleaseSize",
             "type": "number"
         },
         {
             "name": "totalFileCount",
             "baseName": "totalFileCount",
             "type": "number"
         },
         {
             "name": "childworkflowType",
             "baseName": "childworkflowType",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsReleaseResponseReleaseResultMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsReleaseUserInfo {
     'userPrincipalName'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "userPrincipalName",
             "baseName": "userPrincipalName",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsReleaseUserInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsRequestDetails {
     'operationId'?: string;
     'status'?: MSEssGatewayClientContractsRequestDetails.StatusEnum;
     'errorCode'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsRequestDetails.StatusEnum"
         },
         {
             "name": "errorCode",
             "baseName": "errorCode",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsRequestDetails.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsRequestDetails {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsRoutingInfo {
     'intent'?: string;
     'contentType'?: string;
     'contentOrigin'?: string;
     'productState'?: string;
     'audience'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "intent",
             "baseName": "intent",
             "type": "string"
         },
         {
             "name": "contentType",
             "baseName": "contentType",
             "type": "string"
         },
         {
             "name": "contentOrigin",
             "baseName": "contentOrigin",
             "type": "string"
         },
         {
             "name": "productState",
             "baseName": "productState",
             "type": "string"
         },
         {
             "name": "audience",
             "baseName": "audience",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsRoutingInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsScanFileInfo {
     'name'?: string;
     'hash'?: string;
     'sourceLocation'?: MSEssGatewayClientContractsFileLocation;
     'sizeInBytes'?: number;
     'hashType'?: MSEssGatewayClientContractsScanFileInfo.HashTypeEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "hash",
             "baseName": "hash",
             "type": "string"
         },
         {
             "name": "sourceLocation",
             "baseName": "sourceLocation",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "sizeInBytes",
             "baseName": "sizeInBytes",
             "type": "number"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsScanFileInfo.HashTypeEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsScanFileInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsScanFileInfo {
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
 }
 export class MSEssGatewayClientContractsScanGroupResult {
     'groupId'?: string;
     'result'?: MSEssGatewayClientContractsScanGroupResult.ResultEnum;
     'lastUpdatedAt'?: Date;
     'requests'?: Array<MSEssGatewayClientContractsRequestDetails>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "result",
             "baseName": "result",
             "type": "MSEssGatewayClientContractsScanGroupResult.ResultEnum"
         },
         {
             "name": "lastUpdatedAt",
             "baseName": "lastUpdatedAt",
             "type": "Date"
         },
         {
             "name": "requests",
             "baseName": "requests",
             "type": "Array<MSEssGatewayClientContractsRequestDetails>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsScanGroupResult.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsScanGroupResult {
     export enum ResultEnum {
         NotDetermined = <any> 'notDetermined',
         Clean = <any> 'clean',
         MalwareFound = <any> 'malwareFound',
         Inprogress = <any> 'inprogress',
         PendingAnalysis = <any> 'pendingAnalysis',
         Failed = <any> 'failed'
     }
 }
 export class MSEssGatewayClientContractsScanRequestMessage {
     'file'?: MSEssGatewayClientContractsScanFileInfo;
     'region'?: MSEssGatewayClientContractsScanRequestMessage.RegionEnum;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'isAutoResubmitWhenFailCanRetry'?: boolean;
     'autoResubmisionFailCanRetryCount'?: number;
     'requestExpiresAt'?: Date;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "file",
             "baseName": "file",
             "type": "MSEssGatewayClientContractsScanFileInfo"
         },
         {
             "name": "region",
             "baseName": "region",
             "type": "MSEssGatewayClientContractsScanRequestMessage.RegionEnum"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "isAutoResubmitWhenFailCanRetry",
             "baseName": "isAutoResubmitWhenFailCanRetry",
             "type": "boolean"
         },
         {
             "name": "autoResubmisionFailCanRetryCount",
             "baseName": "autoResubmisionFailCanRetryCount",
             "type": "number"
         },
         {
             "name": "requestExpiresAt",
             "baseName": "requestExpiresAt",
             "type": "Date"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsScanRequestMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsScanRequestMessage {
     export enum RegionEnum {
         None = <any> 'none',
         PuertoRico = <any> 'puertoRico',
         Us = <any> 'us',
         Dublin = <any> 'dublin',
         Singapore = <any> 'singapore'
     }
 }
 export class MSEssGatewayClientContractsScanResultMessage {
     'sourceFileHash'?: string;
     'hashType'?: MSEssGatewayClientContractsScanResultMessage.HashTypeEnum;
     'decompressedHashCount'?: number;
     'workflowType'?: MSEssGatewayClientContractsScanResultMessage.WorkflowTypeEnum;
     'fileSizeInBytes'?: number;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsScanResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "sourceFileHash",
             "baseName": "sourceFileHash",
             "type": "string"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsScanResultMessage.HashTypeEnum"
         },
         {
             "name": "decompressedHashCount",
             "baseName": "decompressedHashCount",
             "type": "number"
         },
         {
             "name": "workflowType",
             "baseName": "workflowType",
             "type": "MSEssGatewayClientContractsScanResultMessage.WorkflowTypeEnum"
         },
         {
             "name": "fileSizeInBytes",
             "baseName": "fileSizeInBytes",
             "type": "number"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsScanResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsScanResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsScanResultMessage {
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
     export enum WorkflowTypeEnum {
         None = <any> 'none',
         Scan = <any> 'scan',
         SignAndScan = <any> 'signAndScan',
         Release = <any> 'release',
         DigestSign = <any> 'digestSign',
         Pkita = <any> 'pkita',
         Simulation = <any> 'simulation',
         Crypto = <any> 'crypto',
         SignAndLazyScan = <any> 'signAndLazyScan',
         SignWithAsyncScan = <any> 'signWithAsyncScan',
         ReleaseWithAsyncScan = <any> 'releaseWithAsyncScan',
         SignOnly = <any> 'signOnly',
         ReleaseWithAsyncCrypto = <any> 'releaseWithAsyncCrypto',
         SignWithNonBlockingScan = <any> 'signWithNonBlockingScan',
         FileTransfer = <any> 'fileTransfer',
         Vault = <any> 'vault',
         VaultWithAsyncFileTransfer = <any> 'vaultWithAsyncFileTransfer'
     }
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsSessionRequestMessage {
     'expiresAfter'?: string;
     'partitionCount'?: number;
     'isProvisionStorage'?: boolean;
     'isLegacyCopsModel'?: boolean;
     'commandName'?: string;
     'intent'?: string;
     'contentType'?: string;
     'contentOrigin'?: string;
     'productState'?: string;
     'audience'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "expiresAfter",
             "baseName": "expiresAfter",
             "type": "string"
         },
         {
             "name": "partitionCount",
             "baseName": "partitionCount",
             "type": "number"
         },
         {
             "name": "isProvisionStorage",
             "baseName": "isProvisionStorage",
             "type": "boolean"
         },
         {
             "name": "isLegacyCopsModel",
             "baseName": "isLegacyCopsModel",
             "type": "boolean"
         },
         {
             "name": "commandName",
             "baseName": "commandName",
             "type": "string"
         },
         {
             "name": "intent",
             "baseName": "intent",
             "type": "string"
         },
         {
             "name": "contentType",
             "baseName": "contentType",
             "type": "string"
         },
         {
             "name": "contentOrigin",
             "baseName": "contentOrigin",
             "type": "string"
         },
         {
             "name": "productState",
             "baseName": "productState",
             "type": "string"
         },
         {
             "name": "audience",
             "baseName": "audience",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsSessionRequestMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsSessionResultMessage {
     'clientConfig'?: MSEssGatewayClientContractsEsrpClientConfigInfo3;
     'policyResult'?: MSEssGatewayClientContractsPolicyResultMessage;
     'storageResult'?: MSEssGatewayClientContractsProvisionStorageResultMessage;
     'digestSignMapping'?: MSEssGatewayClientContractsDigestSignMapping;
     'legacyCopsMapping'?: Array<MSEssGatewayClientContractsLegacyCopsMappingData>;
     'digestSignOperationErrorPatterns'?: Array<MSEssGatewayClientContractsDigestSignOperationErrorPatterns>;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsSessionResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "clientConfig",
             "baseName": "clientConfig",
             "type": "MSEssGatewayClientContractsEsrpClientConfigInfo3"
         },
         {
             "name": "policyResult",
             "baseName": "policyResult",
             "type": "MSEssGatewayClientContractsPolicyResultMessage"
         },
         {
             "name": "storageResult",
             "baseName": "storageResult",
             "type": "MSEssGatewayClientContractsProvisionStorageResultMessage"
         },
         {
             "name": "digestSignMapping",
             "baseName": "digestSignMapping",
             "type": "MSEssGatewayClientContractsDigestSignMapping"
         },
         {
             "name": "legacyCopsMapping",
             "baseName": "legacyCopsMapping",
             "type": "Array<MSEssGatewayClientContractsLegacyCopsMappingData>"
         },
         {
             "name": "digestSignOperationErrorPatterns",
             "baseName": "digestSignOperationErrorPatterns",
             "type": "Array<MSEssGatewayClientContractsDigestSignOperationErrorPatterns>"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsSessionResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsSessionResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsSessionResultMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsSignFileInfo {
     'destinationLocation'?: MSEssGatewayClientContractsFileLocation;
     'signingOperations'?: Array<MSEssGatewayClientContractsStaticSigningOperation>;
     'dynamicSigningOperations'?: Array<MSEssGatewayClientContractsDynamicSigningOperation>;
     'name'?: string;
     'hash'?: string;
     'sourceLocation'?: MSEssGatewayClientContractsFileLocation;
     'sizeInBytes'?: number;
     'hashType'?: MSEssGatewayClientContractsSignFileInfo.HashTypeEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "destinationLocation",
             "baseName": "destinationLocation",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "signingOperations",
             "baseName": "signingOperations",
             "type": "Array<MSEssGatewayClientContractsStaticSigningOperation>"
         },
         {
             "name": "dynamicSigningOperations",
             "baseName": "dynamicSigningOperations",
             "type": "Array<MSEssGatewayClientContractsDynamicSigningOperation>"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "hash",
             "baseName": "hash",
             "type": "string"
         },
         {
             "name": "sourceLocation",
             "baseName": "sourceLocation",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "sizeInBytes",
             "baseName": "sizeInBytes",
             "type": "number"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsSignFileInfo.HashTypeEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsSignFileInfo.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsSignFileInfo {
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
 }
 export class MSEssGatewayClientContractsSignRequestMessage {
     'file'?: MSEssGatewayClientContractsSignFileInfo;
     'jwsToken'?: string;
     'clientId'?: string;
     'region'?: MSEssGatewayClientContractsSignRequestMessage.RegionEnum;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'requestExpiresAt'?: Date;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "file",
             "baseName": "file",
             "type": "MSEssGatewayClientContractsSignFileInfo"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "region",
             "baseName": "region",
             "type": "MSEssGatewayClientContractsSignRequestMessage.RegionEnum"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "requestExpiresAt",
             "baseName": "requestExpiresAt",
             "type": "Date"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsSignRequestMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsSignRequestMessage {
     export enum RegionEnum {
         None = <any> 'none',
         PuertoRico = <any> 'puertoRico',
         Us = <any> 'us',
         Dublin = <any> 'dublin',
         Singapore = <any> 'singapore'
     }
 }
 export class MSEssGatewayClientContractsSignResultMessage {
     'sourceFileHash'?: string;
     'destinationFileHash'?: string;
     'destinationLocation'?: MSEssGatewayClientContractsFileLocation;
     'hashType'?: MSEssGatewayClientContractsSignResultMessage.HashTypeEnum;
     'certificateThumbprint'?: string;
     'fileName'?: string;
     'fileSize'?: number;
     'isSignOnly_'?: boolean;
     'destinationFileSasUrl_'?: string;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsSignResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "sourceFileHash",
             "baseName": "sourceFileHash",
             "type": "string"
         },
         {
             "name": "destinationFileHash",
             "baseName": "destinationFileHash",
             "type": "string"
         },
         {
             "name": "destinationLocation",
             "baseName": "destinationLocation",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "hashType",
             "baseName": "hashType",
             "type": "MSEssGatewayClientContractsSignResultMessage.HashTypeEnum"
         },
         {
             "name": "certificateThumbprint",
             "baseName": "certificateThumbprint",
             "type": "string"
         },
         {
             "name": "fileName",
             "baseName": "fileName",
             "type": "string"
         },
         {
             "name": "fileSize",
             "baseName": "fileSize",
             "type": "number"
         },
         {
             "name": "isSignOnly_",
             "baseName": "isSignOnly ",
             "type": "boolean"
         },
         {
             "name": "destinationFileSasUrl_",
             "baseName": "destinationFileSasUrl ",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsSignResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsSignResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsSignResultMessage {
     export enum HashTypeEnum {
         Sha256 = <any> 'sha256',
         Sha1 = <any> 'sha1'
     }
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsSigningParameter {
     'parameterName'?: string;
     'parameterValue'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "parameterName",
             "baseName": "parameterName",
             "type": "string"
         },
         {
             "name": "parameterValue",
             "baseName": "parameterValue",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsSigningParameter.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsSlkRequestSlkRequestMessage {
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'jwsToken'?: string;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsSlkRequestSlkRequestMessage.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse {
     'rangeId'?: string;
     'groupId'?: number;
     'partNumber'?: string;
     'publicKey'?: string;
     'semiPrivateKey'?: string;
     'errorCode'?: number;
     'errorDescription'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "rangeId",
             "baseName": "rangeId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "number"
         },
         {
             "name": "partNumber",
             "baseName": "partNumber",
             "type": "string"
         },
         {
             "name": "publicKey",
             "baseName": "publicKey",
             "type": "string"
         },
         {
             "name": "semiPrivateKey",
             "baseName": "semiPrivateKey",
             "type": "string"
         },
         {
             "name": "errorCode",
             "baseName": "errorCode",
             "type": "number"
         },
         {
             "name": "errorDescription",
             "baseName": "errorDescription",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_ {
     'version'?: string;
     'response'?: MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "response",
             "baseName": "response",
             "type": "MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_ {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientContractsStaticSigningOperation {
     'keyCode'?: string;
     'operationSetCode'?: string;
     'parameters'?: Array<MSEssGatewayClientContractsSigningParameter>;
     'toolName'?: string;
     'toolVersion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "keyCode",
             "baseName": "keyCode",
             "type": "string"
         },
         {
             "name": "operationSetCode",
             "baseName": "operationSetCode",
             "type": "string"
         },
         {
             "name": "parameters",
             "baseName": "parameters",
             "type": "Array<MSEssGatewayClientContractsSigningParameter>"
         },
         {
             "name": "toolName",
             "baseName": "toolName",
             "type": "string"
         },
         {
             "name": "toolVersion",
             "baseName": "toolVersion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsStaticSigningOperation.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientContractsStorageShard {
     'shardLocation'?: MSEssGatewayClientContractsFileLocation;
     'lowKey'?: number;
     'highKey'?: number;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "shardLocation",
             "baseName": "shardLocation",
             "type": "MSEssGatewayClientContractsFileLocation"
         },
         {
             "name": "lowKey",
             "baseName": "lowKey",
             "type": "number"
         },
         {
             "name": "highKey",
             "baseName": "highKey",
             "type": "number"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientContractsStorageShard.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientOnPremContractsDigestSignRequestMessage {
     'algorithm'?: string;
     'keyCode'?: string;
     'hashes'?: Array<MSEssGatewayClientOnPremContractsHashInfo>;
     'region'?: MSEssGatewayClientOnPremContractsDigestSignRequestMessage.RegionEnum;
     'routingInfo'?: MSEssGatewayClientContractsRoutingInfo;
     'jwsToken'?: string;
     'isDynamic'?: boolean;
     'requestExpiresAt'?: Date;
     'publicCert'?: string;
     'driEmail'?: Array<string>;
     'groupId'?: string;
     'customerCorrelationId'?: string;
     'esrpCorrelationId'?: string;
     'version'?: string;
     'contextData'?: { [key: string]: string; };
     'features'?: Array<MSEssGatewayClientContractsIFeature>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "algorithm",
             "baseName": "algorithm",
             "type": "string"
         },
         {
             "name": "keyCode",
             "baseName": "keyCode",
             "type": "string"
         },
         {
             "name": "hashes",
             "baseName": "hashes",
             "type": "Array<MSEssGatewayClientOnPremContractsHashInfo>"
         },
         {
             "name": "region",
             "baseName": "region",
             "type": "MSEssGatewayClientOnPremContractsDigestSignRequestMessage.RegionEnum"
         },
         {
             "name": "routingInfo",
             "baseName": "routingInfo",
             "type": "MSEssGatewayClientContractsRoutingInfo"
         },
         {
             "name": "jwsToken",
             "baseName": "jwsToken",
             "type": "string"
         },
         {
             "name": "isDynamic",
             "baseName": "isDynamic",
             "type": "boolean"
         },
         {
             "name": "requestExpiresAt",
             "baseName": "requestExpiresAt",
             "type": "Date"
         },
         {
             "name": "publicCert",
             "baseName": "publicCert",
             "type": "string"
         },
         {
             "name": "driEmail",
             "baseName": "driEmail",
             "type": "Array<string>"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "esrpCorrelationId",
             "baseName": "esrpCorrelationId",
             "type": "string"
         },
         {
             "name": "version",
             "baseName": "version",
             "type": "string"
         },
         {
             "name": "contextData",
             "baseName": "contextData",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<MSEssGatewayClientContractsIFeature>"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientOnPremContractsDigestSignRequestMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientOnPremContractsDigestSignRequestMessage {
     export enum RegionEnum {
         None = <any> 'none',
         PuertoRico = <any> 'puertoRico',
         Us = <any> 'us',
         Dublin = <any> 'dublin',
         Singapore = <any> 'singapore'
     }
 }
 export class MSEssGatewayClientOnPremContractsDigestSignResultMessage {
     'algorithm'?: string;
     'keyCode'?: string;
     'signatures'?: Array<MSEssGatewayClientOnPremContractsSignedDigest>;
     'certificate'?: string;
     'operationJson'?: string;
     'operationId'?: string;
     'customerCorrelationId'?: string;
     'groupId'?: string;
     'status'?: MSEssGatewayClientOnPremContractsDigestSignResultMessage.StatusEnum;
     'errorinfo'?: MSEssGatewayClientContractsInnerServiceError;
     'requestSubmittedAt'?: Date;
     'lastModifiedAt'?: Date;
     'clientId'?: string;
     'routedRegion'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "algorithm",
             "baseName": "algorithm",
             "type": "string"
         },
         {
             "name": "keyCode",
             "baseName": "keyCode",
             "type": "string"
         },
         {
             "name": "signatures",
             "baseName": "signatures",
             "type": "Array<MSEssGatewayClientOnPremContractsSignedDigest>"
         },
         {
             "name": "certificate",
             "baseName": "certificate",
             "type": "string"
         },
         {
             "name": "operationJson",
             "baseName": "operationJson",
             "type": "string"
         },
         {
             "name": "operationId",
             "baseName": "operationId",
             "type": "string"
         },
         {
             "name": "customerCorrelationId",
             "baseName": "customerCorrelationId",
             "type": "string"
         },
         {
             "name": "groupId",
             "baseName": "groupId",
             "type": "string"
         },
         {
             "name": "status",
             "baseName": "status",
             "type": "MSEssGatewayClientOnPremContractsDigestSignResultMessage.StatusEnum"
         },
         {
             "name": "errorinfo",
             "baseName": "errorinfo",
             "type": "MSEssGatewayClientContractsInnerServiceError"
         },
         {
             "name": "requestSubmittedAt",
             "baseName": "requestSubmittedAt",
             "type": "Date"
         },
         {
             "name": "lastModifiedAt",
             "baseName": "lastModifiedAt",
             "type": "Date"
         },
         {
             "name": "clientId",
             "baseName": "clientId",
             "type": "string"
         },
         {
             "name": "routedRegion",
             "baseName": "routedRegion",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientOnPremContractsDigestSignResultMessage.attributeTypeMap;
     }
 }
 
 export namespace MSEssGatewayClientOnPremContractsDigestSignResultMessage {
     export enum StatusEnum {
         Pass = <any> 'pass',
         Inprogress = <any> 'inprogress',
         FailCanRetry = <any> 'failCanRetry',
         FailDoNotRetry = <any> 'failDoNotRetry',
         PendingAnalysis = <any> 'pendingAnalysis',
         Cancelled = <any> 'cancelled'
     }
 }
 export class MSEssGatewayClientOnPremContractsHashInfo {
     'digest'?: string;
     'hash'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "digest",
             "baseName": "digest",
             "type": "string"
         },
         {
             "name": "hash",
             "baseName": "hash",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientOnPremContractsHashInfo.attributeTypeMap;
     }
 }
 
 export class MSEssGatewayClientOnPremContractsSignedDigest {
     'digest'?: string;
     'hash'?: string;
     'signature'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "digest",
             "baseName": "digest",
             "type": "string"
         },
         {
             "name": "hash",
             "baseName": "hash",
             "type": "string"
         },
         {
             "name": "signature",
             "baseName": "signature",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MSEssGatewayClientOnPremContractsSignedDigest.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager {
     'httpContext'?: MicrosoftAspNetCoreHttpHttpContext;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "httpContext",
             "baseName": "httpContext",
             "type": "MicrosoftAspNetCoreHttpHttpContext"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpConnectionInfo {
     'id'?: string;
     'remoteIpAddress'?: SystemNetIPAddress;
     'remotePort'?: number;
     'localIpAddress'?: SystemNetIPAddress;
     'localPort'?: number;
     'clientCertificate'?: any;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "id",
             "baseName": "id",
             "type": "string"
         },
         {
             "name": "remoteIpAddress",
             "baseName": "remoteIpAddress",
             "type": "SystemNetIPAddress"
         },
         {
             "name": "remotePort",
             "baseName": "remotePort",
             "type": "number"
         },
         {
             "name": "localIpAddress",
             "baseName": "localIpAddress",
             "type": "SystemNetIPAddress"
         },
         {
             "name": "localPort",
             "baseName": "localPort",
             "type": "number"
         },
         {
             "name": "clientCertificate",
             "baseName": "clientCertificate",
             "type": "any"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpConnectionInfo.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpHostString {
     'value'?: string;
     'hasValue'?: boolean;
     'host'?: string;
     'port'?: number;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "value",
             "baseName": "value",
             "type": "string"
         },
         {
             "name": "hasValue",
             "baseName": "hasValue",
             "type": "boolean"
         },
         {
             "name": "host",
             "baseName": "host",
             "type": "string"
         },
         {
             "name": "port",
             "baseName": "port",
             "type": "number"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpHostString.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpHttpContext {
     'features'?: Array<SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_>;
     'request'?: MicrosoftAspNetCoreHttpHttpRequest;
     'response'?: MicrosoftAspNetCoreHttpHttpResponse;
     'connection'?: MicrosoftAspNetCoreHttpConnectionInfo;
     'webSockets'?: MicrosoftAspNetCoreHttpWebSocketManager;
     'authentication'?: MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager;
     'user'?: SystemSecurityClaimsClaimsPrincipal;
     'items'?: { [key: string]: any; };
     'requestServices'?: SystemIServiceProvider;
     'requestAborted'?: SystemThreadingCancellationToken;
     'traceIdentifier'?: string;
     'session'?: MicrosoftAspNetCoreHttpISession;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "features",
             "baseName": "features",
             "type": "Array<SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_>"
         },
         {
             "name": "request",
             "baseName": "request",
             "type": "MicrosoftAspNetCoreHttpHttpRequest"
         },
         {
             "name": "response",
             "baseName": "response",
             "type": "MicrosoftAspNetCoreHttpHttpResponse"
         },
         {
             "name": "connection",
             "baseName": "connection",
             "type": "MicrosoftAspNetCoreHttpConnectionInfo"
         },
         {
             "name": "webSockets",
             "baseName": "webSockets",
             "type": "MicrosoftAspNetCoreHttpWebSocketManager"
         },
         {
             "name": "authentication",
             "baseName": "authentication",
             "type": "MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager"
         },
         {
             "name": "user",
             "baseName": "user",
             "type": "SystemSecurityClaimsClaimsPrincipal"
         },
         {
             "name": "items",
             "baseName": "items",
             "type": "{ [key: string]: any; }"
         },
         {
             "name": "requestServices",
             "baseName": "requestServices",
             "type": "SystemIServiceProvider"
         },
         {
             "name": "requestAborted",
             "baseName": "requestAborted",
             "type": "SystemThreadingCancellationToken"
         },
         {
             "name": "traceIdentifier",
             "baseName": "traceIdentifier",
             "type": "string"
         },
         {
             "name": "session",
             "baseName": "session",
             "type": "MicrosoftAspNetCoreHttpISession"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpHttpContext.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpHttpRequest {
     'httpContext'?: MicrosoftAspNetCoreHttpHttpContext;
     'method'?: string;
     'scheme'?: string;
     'isHttps'?: boolean;
     'host'?: MicrosoftAspNetCoreHttpHostString;
     'pathBase'?: string;
     'path'?: string;
     'queryString'?: MicrosoftAspNetCoreHttpQueryString;
     'query'?: Array<SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_>;
     'protocol'?: string;
     'headers'?: { [key: string]: Array<string>; };
     'cookies'?: Array<SystemCollectionsGenericKeyValuePair2SystemStringSystemString_>;
     'contentLength'?: number;
     'contentType'?: string;
     'body'?: SystemIOStream;
     'hasFormContentType'?: boolean;
     'form'?: Array<SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "httpContext",
             "baseName": "httpContext",
             "type": "MicrosoftAspNetCoreHttpHttpContext"
         },
         {
             "name": "method",
             "baseName": "method",
             "type": "string"
         },
         {
             "name": "scheme",
             "baseName": "scheme",
             "type": "string"
         },
         {
             "name": "isHttps",
             "baseName": "isHttps",
             "type": "boolean"
         },
         {
             "name": "host",
             "baseName": "host",
             "type": "MicrosoftAspNetCoreHttpHostString"
         },
         {
             "name": "pathBase",
             "baseName": "pathBase",
             "type": "string"
         },
         {
             "name": "path",
             "baseName": "path",
             "type": "string"
         },
         {
             "name": "queryString",
             "baseName": "queryString",
             "type": "MicrosoftAspNetCoreHttpQueryString"
         },
         {
             "name": "query",
             "baseName": "query",
             "type": "Array<SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_>"
         },
         {
             "name": "protocol",
             "baseName": "protocol",
             "type": "string"
         },
         {
             "name": "headers",
             "baseName": "headers",
             "type": "{ [key: string]: Array<string>; }"
         },
         {
             "name": "cookies",
             "baseName": "cookies",
             "type": "Array<SystemCollectionsGenericKeyValuePair2SystemStringSystemString_>"
         },
         {
             "name": "contentLength",
             "baseName": "contentLength",
             "type": "number"
         },
         {
             "name": "contentType",
             "baseName": "contentType",
             "type": "string"
         },
         {
             "name": "body",
             "baseName": "body",
             "type": "SystemIOStream"
         },
         {
             "name": "hasFormContentType",
             "baseName": "hasFormContentType",
             "type": "boolean"
         },
         {
             "name": "form",
             "baseName": "form",
             "type": "Array<SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_>"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpHttpRequest.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpHttpResponse {
     'httpContext'?: MicrosoftAspNetCoreHttpHttpContext;
     'statusCode'?: number;
     'headers'?: { [key: string]: Array<string>; };
     'body'?: SystemIOStream;
     'contentLength'?: number;
     'contentType'?: string;
     'cookies'?: MicrosoftAspNetCoreHttpIResponseCookies;
     'hasStarted'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "httpContext",
             "baseName": "httpContext",
             "type": "MicrosoftAspNetCoreHttpHttpContext"
         },
         {
             "name": "statusCode",
             "baseName": "statusCode",
             "type": "number"
         },
         {
             "name": "headers",
             "baseName": "headers",
             "type": "{ [key: string]: Array<string>; }"
         },
         {
             "name": "body",
             "baseName": "body",
             "type": "SystemIOStream"
         },
         {
             "name": "contentLength",
             "baseName": "contentLength",
             "type": "number"
         },
         {
             "name": "contentType",
             "baseName": "contentType",
             "type": "string"
         },
         {
             "name": "cookies",
             "baseName": "cookies",
             "type": "MicrosoftAspNetCoreHttpIResponseCookies"
         },
         {
             "name": "hasStarted",
             "baseName": "hasStarted",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpHttpResponse.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpIResponseCookies {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpIResponseCookies.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpISession {
     'isAvailable'?: boolean;
     'id'?: string;
     'keys'?: Array<string>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "isAvailable",
             "baseName": "isAvailable",
             "type": "boolean"
         },
         {
             "name": "id",
             "baseName": "id",
             "type": "string"
         },
         {
             "name": "keys",
             "baseName": "keys",
             "type": "Array<string>"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpISession.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpQueryString {
     'value'?: string;
     'hasValue'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "value",
             "baseName": "value",
             "type": "string"
         },
         {
             "name": "hasValue",
             "baseName": "hasValue",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpQueryString.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetCoreHttpWebSocketManager {
     'isWebSocketRequest'?: boolean;
     'webSocketRequestedProtocols'?: Array<string>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "isWebSocketRequest",
             "baseName": "isWebSocketRequest",
             "type": "boolean"
         },
         {
             "name": "webSocketRequestedProtocols",
             "baseName": "webSocketRequestedProtocols",
             "type": "Array<string>"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetCoreHttpWebSocketManager.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataODataQueryContext {
     'defaultQuerySettings'?: MicrosoftAspNetODataQueryDefaultQuerySettings;
     'model'?: MicrosoftODataEdmIEdmModel;
     'elementType'?: MicrosoftODataEdmIEdmType;
     'navigationSource'?: MicrosoftODataEdmIEdmNavigationSource;
     'elementClrType'?: string;
     'path'?: MicrosoftAspNetODataRoutingODataPath;
     'requestContainer'?: SystemIServiceProvider;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "defaultQuerySettings",
             "baseName": "defaultQuerySettings",
             "type": "MicrosoftAspNetODataQueryDefaultQuerySettings"
         },
         {
             "name": "model",
             "baseName": "model",
             "type": "MicrosoftODataEdmIEdmModel"
         },
         {
             "name": "elementType",
             "baseName": "elementType",
             "type": "MicrosoftODataEdmIEdmType"
         },
         {
             "name": "navigationSource",
             "baseName": "navigationSource",
             "type": "MicrosoftODataEdmIEdmNavigationSource"
         },
         {
             "name": "elementClrType",
             "baseName": "elementClrType",
             "type": "string"
         },
         {
             "name": "path",
             "baseName": "path",
             "type": "MicrosoftAspNetODataRoutingODataPath"
         },
         {
             "name": "requestContainer",
             "baseName": "requestContainer",
             "type": "SystemIServiceProvider"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataODataQueryContext.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryApplyQueryOption {
     'context'?: MicrosoftAspNetODataODataQueryContext;
     'resultClrType'?: string;
     'applyClause'?: MicrosoftODataUriParserAggregationApplyClause;
     'rawValue'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "context",
             "baseName": "context",
             "type": "MicrosoftAspNetODataODataQueryContext"
         },
         {
             "name": "resultClrType",
             "baseName": "resultClrType",
             "type": "string"
         },
         {
             "name": "applyClause",
             "baseName": "applyClause",
             "type": "MicrosoftODataUriParserAggregationApplyClause"
         },
         {
             "name": "rawValue",
             "baseName": "rawValue",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryApplyQueryOption.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryCountQueryOption {
     'context'?: MicrosoftAspNetODataODataQueryContext;
     'rawValue'?: string;
     'value'?: boolean;
     'validator'?: MicrosoftAspNetODataQueryValidatorsCountQueryValidator;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "context",
             "baseName": "context",
             "type": "MicrosoftAspNetODataODataQueryContext"
         },
         {
             "name": "rawValue",
             "baseName": "rawValue",
             "type": "string"
         },
         {
             "name": "value",
             "baseName": "value",
             "type": "boolean"
         },
         {
             "name": "validator",
             "baseName": "validator",
             "type": "MicrosoftAspNetODataQueryValidatorsCountQueryValidator"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryCountQueryOption.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryDefaultQuerySettings {
     'enableExpand'?: boolean;
     'enableSelect'?: boolean;
     'enableCount'?: boolean;
     'enableOrderBy'?: boolean;
     'enableFilter'?: boolean;
     'maxTop'?: number;
     'enableSkipToken'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "enableExpand",
             "baseName": "enableExpand",
             "type": "boolean"
         },
         {
             "name": "enableSelect",
             "baseName": "enableSelect",
             "type": "boolean"
         },
         {
             "name": "enableCount",
             "baseName": "enableCount",
             "type": "boolean"
         },
         {
             "name": "enableOrderBy",
             "baseName": "enableOrderBy",
             "type": "boolean"
         },
         {
             "name": "enableFilter",
             "baseName": "enableFilter",
             "type": "boolean"
         },
         {
             "name": "maxTop",
             "baseName": "maxTop",
             "type": "number"
         },
         {
             "name": "enableSkipToken",
             "baseName": "enableSkipToken",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryDefaultQuerySettings.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryFilterQueryOption {
     'context'?: MicrosoftAspNetODataODataQueryContext;
     'validator'?: MicrosoftAspNetODataQueryValidatorsFilterQueryValidator;
     'filterClause'?: MicrosoftODataUriParserFilterClause;
     'rawValue'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "context",
             "baseName": "context",
             "type": "MicrosoftAspNetODataODataQueryContext"
         },
         {
             "name": "validator",
             "baseName": "validator",
             "type": "MicrosoftAspNetODataQueryValidatorsFilterQueryValidator"
         },
         {
             "name": "filterClause",
             "baseName": "filterClause",
             "type": "MicrosoftODataUriParserFilterClause"
         },
         {
             "name": "rawValue",
             "baseName": "rawValue",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryFilterQueryOption.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryODataQueryOptions {
     'request'?: MicrosoftAspNetCoreHttpHttpRequest;
     'context'?: MicrosoftAspNetODataODataQueryContext;
     'rawValues'?: MicrosoftAspNetODataQueryODataRawQueryOptions;
     'selectExpand'?: MicrosoftAspNetODataQuerySelectExpandQueryOption;
     'apply'?: MicrosoftAspNetODataQueryApplyQueryOption;
     'filter'?: MicrosoftAspNetODataQueryFilterQueryOption;
     'orderBy'?: MicrosoftAspNetODataQueryOrderByQueryOption;
     'skip'?: MicrosoftAspNetODataQuerySkipQueryOption;
     'skipToken'?: MicrosoftAspNetODataQuerySkipTokenQueryOption;
     'top'?: MicrosoftAspNetODataQueryTopQueryOption;
     'count'?: MicrosoftAspNetODataQueryCountQueryOption;
     'validator'?: MicrosoftAspNetODataQueryValidatorsODataQueryValidator;
     'ifMatch'?: any;
     'ifNoneMatch'?: any;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "request",
             "baseName": "request",
             "type": "MicrosoftAspNetCoreHttpHttpRequest"
         },
         {
             "name": "context",
             "baseName": "context",
             "type": "MicrosoftAspNetODataODataQueryContext"
         },
         {
             "name": "rawValues",
             "baseName": "rawValues",
             "type": "MicrosoftAspNetODataQueryODataRawQueryOptions"
         },
         {
             "name": "selectExpand",
             "baseName": "selectExpand",
             "type": "MicrosoftAspNetODataQuerySelectExpandQueryOption"
         },
         {
             "name": "apply",
             "baseName": "apply",
             "type": "MicrosoftAspNetODataQueryApplyQueryOption"
         },
         {
             "name": "filter",
             "baseName": "filter",
             "type": "MicrosoftAspNetODataQueryFilterQueryOption"
         },
         {
             "name": "orderBy",
             "baseName": "orderBy",
             "type": "MicrosoftAspNetODataQueryOrderByQueryOption"
         },
         {
             "name": "skip",
             "baseName": "skip",
             "type": "MicrosoftAspNetODataQuerySkipQueryOption"
         },
         {
             "name": "skipToken",
             "baseName": "skipToken",
             "type": "MicrosoftAspNetODataQuerySkipTokenQueryOption"
         },
         {
             "name": "top",
             "baseName": "top",
             "type": "MicrosoftAspNetODataQueryTopQueryOption"
         },
         {
             "name": "count",
             "baseName": "count",
             "type": "MicrosoftAspNetODataQueryCountQueryOption"
         },
         {
             "name": "validator",
             "baseName": "validator",
             "type": "MicrosoftAspNetODataQueryValidatorsODataQueryValidator"
         },
         {
             "name": "ifMatch",
             "baseName": "ifMatch",
             "type": "any"
         },
         {
             "name": "ifNoneMatch",
             "baseName": "ifNoneMatch",
             "type": "any"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryODataQueryOptions.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryODataQuerySettings {
     'ensureStableOrdering'?: boolean;
     'handleNullPropagation'?: MicrosoftAspNetODataQueryODataQuerySettings.HandleNullPropagationEnum;
     'enableConstantParameterization'?: boolean;
     'enableCorrelatedSubqueryBuffering'?: boolean;
     'pageSize'?: number;
     'handleReferenceNavigationPropertyExpandFilter'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "ensureStableOrdering",
             "baseName": "ensureStableOrdering",
             "type": "boolean"
         },
         {
             "name": "handleNullPropagation",
             "baseName": "handleNullPropagation",
             "type": "MicrosoftAspNetODataQueryODataQuerySettings.HandleNullPropagationEnum"
         },
         {
             "name": "enableConstantParameterization",
             "baseName": "enableConstantParameterization",
             "type": "boolean"
         },
         {
             "name": "enableCorrelatedSubqueryBuffering",
             "baseName": "enableCorrelatedSubqueryBuffering",
             "type": "boolean"
         },
         {
             "name": "pageSize",
             "baseName": "pageSize",
             "type": "number"
         },
         {
             "name": "handleReferenceNavigationPropertyExpandFilter",
             "baseName": "handleReferenceNavigationPropertyExpandFilter",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryODataQuerySettings.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftAspNetODataQueryODataQuerySettings {
     export enum HandleNullPropagationEnum {
         Default = <any> 'default',
         True = <any> 'true',
         False = <any> 'false'
     }
 }
 export class MicrosoftAspNetODataQueryODataRawQueryOptions {
     'filter'?: string;
     'apply'?: string;
     'orderBy'?: string;
     'top'?: string;
     'skip'?: string;
     'select'?: string;
     'expand'?: string;
     'count'?: string;
     'format'?: string;
     'skipToken'?: string;
     'deltaToken'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "filter",
             "baseName": "filter",
             "type": "string"
         },
         {
             "name": "apply",
             "baseName": "apply",
             "type": "string"
         },
         {
             "name": "orderBy",
             "baseName": "orderBy",
             "type": "string"
         },
         {
             "name": "top",
             "baseName": "top",
             "type": "string"
         },
         {
             "name": "skip",
             "baseName": "skip",
             "type": "string"
         },
         {
             "name": "select",
             "baseName": "select",
             "type": "string"
         },
         {
             "name": "expand",
             "baseName": "expand",
             "type": "string"
         },
         {
             "name": "count",
             "baseName": "count",
             "type": "string"
         },
         {
             "name": "format",
             "baseName": "format",
             "type": "string"
         },
         {
             "name": "skipToken",
             "baseName": "skipToken",
             "type": "string"
         },
         {
             "name": "deltaToken",
             "baseName": "deltaToken",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryODataRawQueryOptions.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryOrderByNode {
     'direction'?: MicrosoftAspNetODataQueryOrderByNode.DirectionEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "direction",
             "baseName": "direction",
             "type": "MicrosoftAspNetODataQueryOrderByNode.DirectionEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryOrderByNode.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftAspNetODataQueryOrderByNode {
     export enum DirectionEnum {
         Ascending = <any> 'ascending',
         Descending = <any> 'descending'
     }
 }
 export class MicrosoftAspNetODataQueryOrderByQueryOption {
     'context'?: MicrosoftAspNetODataODataQueryContext;
     'orderByNodes'?: Array<MicrosoftAspNetODataQueryOrderByNode>;
     'rawValue'?: string;
     'validator'?: MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator;
     'orderByClause'?: MicrosoftODataUriParserOrderByClause;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "context",
             "baseName": "context",
             "type": "MicrosoftAspNetODataODataQueryContext"
         },
         {
             "name": "orderByNodes",
             "baseName": "orderByNodes",
             "type": "Array<MicrosoftAspNetODataQueryOrderByNode>"
         },
         {
             "name": "rawValue",
             "baseName": "rawValue",
             "type": "string"
         },
         {
             "name": "validator",
             "baseName": "validator",
             "type": "MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator"
         },
         {
             "name": "orderByClause",
             "baseName": "orderByClause",
             "type": "MicrosoftODataUriParserOrderByClause"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryOrderByQueryOption.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQuerySelectExpandQueryOption {
     'context'?: MicrosoftAspNetODataODataQueryContext;
     'rawSelect'?: string;
     'rawExpand'?: string;
     'validator'?: MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator;
     'selectExpandClause'?: MicrosoftODataUriParserSelectExpandClause;
     'levelsMaxLiteralExpansionDepth'?: number;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "context",
             "baseName": "context",
             "type": "MicrosoftAspNetODataODataQueryContext"
         },
         {
             "name": "rawSelect",
             "baseName": "rawSelect",
             "type": "string"
         },
         {
             "name": "rawExpand",
             "baseName": "rawExpand",
             "type": "string"
         },
         {
             "name": "validator",
             "baseName": "validator",
             "type": "MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator"
         },
         {
             "name": "selectExpandClause",
             "baseName": "selectExpandClause",
             "type": "MicrosoftODataUriParserSelectExpandClause"
         },
         {
             "name": "levelsMaxLiteralExpansionDepth",
             "baseName": "levelsMaxLiteralExpansionDepth",
             "type": "number"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQuerySelectExpandQueryOption.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQuerySkipQueryOption {
     'context'?: MicrosoftAspNetODataODataQueryContext;
     'rawValue'?: string;
     'value'?: number;
     'validator'?: MicrosoftAspNetODataQueryValidatorsSkipQueryValidator;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "context",
             "baseName": "context",
             "type": "MicrosoftAspNetODataODataQueryContext"
         },
         {
             "name": "rawValue",
             "baseName": "rawValue",
             "type": "string"
         },
         {
             "name": "value",
             "baseName": "value",
             "type": "number"
         },
         {
             "name": "validator",
             "baseName": "validator",
             "type": "MicrosoftAspNetODataQueryValidatorsSkipQueryValidator"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQuerySkipQueryOption.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQuerySkipTokenQueryOption {
     'rawValue'?: string;
     'context'?: MicrosoftAspNetODataODataQueryContext;
     'validator'?: MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator;
     'querySettings'?: MicrosoftAspNetODataQueryODataQuerySettings;
     'queryOptions'?: MicrosoftAspNetODataQueryODataQueryOptions;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "rawValue",
             "baseName": "rawValue",
             "type": "string"
         },
         {
             "name": "context",
             "baseName": "context",
             "type": "MicrosoftAspNetODataODataQueryContext"
         },
         {
             "name": "validator",
             "baseName": "validator",
             "type": "MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator"
         },
         {
             "name": "querySettings",
             "baseName": "querySettings",
             "type": "MicrosoftAspNetODataQueryODataQuerySettings"
         },
         {
             "name": "queryOptions",
             "baseName": "queryOptions",
             "type": "MicrosoftAspNetODataQueryODataQueryOptions"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQuerySkipTokenQueryOption.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryTopQueryOption {
     'context'?: MicrosoftAspNetODataODataQueryContext;
     'rawValue'?: string;
     'value'?: number;
     'validator'?: MicrosoftAspNetODataQueryValidatorsTopQueryValidator;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "context",
             "baseName": "context",
             "type": "MicrosoftAspNetODataODataQueryContext"
         },
         {
             "name": "rawValue",
             "baseName": "rawValue",
             "type": "string"
         },
         {
             "name": "value",
             "baseName": "value",
             "type": "number"
         },
         {
             "name": "validator",
             "baseName": "validator",
             "type": "MicrosoftAspNetODataQueryValidatorsTopQueryValidator"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryTopQueryOption.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryValidatorsCountQueryValidator {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryValidatorsCountQueryValidator.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryValidatorsFilterQueryValidator {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryValidatorsFilterQueryValidator.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryValidatorsODataQueryValidator {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryValidatorsODataQueryValidator.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryValidatorsSkipQueryValidator {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryValidatorsSkipQueryValidator.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataQueryValidatorsTopQueryValidator {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataQueryValidatorsTopQueryValidator.attributeTypeMap;
     }
 }
 
 export class MicrosoftAspNetODataRoutingODataPath {
     'edmType'?: MicrosoftODataEdmIEdmType;
     'navigationSource'?: MicrosoftODataEdmIEdmNavigationSource;
     'segments'?: Array<MicrosoftODataUriParserODataPathSegment>;
     'pathTemplate'?: string;
     'path'?: Array<MicrosoftODataUriParserODataPathSegment>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "edmType",
             "baseName": "edmType",
             "type": "MicrosoftODataEdmIEdmType"
         },
         {
             "name": "navigationSource",
             "baseName": "navigationSource",
             "type": "MicrosoftODataEdmIEdmNavigationSource"
         },
         {
             "name": "segments",
             "baseName": "segments",
             "type": "Array<MicrosoftODataUriParserODataPathSegment>"
         },
         {
             "name": "pathTemplate",
             "baseName": "pathTemplate",
             "type": "string"
         },
         {
             "name": "path",
             "baseName": "path",
             "type": "Array<MicrosoftODataUriParserODataPathSegment>"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftAspNetODataRoutingODataPath.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataEdmEdmReferentialConstraintPropertyPair {
     'dependentProperty'?: MicrosoftODataEdmIEdmStructuralProperty;
     'principalProperty'?: MicrosoftODataEdmIEdmStructuralProperty;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "dependentProperty",
             "baseName": "dependentProperty",
             "type": "MicrosoftODataEdmIEdmStructuralProperty"
         },
         {
             "name": "principalProperty",
             "baseName": "principalProperty",
             "type": "MicrosoftODataEdmIEdmStructuralProperty"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmEdmReferentialConstraintPropertyPair.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataEdmIEdmEntityContainer {
     'elements'?: Array<MicrosoftODataEdmIEdmEntityContainerElement>;
     'schemaElementKind'?: MicrosoftODataEdmIEdmEntityContainer.SchemaElementKindEnum;
     'namespace'?: string;
     'name'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "elements",
             "baseName": "elements",
             "type": "Array<MicrosoftODataEdmIEdmEntityContainerElement>"
         },
         {
             "name": "schemaElementKind",
             "baseName": "schemaElementKind",
             "type": "MicrosoftODataEdmIEdmEntityContainer.SchemaElementKindEnum"
         },
         {
             "name": "namespace",
             "baseName": "namespace",
             "type": "string"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmEntityContainer.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmEntityContainer {
     export enum SchemaElementKindEnum {
         None = <any> 'none',
         TypeDefinition = <any> 'typeDefinition',
         Term = <any> 'term',
         Action = <any> 'action',
         EntityContainer = <any> 'entityContainer',
         Function = <any> 'function'
     }
 }
 export class MicrosoftODataEdmIEdmEntityContainerElement {
     'containerElementKind'?: MicrosoftODataEdmIEdmEntityContainerElement.ContainerElementKindEnum;
     'container'?: MicrosoftODataEdmIEdmEntityContainer;
     'name'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "containerElementKind",
             "baseName": "containerElementKind",
             "type": "MicrosoftODataEdmIEdmEntityContainerElement.ContainerElementKindEnum"
         },
         {
             "name": "container",
             "baseName": "container",
             "type": "MicrosoftODataEdmIEdmEntityContainer"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmEntityContainerElement.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmEntityContainerElement {
     export enum ContainerElementKindEnum {
         None = <any> 'none',
         EntitySet = <any> 'entitySet',
         ActionImport = <any> 'actionImport',
         FunctionImport = <any> 'functionImport',
         Singleton = <any> 'singleton'
     }
 }
 export class MicrosoftODataEdmIEdmExpression {
     'expressionKind'?: MicrosoftODataEdmIEdmExpression.ExpressionKindEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "expressionKind",
             "baseName": "expressionKind",
             "type": "MicrosoftODataEdmIEdmExpression.ExpressionKindEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmExpression.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmExpression {
     export enum ExpressionKindEnum {
         None = <any> 'none',
         BinaryConstant = <any> 'binaryConstant',
         BooleanConstant = <any> 'booleanConstant',
         DateTimeOffsetConstant = <any> 'dateTimeOffsetConstant',
         DecimalConstant = <any> 'decimalConstant',
         FloatingConstant = <any> 'floatingConstant',
         GuidConstant = <any> 'guidConstant',
         IntegerConstant = <any> 'integerConstant',
         StringConstant = <any> 'stringConstant',
         DurationConstant = <any> 'durationConstant',
         Null = <any> 'null',
         Record = <any> 'record',
         Collection = <any> 'collection',
         Path = <any> 'path',
         If = <any> 'if',
         Cast = <any> 'cast',
         IsType = <any> 'isType',
         FunctionApplication = <any> 'functionApplication',
         LabeledExpressionReference = <any> 'labeledExpressionReference',
         Labeled = <any> 'labeled',
         PropertyPath = <any> 'propertyPath',
         NavigationPropertyPath = <any> 'navigationPropertyPath',
         DateConstant = <any> 'dateConstant',
         TimeOfDayConstant = <any> 'timeOfDayConstant',
         EnumMember = <any> 'enumMember',
         AnnotationPath = <any> 'annotationPath'
     }
 }
 export class MicrosoftODataEdmIEdmModel {
     'schemaElements'?: Array<MicrosoftODataEdmIEdmSchemaElement>;
     'vocabularyAnnotations'?: Array<MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation>;
     'referencedModels'?: Array<MicrosoftODataEdmIEdmModel>;
     'declaredNamespaces'?: Array<string>;
     'directValueAnnotationsManager'?: MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager;
     'entityContainer'?: MicrosoftODataEdmIEdmEntityContainer;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "schemaElements",
             "baseName": "schemaElements",
             "type": "Array<MicrosoftODataEdmIEdmSchemaElement>"
         },
         {
             "name": "vocabularyAnnotations",
             "baseName": "vocabularyAnnotations",
             "type": "Array<MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation>"
         },
         {
             "name": "referencedModels",
             "baseName": "referencedModels",
             "type": "Array<MicrosoftODataEdmIEdmModel>"
         },
         {
             "name": "declaredNamespaces",
             "baseName": "declaredNamespaces",
             "type": "Array<string>"
         },
         {
             "name": "directValueAnnotationsManager",
             "baseName": "directValueAnnotationsManager",
             "type": "MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager"
         },
         {
             "name": "entityContainer",
             "baseName": "entityContainer",
             "type": "MicrosoftODataEdmIEdmEntityContainer"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmModel.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataEdmIEdmNavigationProperty {
     'partner'?: MicrosoftODataEdmIEdmNavigationProperty;
     'onDelete'?: MicrosoftODataEdmIEdmNavigationProperty.OnDeleteEnum;
     'containsTarget'?: boolean;
     'referentialConstraint'?: MicrosoftODataEdmIEdmReferentialConstraint;
     'propertyKind'?: MicrosoftODataEdmIEdmNavigationProperty.PropertyKindEnum;
     'type'?: MicrosoftODataEdmIEdmTypeReference;
     'declaringType'?: MicrosoftODataEdmIEdmStructuredType;
     'name'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "partner",
             "baseName": "partner",
             "type": "MicrosoftODataEdmIEdmNavigationProperty"
         },
         {
             "name": "onDelete",
             "baseName": "onDelete",
             "type": "MicrosoftODataEdmIEdmNavigationProperty.OnDeleteEnum"
         },
         {
             "name": "containsTarget",
             "baseName": "containsTarget",
             "type": "boolean"
         },
         {
             "name": "referentialConstraint",
             "baseName": "referentialConstraint",
             "type": "MicrosoftODataEdmIEdmReferentialConstraint"
         },
         {
             "name": "propertyKind",
             "baseName": "propertyKind",
             "type": "MicrosoftODataEdmIEdmNavigationProperty.PropertyKindEnum"
         },
         {
             "name": "type",
             "baseName": "type",
             "type": "MicrosoftODataEdmIEdmTypeReference"
         },
         {
             "name": "declaringType",
             "baseName": "declaringType",
             "type": "MicrosoftODataEdmIEdmStructuredType"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmNavigationProperty.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmNavigationProperty {
     export enum OnDeleteEnum {
         None = <any> 'none',
         Cascade = <any> 'cascade'
     }
     export enum PropertyKindEnum {
         None = <any> 'none',
         Structural = <any> 'structural',
         Navigation = <any> 'navigation'
     }
 }
 export class MicrosoftODataEdmIEdmNavigationPropertyBinding {
     'navigationProperty'?: MicrosoftODataEdmIEdmNavigationProperty;
     'target'?: MicrosoftODataEdmIEdmNavigationSource;
     'path'?: MicrosoftODataEdmIEdmPathExpression;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "navigationProperty",
             "baseName": "navigationProperty",
             "type": "MicrosoftODataEdmIEdmNavigationProperty"
         },
         {
             "name": "target",
             "baseName": "target",
             "type": "MicrosoftODataEdmIEdmNavigationSource"
         },
         {
             "name": "path",
             "baseName": "path",
             "type": "MicrosoftODataEdmIEdmPathExpression"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmNavigationPropertyBinding.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataEdmIEdmNavigationSource {
     'navigationPropertyBindings'?: Array<MicrosoftODataEdmIEdmNavigationPropertyBinding>;
     'path'?: MicrosoftODataEdmIEdmPathExpression;
     'type'?: MicrosoftODataEdmIEdmType;
     'name'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "navigationPropertyBindings",
             "baseName": "navigationPropertyBindings",
             "type": "Array<MicrosoftODataEdmIEdmNavigationPropertyBinding>"
         },
         {
             "name": "path",
             "baseName": "path",
             "type": "MicrosoftODataEdmIEdmPathExpression"
         },
         {
             "name": "type",
             "baseName": "type",
             "type": "MicrosoftODataEdmIEdmType"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmNavigationSource.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataEdmIEdmPathExpression {
     'pathSegments'?: Array<string>;
     'path'?: string;
     'expressionKind'?: MicrosoftODataEdmIEdmPathExpression.ExpressionKindEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "pathSegments",
             "baseName": "pathSegments",
             "type": "Array<string>"
         },
         {
             "name": "path",
             "baseName": "path",
             "type": "string"
         },
         {
             "name": "expressionKind",
             "baseName": "expressionKind",
             "type": "MicrosoftODataEdmIEdmPathExpression.ExpressionKindEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmPathExpression.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmPathExpression {
     export enum ExpressionKindEnum {
         None = <any> 'none',
         BinaryConstant = <any> 'binaryConstant',
         BooleanConstant = <any> 'booleanConstant',
         DateTimeOffsetConstant = <any> 'dateTimeOffsetConstant',
         DecimalConstant = <any> 'decimalConstant',
         FloatingConstant = <any> 'floatingConstant',
         GuidConstant = <any> 'guidConstant',
         IntegerConstant = <any> 'integerConstant',
         StringConstant = <any> 'stringConstant',
         DurationConstant = <any> 'durationConstant',
         Null = <any> 'null',
         Record = <any> 'record',
         Collection = <any> 'collection',
         Path = <any> 'path',
         If = <any> 'if',
         Cast = <any> 'cast',
         IsType = <any> 'isType',
         FunctionApplication = <any> 'functionApplication',
         LabeledExpressionReference = <any> 'labeledExpressionReference',
         Labeled = <any> 'labeled',
         PropertyPath = <any> 'propertyPath',
         NavigationPropertyPath = <any> 'navigationPropertyPath',
         DateConstant = <any> 'dateConstant',
         TimeOfDayConstant = <any> 'timeOfDayConstant',
         EnumMember = <any> 'enumMember',
         AnnotationPath = <any> 'annotationPath'
     }
 }
 export class MicrosoftODataEdmIEdmProperty {
     'propertyKind'?: MicrosoftODataEdmIEdmProperty.PropertyKindEnum;
     'type'?: MicrosoftODataEdmIEdmTypeReference;
     'declaringType'?: MicrosoftODataEdmIEdmStructuredType;
     'name'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "propertyKind",
             "baseName": "propertyKind",
             "type": "MicrosoftODataEdmIEdmProperty.PropertyKindEnum"
         },
         {
             "name": "type",
             "baseName": "type",
             "type": "MicrosoftODataEdmIEdmTypeReference"
         },
         {
             "name": "declaringType",
             "baseName": "declaringType",
             "type": "MicrosoftODataEdmIEdmStructuredType"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmProperty.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmProperty {
     export enum PropertyKindEnum {
         None = <any> 'none',
         Structural = <any> 'structural',
         Navigation = <any> 'navigation'
     }
 }
 export class MicrosoftODataEdmIEdmReferentialConstraint {
     'propertyPairs'?: Array<MicrosoftODataEdmEdmReferentialConstraintPropertyPair>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "propertyPairs",
             "baseName": "propertyPairs",
             "type": "Array<MicrosoftODataEdmEdmReferentialConstraintPropertyPair>"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmReferentialConstraint.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataEdmIEdmSchemaElement {
     'schemaElementKind'?: MicrosoftODataEdmIEdmSchemaElement.SchemaElementKindEnum;
     'namespace'?: string;
     'name'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "schemaElementKind",
             "baseName": "schemaElementKind",
             "type": "MicrosoftODataEdmIEdmSchemaElement.SchemaElementKindEnum"
         },
         {
             "name": "namespace",
             "baseName": "namespace",
             "type": "string"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmSchemaElement.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmSchemaElement {
     export enum SchemaElementKindEnum {
         None = <any> 'none',
         TypeDefinition = <any> 'typeDefinition',
         Term = <any> 'term',
         Action = <any> 'action',
         EntityContainer = <any> 'entityContainer',
         Function = <any> 'function'
     }
 }
 export class MicrosoftODataEdmIEdmStructuralProperty {
     'defaultValueString'?: string;
     'propertyKind'?: MicrosoftODataEdmIEdmStructuralProperty.PropertyKindEnum;
     'type'?: MicrosoftODataEdmIEdmTypeReference;
     'declaringType'?: MicrosoftODataEdmIEdmStructuredType;
     'name'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "defaultValueString",
             "baseName": "defaultValueString",
             "type": "string"
         },
         {
             "name": "propertyKind",
             "baseName": "propertyKind",
             "type": "MicrosoftODataEdmIEdmStructuralProperty.PropertyKindEnum"
         },
         {
             "name": "type",
             "baseName": "type",
             "type": "MicrosoftODataEdmIEdmTypeReference"
         },
         {
             "name": "declaringType",
             "baseName": "declaringType",
             "type": "MicrosoftODataEdmIEdmStructuredType"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmStructuralProperty.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmStructuralProperty {
     export enum PropertyKindEnum {
         None = <any> 'none',
         Structural = <any> 'structural',
         Navigation = <any> 'navigation'
     }
 }
 export class MicrosoftODataEdmIEdmStructuredType {
     'isAbstract'?: boolean;
     'isOpen'?: boolean;
     'baseType'?: MicrosoftODataEdmIEdmStructuredType;
     'declaredProperties'?: Array<MicrosoftODataEdmIEdmProperty>;
     'typeKind'?: MicrosoftODataEdmIEdmStructuredType.TypeKindEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "isAbstract",
             "baseName": "isAbstract",
             "type": "boolean"
         },
         {
             "name": "isOpen",
             "baseName": "isOpen",
             "type": "boolean"
         },
         {
             "name": "baseType",
             "baseName": "baseType",
             "type": "MicrosoftODataEdmIEdmStructuredType"
         },
         {
             "name": "declaredProperties",
             "baseName": "declaredProperties",
             "type": "Array<MicrosoftODataEdmIEdmProperty>"
         },
         {
             "name": "typeKind",
             "baseName": "typeKind",
             "type": "MicrosoftODataEdmIEdmStructuredType.TypeKindEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmStructuredType.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmStructuredType {
     export enum TypeKindEnum {
         None = <any> 'none',
         Primitive = <any> 'primitive',
         Entity = <any> 'entity',
         Complex = <any> 'complex',
         Collection = <any> 'collection',
         EntityReference = <any> 'entityReference',
         Enum = <any> 'enum',
         TypeDefinition = <any> 'typeDefinition',
         Untyped = <any> 'untyped',
         Path = <any> 'path'
     }
 }
 export class MicrosoftODataEdmIEdmType {
     'typeKind'?: MicrosoftODataEdmIEdmType.TypeKindEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "typeKind",
             "baseName": "typeKind",
             "type": "MicrosoftODataEdmIEdmType.TypeKindEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmType.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmIEdmType {
     export enum TypeKindEnum {
         None = <any> 'none',
         Primitive = <any> 'primitive',
         Entity = <any> 'entity',
         Complex = <any> 'complex',
         Collection = <any> 'collection',
         EntityReference = <any> 'entityReference',
         Enum = <any> 'enum',
         TypeDefinition = <any> 'typeDefinition',
         Untyped = <any> 'untyped',
         Path = <any> 'path'
     }
 }
 export class MicrosoftODataEdmIEdmTypeReference {
     'isNullable'?: boolean;
     'definition'?: MicrosoftODataEdmIEdmType;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "isNullable",
             "baseName": "isNullable",
             "type": "boolean"
         },
         {
             "name": "definition",
             "baseName": "definition",
             "type": "MicrosoftODataEdmIEdmType"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmIEdmTypeReference.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataEdmVocabulariesIEdmTerm {
     'type'?: MicrosoftODataEdmIEdmTypeReference;
     'appliesTo'?: string;
     'defaultValue'?: string;
     'schemaElementKind'?: MicrosoftODataEdmVocabulariesIEdmTerm.SchemaElementKindEnum;
     'namespace'?: string;
     'name'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "type",
             "baseName": "type",
             "type": "MicrosoftODataEdmIEdmTypeReference"
         },
         {
             "name": "appliesTo",
             "baseName": "appliesTo",
             "type": "string"
         },
         {
             "name": "defaultValue",
             "baseName": "defaultValue",
             "type": "string"
         },
         {
             "name": "schemaElementKind",
             "baseName": "schemaElementKind",
             "type": "MicrosoftODataEdmVocabulariesIEdmTerm.SchemaElementKindEnum"
         },
         {
             "name": "namespace",
             "baseName": "namespace",
             "type": "string"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmVocabulariesIEdmTerm.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataEdmVocabulariesIEdmTerm {
     export enum SchemaElementKindEnum {
         None = <any> 'none',
         TypeDefinition = <any> 'typeDefinition',
         Term = <any> 'term',
         Action = <any> 'action',
         EntityContainer = <any> 'entityContainer',
         Function = <any> 'function'
     }
 }
 export class MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation {
     'qualifier'?: string;
     'term'?: MicrosoftODataEdmVocabulariesIEdmTerm;
     'target'?: MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable;
     'value'?: MicrosoftODataEdmIEdmExpression;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "qualifier",
             "baseName": "qualifier",
             "type": "string"
         },
         {
             "name": "term",
             "baseName": "term",
             "type": "MicrosoftODataEdmVocabulariesIEdmTerm"
         },
         {
             "name": "target",
             "baseName": "target",
             "type": "MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable"
         },
         {
             "name": "value",
             "baseName": "value",
             "type": "MicrosoftODataEdmIEdmExpression"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataUriParserAggregationApplyClause {
     'transformations'?: Array<MicrosoftODataUriParserAggregationTransformationNode>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "transformations",
             "baseName": "transformations",
             "type": "Array<MicrosoftODataUriParserAggregationTransformationNode>"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataUriParserAggregationApplyClause.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataUriParserAggregationTransformationNode {
     'kind'?: MicrosoftODataUriParserAggregationTransformationNode.KindEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "kind",
             "baseName": "kind",
             "type": "MicrosoftODataUriParserAggregationTransformationNode.KindEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataUriParserAggregationTransformationNode.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataUriParserAggregationTransformationNode {
     export enum KindEnum {
         Aggregate = <any> 'aggregate',
         GroupBy = <any> 'groupBy',
         Filter = <any> 'filter',
         Compute = <any> 'compute',
         Expand = <any> 'expand'
     }
 }
 export class MicrosoftODataUriParserFilterClause {
     'expression'?: MicrosoftODataUriParserSingleValueNode;
     'rangeVariable'?: MicrosoftODataUriParserRangeVariable;
     'itemType'?: MicrosoftODataEdmIEdmTypeReference;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "expression",
             "baseName": "expression",
             "type": "MicrosoftODataUriParserSingleValueNode"
         },
         {
             "name": "rangeVariable",
             "baseName": "rangeVariable",
             "type": "MicrosoftODataUriParserRangeVariable"
         },
         {
             "name": "itemType",
             "baseName": "itemType",
             "type": "MicrosoftODataEdmIEdmTypeReference"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataUriParserFilterClause.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataUriParserODataPathSegment {
     'edmType'?: MicrosoftODataEdmIEdmType;
     'identifier'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "edmType",
             "baseName": "edmType",
             "type": "MicrosoftODataEdmIEdmType"
         },
         {
             "name": "identifier",
             "baseName": "identifier",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataUriParserODataPathSegment.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataUriParserOrderByClause {
     'thenBy'?: MicrosoftODataUriParserOrderByClause;
     'expression'?: MicrosoftODataUriParserSingleValueNode;
     'direction'?: MicrosoftODataUriParserOrderByClause.DirectionEnum;
     'rangeVariable'?: MicrosoftODataUriParserRangeVariable;
     'itemType'?: MicrosoftODataEdmIEdmTypeReference;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "thenBy",
             "baseName": "thenBy",
             "type": "MicrosoftODataUriParserOrderByClause"
         },
         {
             "name": "expression",
             "baseName": "expression",
             "type": "MicrosoftODataUriParserSingleValueNode"
         },
         {
             "name": "direction",
             "baseName": "direction",
             "type": "MicrosoftODataUriParserOrderByClause.DirectionEnum"
         },
         {
             "name": "rangeVariable",
             "baseName": "rangeVariable",
             "type": "MicrosoftODataUriParserRangeVariable"
         },
         {
             "name": "itemType",
             "baseName": "itemType",
             "type": "MicrosoftODataEdmIEdmTypeReference"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataUriParserOrderByClause.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataUriParserOrderByClause {
     export enum DirectionEnum {
         Ascending = <any> 'ascending',
         Descending = <any> 'descending'
     }
 }
 export class MicrosoftODataUriParserRangeVariable {
     'name'?: string;
     'typeReference'?: MicrosoftODataEdmIEdmTypeReference;
     'kind'?: number;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "typeReference",
             "baseName": "typeReference",
             "type": "MicrosoftODataEdmIEdmTypeReference"
         },
         {
             "name": "kind",
             "baseName": "kind",
             "type": "number"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataUriParserRangeVariable.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataUriParserSelectExpandClause {
     'selectedItems'?: Array<MicrosoftODataUriParserSelectItem>;
     'allSelected'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "selectedItems",
             "baseName": "selectedItems",
             "type": "Array<MicrosoftODataUriParserSelectItem>"
         },
         {
             "name": "allSelected",
             "baseName": "allSelected",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataUriParserSelectExpandClause.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataUriParserSelectItem {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataUriParserSelectItem.attributeTypeMap;
     }
 }
 
 export class MicrosoftODataUriParserSingleValueNode {
     'typeReference'?: MicrosoftODataEdmIEdmTypeReference;
     'kind'?: MicrosoftODataUriParserSingleValueNode.KindEnum;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "typeReference",
             "baseName": "typeReference",
             "type": "MicrosoftODataEdmIEdmTypeReference"
         },
         {
             "name": "kind",
             "baseName": "kind",
             "type": "MicrosoftODataUriParserSingleValueNode.KindEnum"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftODataUriParserSingleValueNode.attributeTypeMap;
     }
 }
 
 export namespace MicrosoftODataUriParserSingleValueNode {
     export enum KindEnum {
         None = <any> 'none',
         Constant = <any> 'constant',
         Convert = <any> 'convert',
         NonResourceRangeVariableReference = <any> 'nonResourceRangeVariableReference',
         BinaryOperator = <any> 'binaryOperator',
         UnaryOperator = <any> 'unaryOperator',
         SingleValuePropertyAccess = <any> 'singleValuePropertyAccess',
         CollectionPropertyAccess = <any> 'collectionPropertyAccess',
         SingleValueFunctionCall = <any> 'singleValueFunctionCall',
         Any = <any> 'any',
         CollectionNavigationNode = <any> 'collectionNavigationNode',
         SingleNavigationNode = <any> 'singleNavigationNode',
         SingleValueOpenPropertyAccess = <any> 'singleValueOpenPropertyAccess',
         SingleResourceCast = <any> 'singleResourceCast',
         All = <any> 'all',
         CollectionResourceCast = <any> 'collectionResourceCast',
         ResourceRangeVariableReference = <any> 'resourceRangeVariableReference',
         SingleResourceFunctionCall = <any> 'singleResourceFunctionCall',
         CollectionFunctionCall = <any> 'collectionFunctionCall',
         CollectionResourceFunctionCall = <any> 'collectionResourceFunctionCall',
         NamedFunctionParameter = <any> 'namedFunctionParameter',
         ParameterAlias = <any> 'parameterAlias',
         EntitySet = <any> 'entitySet',
         KeyLookup = <any> 'keyLookup',
         SearchTerm = <any> 'searchTerm',
         CollectionOpenPropertyAccess = <any> 'collectionOpenPropertyAccess',
         CollectionComplexNode = <any> 'collectionComplexNode',
         SingleComplexNode = <any> 'singleComplexNode',
         Count = <any> 'count',
         SingleValueCast = <any> 'singleValueCast',
         CollectionPropertyNode = <any> 'collectionPropertyNode',
         AggregatedCollectionPropertyNode = <any> 'aggregatedCollectionPropertyNode',
         In = <any> 'in',
         CollectionConstant = <any> 'collectionConstant'
     }
 }
 export class MicrosoftWin32SafeHandlesSafeWaitHandle {
     'isInvalid'?: boolean;
     'isClosed'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "isInvalid",
             "baseName": "isInvalid",
             "type": "boolean"
         },
         {
             "name": "isClosed",
             "baseName": "isClosed",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return MicrosoftWin32SafeHandlesSafeWaitHandle.attributeTypeMap;
     }
 }
 
 export class SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_ {
     'key'?: string;
     'value'?: Array<string>;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "key",
             "baseName": "key",
             "type": "string"
         },
         {
             "name": "value",
             "baseName": "value",
             "type": "Array<string>"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_.attributeTypeMap;
     }
 }
 
 export class SystemCollectionsGenericKeyValuePair2SystemStringSystemString_ {
     'key'?: string;
     'value'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "key",
             "baseName": "key",
             "type": "string"
         },
         {
             "name": "value",
             "baseName": "value",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemCollectionsGenericKeyValuePair2SystemStringSystemString_.attributeTypeMap;
     }
 }
 
 export class SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_ {
     'key'?: string;
     'value'?: any;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "key",
             "baseName": "key",
             "type": "string"
         },
         {
             "name": "value",
             "baseName": "value",
             "type": "any"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_.attributeTypeMap;
     }
 }
 
 export class SystemIOStream {
     'canRead'?: boolean;
     'canSeek'?: boolean;
     'canTimeout'?: boolean;
     'canWrite'?: boolean;
     'length'?: number;
     'position'?: number;
     'readTimeout'?: number;
     'writeTimeout'?: number;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "canRead",
             "baseName": "canRead",
             "type": "boolean"
         },
         {
             "name": "canSeek",
             "baseName": "canSeek",
             "type": "boolean"
         },
         {
             "name": "canTimeout",
             "baseName": "canTimeout",
             "type": "boolean"
         },
         {
             "name": "canWrite",
             "baseName": "canWrite",
             "type": "boolean"
         },
         {
             "name": "length",
             "baseName": "length",
             "type": "number"
         },
         {
             "name": "position",
             "baseName": "position",
             "type": "number"
         },
         {
             "name": "readTimeout",
             "baseName": "readTimeout",
             "type": "number"
         },
         {
             "name": "writeTimeout",
             "baseName": "writeTimeout",
             "type": "number"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemIOStream.attributeTypeMap;
     }
 }
 
 export class SystemIServiceProvider {
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
     ];
 
     static getAttributeTypeMap() {
         return SystemIServiceProvider.attributeTypeMap;
     }
 }
 
 export class SystemNetIPAddress {
     'address'?: number;
     'addressFamily'?: SystemNetIPAddress.AddressFamilyEnum;
     'scopeId'?: number;
     'isIPv6Multicast'?: boolean;
     'isIPv6LinkLocal'?: boolean;
     'isIPv6SiteLocal'?: boolean;
     'isIPv6Teredo'?: boolean;
     'isIPv4MappedToIPv6'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "address",
             "baseName": "address",
             "type": "number"
         },
         {
             "name": "addressFamily",
             "baseName": "addressFamily",
             "type": "SystemNetIPAddress.AddressFamilyEnum"
         },
         {
             "name": "scopeId",
             "baseName": "scopeId",
             "type": "number"
         },
         {
             "name": "isIPv6Multicast",
             "baseName": "isIPv6Multicast",
             "type": "boolean"
         },
         {
             "name": "isIPv6LinkLocal",
             "baseName": "isIPv6LinkLocal",
             "type": "boolean"
         },
         {
             "name": "isIPv6SiteLocal",
             "baseName": "isIPv6SiteLocal",
             "type": "boolean"
         },
         {
             "name": "isIPv6Teredo",
             "baseName": "isIPv6Teredo",
             "type": "boolean"
         },
         {
             "name": "isIPv4MappedToIPv6",
             "baseName": "isIPv4MappedToIPv6",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemNetIPAddress.attributeTypeMap;
     }
 }
 
 export namespace SystemNetIPAddress {
     export enum AddressFamilyEnum {
         Unknown = <any> 'unknown',
         Unspecified = <any> 'unspecified',
         Unix = <any> 'unix',
         InterNetwork = <any> 'interNetwork',
         ImpLink = <any> 'impLink',
         Pup = <any> 'pup',
         Chaos = <any> 'chaos',
         NS = <any> 'nS',
         Ipx = <any> 'ipx',
         Iso = <any> 'iso',
         Osi = <any> 'osi',
         Ecma = <any> 'ecma',
         DataKit = <any> 'dataKit',
         Ccitt = <any> 'ccitt',
         Sna = <any> 'sna',
         DecNet = <any> 'decNet',
         DataLink = <any> 'dataLink',
         Lat = <any> 'lat',
         HyperChannel = <any> 'hyperChannel',
         AppleTalk = <any> 'appleTalk',
         NetBios = <any> 'netBios',
         VoiceView = <any> 'voiceView',
         FireFox = <any> 'fireFox',
         Banyan = <any> 'banyan',
         Atm = <any> 'atm',
         InterNetworkV6 = <any> 'interNetworkV6',
         Cluster = <any> 'cluster',
         Ieee12844 = <any> 'ieee12844',
         Irda = <any> 'irda',
         NetworkDesigners = <any> 'networkDesigners',
         Max = <any> 'max'
     }
 }
 export class SystemSecurityClaimsClaim {
     'issuer'?: string;
     'originalIssuer'?: string;
     'properties'?: { [key: string]: string; };
     'subject'?: SystemSecurityClaimsClaimsIdentity;
     'type'?: string;
     'value'?: string;
     'valueType'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "issuer",
             "baseName": "issuer",
             "type": "string"
         },
         {
             "name": "originalIssuer",
             "baseName": "originalIssuer",
             "type": "string"
         },
         {
             "name": "properties",
             "baseName": "properties",
             "type": "{ [key: string]: string; }"
         },
         {
             "name": "subject",
             "baseName": "subject",
             "type": "SystemSecurityClaimsClaimsIdentity"
         },
         {
             "name": "type",
             "baseName": "type",
             "type": "string"
         },
         {
             "name": "value",
             "baseName": "value",
             "type": "string"
         },
         {
             "name": "valueType",
             "baseName": "valueType",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemSecurityClaimsClaim.attributeTypeMap;
     }
 }
 
 export class SystemSecurityClaimsClaimsIdentity {
     'authenticationType'?: string;
     'isAuthenticated'?: boolean;
     'actor'?: SystemSecurityClaimsClaimsIdentity;
     'bootstrapContext'?: any;
     'claims'?: Array<SystemSecurityClaimsClaim>;
     'label'?: string;
     'name'?: string;
     'nameClaimType'?: string;
     'roleClaimType'?: string;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "authenticationType",
             "baseName": "authenticationType",
             "type": "string"
         },
         {
             "name": "isAuthenticated",
             "baseName": "isAuthenticated",
             "type": "boolean"
         },
         {
             "name": "actor",
             "baseName": "actor",
             "type": "SystemSecurityClaimsClaimsIdentity"
         },
         {
             "name": "bootstrapContext",
             "baseName": "bootstrapContext",
             "type": "any"
         },
         {
             "name": "claims",
             "baseName": "claims",
             "type": "Array<SystemSecurityClaimsClaim>"
         },
         {
             "name": "label",
             "baseName": "label",
             "type": "string"
         },
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "nameClaimType",
             "baseName": "nameClaimType",
             "type": "string"
         },
         {
             "name": "roleClaimType",
             "baseName": "roleClaimType",
             "type": "string"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemSecurityClaimsClaimsIdentity.attributeTypeMap;
     }
 }
 
 export class SystemSecurityClaimsClaimsPrincipal {
     'claims'?: Array<SystemSecurityClaimsClaim>;
     'identities'?: Array<SystemSecurityClaimsClaimsIdentity>;
     'identity'?: SystemSecurityPrincipalIIdentity;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "claims",
             "baseName": "claims",
             "type": "Array<SystemSecurityClaimsClaim>"
         },
         {
             "name": "identities",
             "baseName": "identities",
             "type": "Array<SystemSecurityClaimsClaimsIdentity>"
         },
         {
             "name": "identity",
             "baseName": "identity",
             "type": "SystemSecurityPrincipalIIdentity"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemSecurityClaimsClaimsPrincipal.attributeTypeMap;
     }
 }
 
 export class SystemSecurityPrincipalIIdentity {
     'name'?: string;
     'authenticationType'?: string;
     'isAuthenticated'?: boolean;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "name",
             "baseName": "name",
             "type": "string"
         },
         {
             "name": "authenticationType",
             "baseName": "authenticationType",
             "type": "string"
         },
         {
             "name": "isAuthenticated",
             "baseName": "isAuthenticated",
             "type": "boolean"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemSecurityPrincipalIIdentity.attributeTypeMap;
     }
 }
 
 export class SystemThreadingCancellationToken {
     'isCancellationRequested'?: boolean;
     'canBeCanceled'?: boolean;
     'waitHandle'?: SystemThreadingWaitHandle;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "isCancellationRequested",
             "baseName": "isCancellationRequested",
             "type": "boolean"
         },
         {
             "name": "canBeCanceled",
             "baseName": "canBeCanceled",
             "type": "boolean"
         },
         {
             "name": "waitHandle",
             "baseName": "waitHandle",
             "type": "SystemThreadingWaitHandle"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemThreadingCancellationToken.attributeTypeMap;
     }
 }
 
 export class SystemThreadingWaitHandle {
     'handle'?: any;
     'safeWaitHandle'?: MicrosoftWin32SafeHandlesSafeWaitHandle;
 
     static discriminator: string | undefined = undefined;
 
     static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
         {
             "name": "handle",
             "baseName": "handle",
             "type": "any"
         },
         {
             "name": "safeWaitHandle",
             "baseName": "safeWaitHandle",
             "type": "MicrosoftWin32SafeHandlesSafeWaitHandle"
         }    ];
 
     static getAttributeTypeMap() {
         return SystemThreadingWaitHandle.attributeTypeMap;
     }
 }
 
 
 let enumsMap: {[index: string]: any} = {
         "MSEssGatewayClientContractsCipherDetailsMessage.StatusEnum": MSEssGatewayClientContractsCipherDetailsMessage.StatusEnum,
         "MSEssGatewayClientContractsCipherInfo.CipherTypeEnum": MSEssGatewayClientContractsCipherInfo.CipherTypeEnum,
         "MSEssGatewayClientContractsCipherResultMessage.StatusEnum": MSEssGatewayClientContractsCipherResultMessage.StatusEnum,
         "MSEssGatewayClientContractsCryptoFileInfo.HashTypeEnum": MSEssGatewayClientContractsCryptoFileInfo.HashTypeEnum,
         "MSEssGatewayClientContractsCryptoOperation.PrimitiveEnum": MSEssGatewayClientContractsCryptoOperation.PrimitiveEnum,
         "MSEssGatewayClientContractsCryptoRequestMessage.RegionEnum": MSEssGatewayClientContractsCryptoRequestMessage.RegionEnum,
         "MSEssGatewayClientContractsCryptoResultMessage.HashTypeEnum": MSEssGatewayClientContractsCryptoResultMessage.HashTypeEnum,
         "MSEssGatewayClientContractsCryptoResultMessage.StatusEnum": MSEssGatewayClientContractsCryptoResultMessage.StatusEnum,
         "MSEssGatewayClientContractsDigestSignCertificateResultMessage.StatusEnum": MSEssGatewayClientContractsDigestSignCertificateResultMessage.StatusEnum,
         "MSEssGatewayClientContractsDigestSignOperationErrorPatterns.StatusCodeEnum": MSEssGatewayClientContractsDigestSignOperationErrorPatterns.StatusCodeEnum,
         "MSEssGatewayClientContractsFileLocation.TypeEnum": MSEssGatewayClientContractsFileLocation.TypeEnum,
         "MSEssGatewayClientContractsFileTransferFileTransferResultMessage.HashTypeEnum": MSEssGatewayClientContractsFileTransferFileTransferResultMessage.HashTypeEnum,
         "MSEssGatewayClientContractsFileTransferFileTransferResultMessage.StatusEnum": MSEssGatewayClientContractsFileTransferFileTransferResultMessage.StatusEnum,
         "MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.FileStatusEnum": MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.FileStatusEnum,
         "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.DestinationHashTypeEnum": MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.DestinationHashTypeEnum,
         "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.StatusEnum": MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.StatusEnum,
         "MSEssGatewayClientContractsIFeature.FeatureTypeEnum": MSEssGatewayClientContractsIFeature.FeatureTypeEnum,
         "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApproverTypeEnum": MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApproverTypeEnum,
         "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApprovalStatusEnum": MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApprovalStatusEnum,
         "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.StatusEnum": MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.StatusEnum,
         "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.ApprovalStatusEnum": MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.ApprovalStatusEnum,
         "MSEssGatewayClientContractsPolicy.WorkflowExecutionTypeEnum": MSEssGatewayClientContractsPolicy.WorkflowExecutionTypeEnum,
         "MSEssGatewayClientContractsProvisionStorageResultMessage.StatusEnum": MSEssGatewayClientContractsProvisionStorageResultMessage.StatusEnum,
         "MSEssGatewayClientContractsReleaseEditApproverInfo.ActionEnum": MSEssGatewayClientContractsReleaseEditApproverInfo.ActionEnum,
         "MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.ActionEnum": MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.ActionEnum,
         "MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.ActionEnum": MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.ActionEnum,
         "MSEssGatewayClientContractsReleaseEditOwnerInfo.ActionEnum": MSEssGatewayClientContractsReleaseEditOwnerInfo.ActionEnum,
         "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.StatusCodeEnum": MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.StatusCodeEnum,
         "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.CipherTypeEnum": MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.CipherTypeEnum,
         "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.HashTypeEnum": MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.HashTypeEnum,
         "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.StatusCodeEnum": MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.StatusCodeEnum,
         "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.HashTypeEnum": MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.HashTypeEnum,
         "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.SecondaryDistributionHashTypeEnum": MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.SecondaryDistributionHashTypeEnum,
         "MSEssGatewayClientContractsReleaseFileScanStatus.StatusCodeEnum": MSEssGatewayClientContractsReleaseFileScanStatus.StatusCodeEnum,
         "MSEssGatewayClientContractsReleaseFileSignStatus.StatusCodeEnum": MSEssGatewayClientContractsReleaseFileSignStatus.StatusCodeEnum,
         "MSEssGatewayClientContractsReleaseFileSignStatus.HashTypeEnum": MSEssGatewayClientContractsReleaseFileSignStatus.HashTypeEnum,
         "MSEssGatewayClientContractsReleaseFileVaultStatusInfo.StatusEnum": MSEssGatewayClientContractsReleaseFileVaultStatusInfo.StatusEnum,
         "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.SecondaryDistributionHashTypeEnum": MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.SecondaryDistributionHashTypeEnum,
         "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.HashTypeEnum": MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.HashTypeEnum,
         "MSEssGatewayClientContractsReleaseReleaseFileInfo.SecondaryDistributionHashTypeEnum": MSEssGatewayClientContractsReleaseReleaseFileInfo.SecondaryDistributionHashTypeEnum,
         "MSEssGatewayClientContractsReleaseReleaseFileInfo.HashTypeEnum": MSEssGatewayClientContractsReleaseReleaseFileInfo.HashTypeEnum,
         "MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.StatusEnum": MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.StatusEnum,
         "MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.ApprovalStatusEnum": MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.ApprovalStatusEnum,
         "MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.ApprovalStatusEnum": MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.ApprovalStatusEnum,
         "MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.StatusEnum": MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.StatusEnum,
         "MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.StatusEnum": MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.StatusEnum,
         "MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.StatusEnum": MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.StatusEnum,
         "MSEssGatewayClientContractsRequestDetails.StatusEnum": MSEssGatewayClientContractsRequestDetails.StatusEnum,
         "MSEssGatewayClientContractsScanFileInfo.HashTypeEnum": MSEssGatewayClientContractsScanFileInfo.HashTypeEnum,
         "MSEssGatewayClientContractsScanGroupResult.ResultEnum": MSEssGatewayClientContractsScanGroupResult.ResultEnum,
         "MSEssGatewayClientContractsScanRequestMessage.RegionEnum": MSEssGatewayClientContractsScanRequestMessage.RegionEnum,
         "MSEssGatewayClientContractsScanResultMessage.HashTypeEnum": MSEssGatewayClientContractsScanResultMessage.HashTypeEnum,
         "MSEssGatewayClientContractsScanResultMessage.WorkflowTypeEnum": MSEssGatewayClientContractsScanResultMessage.WorkflowTypeEnum,
         "MSEssGatewayClientContractsScanResultMessage.StatusEnum": MSEssGatewayClientContractsScanResultMessage.StatusEnum,
         "MSEssGatewayClientContractsSessionResultMessage.StatusEnum": MSEssGatewayClientContractsSessionResultMessage.StatusEnum,
         "MSEssGatewayClientContractsSignFileInfo.HashTypeEnum": MSEssGatewayClientContractsSignFileInfo.HashTypeEnum,
         "MSEssGatewayClientContractsSignRequestMessage.RegionEnum": MSEssGatewayClientContractsSignRequestMessage.RegionEnum,
         "MSEssGatewayClientContractsSignResultMessage.HashTypeEnum": MSEssGatewayClientContractsSignResultMessage.HashTypeEnum,
         "MSEssGatewayClientContractsSignResultMessage.StatusEnum": MSEssGatewayClientContractsSignResultMessage.StatusEnum,
         "MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.StatusEnum": MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.StatusEnum,
         "MSEssGatewayClientOnPremContractsDigestSignRequestMessage.RegionEnum": MSEssGatewayClientOnPremContractsDigestSignRequestMessage.RegionEnum,
         "MSEssGatewayClientOnPremContractsDigestSignResultMessage.StatusEnum": MSEssGatewayClientOnPremContractsDigestSignResultMessage.StatusEnum,
         "MicrosoftAspNetODataQueryODataQuerySettings.HandleNullPropagationEnum": MicrosoftAspNetODataQueryODataQuerySettings.HandleNullPropagationEnum,
         "MicrosoftAspNetODataQueryOrderByNode.DirectionEnum": MicrosoftAspNetODataQueryOrderByNode.DirectionEnum,
         "MicrosoftODataEdmIEdmEntityContainer.SchemaElementKindEnum": MicrosoftODataEdmIEdmEntityContainer.SchemaElementKindEnum,
         "MicrosoftODataEdmIEdmEntityContainerElement.ContainerElementKindEnum": MicrosoftODataEdmIEdmEntityContainerElement.ContainerElementKindEnum,
         "MicrosoftODataEdmIEdmExpression.ExpressionKindEnum": MicrosoftODataEdmIEdmExpression.ExpressionKindEnum,
         "MicrosoftODataEdmIEdmNavigationProperty.OnDeleteEnum": MicrosoftODataEdmIEdmNavigationProperty.OnDeleteEnum,
         "MicrosoftODataEdmIEdmNavigationProperty.PropertyKindEnum": MicrosoftODataEdmIEdmNavigationProperty.PropertyKindEnum,
         "MicrosoftODataEdmIEdmPathExpression.ExpressionKindEnum": MicrosoftODataEdmIEdmPathExpression.ExpressionKindEnum,
         "MicrosoftODataEdmIEdmProperty.PropertyKindEnum": MicrosoftODataEdmIEdmProperty.PropertyKindEnum,
         "MicrosoftODataEdmIEdmSchemaElement.SchemaElementKindEnum": MicrosoftODataEdmIEdmSchemaElement.SchemaElementKindEnum,
         "MicrosoftODataEdmIEdmStructuralProperty.PropertyKindEnum": MicrosoftODataEdmIEdmStructuralProperty.PropertyKindEnum,
         "MicrosoftODataEdmIEdmStructuredType.TypeKindEnum": MicrosoftODataEdmIEdmStructuredType.TypeKindEnum,
         "MicrosoftODataEdmIEdmType.TypeKindEnum": MicrosoftODataEdmIEdmType.TypeKindEnum,
         "MicrosoftODataEdmVocabulariesIEdmTerm.SchemaElementKindEnum": MicrosoftODataEdmVocabulariesIEdmTerm.SchemaElementKindEnum,
         "MicrosoftODataUriParserAggregationTransformationNode.KindEnum": MicrosoftODataUriParserAggregationTransformationNode.KindEnum,
         "MicrosoftODataUriParserOrderByClause.DirectionEnum": MicrosoftODataUriParserOrderByClause.DirectionEnum,
         "MicrosoftODataUriParserSingleValueNode.KindEnum": MicrosoftODataUriParserSingleValueNode.KindEnum,
         "SystemNetIPAddress.AddressFamilyEnum": SystemNetIPAddress.AddressFamilyEnum,
 }
 
 let typeMap: {[index: string]: any} = {
     "MSEssGatewayClientContractsCipherDetailsMessage": MSEssGatewayClientContractsCipherDetailsMessage,
     "MSEssGatewayClientContractsCipherInfo": MSEssGatewayClientContractsCipherInfo,
     "MSEssGatewayClientContractsCipherResultMessage": MSEssGatewayClientContractsCipherResultMessage,
     "MSEssGatewayClientContractsCryptoFileInfo": MSEssGatewayClientContractsCryptoFileInfo,
     "MSEssGatewayClientContractsCryptoOperation": MSEssGatewayClientContractsCryptoOperation,
     "MSEssGatewayClientContractsCryptoParameter": MSEssGatewayClientContractsCryptoParameter,
     "MSEssGatewayClientContractsCryptoRequestMessage": MSEssGatewayClientContractsCryptoRequestMessage,
     "MSEssGatewayClientContractsCryptoResultMessage": MSEssGatewayClientContractsCryptoResultMessage,
     "MSEssGatewayClientContractsDigestSignCertificateRequestMessage": MSEssGatewayClientContractsDigestSignCertificateRequestMessage,
     "MSEssGatewayClientContractsDigestSignCertificateResultMessage": MSEssGatewayClientContractsDigestSignCertificateResultMessage,
     "MSEssGatewayClientContractsDigestSignMapping": MSEssGatewayClientContractsDigestSignMapping,
     "MSEssGatewayClientContractsDigestSignOperationErrorPatterns": MSEssGatewayClientContractsDigestSignOperationErrorPatterns,
     "MSEssGatewayClientContractsDynamicSigningOperation": MSEssGatewayClientContractsDynamicSigningOperation,
     "MSEssGatewayClientContractsEsrpClientConfigInfo3": MSEssGatewayClientContractsEsrpClientConfigInfo3,
     "MSEssGatewayClientContractsEventHubTelemetryConnectionShard": MSEssGatewayClientContractsEventHubTelemetryConnectionShard,
     "MSEssGatewayClientContractsFileLocation": MSEssGatewayClientContractsFileLocation,
     "MSEssGatewayClientContractsFileTransferFileTransferResultMessage": MSEssGatewayClientContractsFileTransferFileTransferResultMessage,
     "MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult": MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult,
     "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage": MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage,
     "MSEssGatewayClientContractsGatewayError": MSEssGatewayClientContractsGatewayError,
     "MSEssGatewayClientContractsIFeature": MSEssGatewayClientContractsIFeature,
     "MSEssGatewayClientContractsInnerServiceError": MSEssGatewayClientContractsInnerServiceError,
     "MSEssGatewayClientContractsLegacyCopsMappingData": MSEssGatewayClientContractsLegacyCopsMappingData,
     "MSEssGatewayClientContractsOperationResponse": MSEssGatewayClientContractsOperationResponse,
     "MSEssGatewayClientContractsOperationTemplate": MSEssGatewayClientContractsOperationTemplate,
     "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo": MSEssGatewayClientContractsPKITACertificateClmApprovalInfo,
     "MSEssGatewayClientContractsPKITACertificateCsrFile": MSEssGatewayClientContractsPKITACertificateCsrFile,
     "MSEssGatewayClientContractsPKITACertificateFailedCsrFile": MSEssGatewayClientContractsPKITACertificateFailedCsrFile,
     "MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage": MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage,
     "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage": MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage,
     "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage": MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage,
     "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage": MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage,
     "MSEssGatewayClientContractsPKITACertificatePolicyExtension": MSEssGatewayClientContractsPKITACertificatePolicyExtension,
     "MSEssGatewayClientContractsPKITACertificateValidityDuration": MSEssGatewayClientContractsPKITACertificateValidityDuration,
     "MSEssGatewayClientContractsPkitaCertificateCertificateInfo": MSEssGatewayClientContractsPkitaCertificateCertificateInfo,
     "MSEssGatewayClientContractsPolicy": MSEssGatewayClientContractsPolicy,
     "MSEssGatewayClientContractsPolicyResultMessage": MSEssGatewayClientContractsPolicyResultMessage,
     "MSEssGatewayClientContractsProvisionStorageRequest": MSEssGatewayClientContractsProvisionStorageRequest,
     "MSEssGatewayClientContractsProvisionStorageResultMessage": MSEssGatewayClientContractsProvisionStorageResultMessage,
     "MSEssGatewayClientContractsReleaseAccessPermissionsInfo": MSEssGatewayClientContractsReleaseAccessPermissionsInfo,
     "MSEssGatewayClientContractsReleaseApproverInfo": MSEssGatewayClientContractsReleaseApproverInfo,
     "MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo": MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo,
     "MSEssGatewayClientContractsReleaseEditApproverInfo": MSEssGatewayClientContractsReleaseEditApproverInfo,
     "MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo": MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo,
     "MSEssGatewayClientContractsReleaseEditChannelDownloadEntity": MSEssGatewayClientContractsReleaseEditChannelDownloadEntity,
     "MSEssGatewayClientContractsReleaseEditOwnerInfo": MSEssGatewayClientContractsReleaseEditOwnerInfo,
     "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus": MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus,
     "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus": MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus,
     "MSEssGatewayClientContractsReleaseFileScanStatus": MSEssGatewayClientContractsReleaseFileScanStatus,
     "MSEssGatewayClientContractsReleaseFileSignStatus": MSEssGatewayClientContractsReleaseFileSignStatus,
     "MSEssGatewayClientContractsReleaseFileVaultStatusInfo": MSEssGatewayClientContractsReleaseFileVaultStatusInfo,
     "MSEssGatewayClientContractsReleaseOwnerInfo": MSEssGatewayClientContractsReleaseOwnerInfo,
     "MSEssGatewayClientContractsReleaseProductInfo": MSEssGatewayClientContractsReleaseProductInfo,
     "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo": MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo,
     "MSEssGatewayClientContractsReleaseReleaseFileInfo": MSEssGatewayClientContractsReleaseReleaseFileInfo,
     "MSEssGatewayClientContractsReleaseReleaseInfo": MSEssGatewayClientContractsReleaseReleaseInfo,
     "MSEssGatewayClientContractsReleaseReleaseInfoProperties": MSEssGatewayClientContractsReleaseReleaseInfoProperties,
     "MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo": MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo,
     "MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage": MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage,
     "MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage": MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage,
     "MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage": MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage,
     "MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage": MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage,
     "MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage": MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage,
     "MSEssGatewayClientContractsReleaseResponseApproverInfoDetails": MSEssGatewayClientContractsReleaseResponseApproverInfoDetails,
     "MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo": MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo,
     "MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage": MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage,
     "MSEssGatewayClientContractsReleaseResponseReleaseEditResponse": MSEssGatewayClientContractsReleaseResponseReleaseEditResponse,
     "MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage": MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage,
     "MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo": MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo,
     "MSEssGatewayClientContractsReleaseResponseReleaseError": MSEssGatewayClientContractsReleaseResponseReleaseError,
     "MSEssGatewayClientContractsReleaseResponseReleaseResultMessage": MSEssGatewayClientContractsReleaseResponseReleaseResultMessage,
     "MSEssGatewayClientContractsReleaseUserInfo": MSEssGatewayClientContractsReleaseUserInfo,
     "MSEssGatewayClientContractsRequestDetails": MSEssGatewayClientContractsRequestDetails,
     "MSEssGatewayClientContractsRoutingInfo": MSEssGatewayClientContractsRoutingInfo,
     "MSEssGatewayClientContractsScanFileInfo": MSEssGatewayClientContractsScanFileInfo,
     "MSEssGatewayClientContractsScanGroupResult": MSEssGatewayClientContractsScanGroupResult,
     "MSEssGatewayClientContractsScanRequestMessage": MSEssGatewayClientContractsScanRequestMessage,
     "MSEssGatewayClientContractsScanResultMessage": MSEssGatewayClientContractsScanResultMessage,
     "MSEssGatewayClientContractsSessionRequestMessage": MSEssGatewayClientContractsSessionRequestMessage,
     "MSEssGatewayClientContractsSessionResultMessage": MSEssGatewayClientContractsSessionResultMessage,
     "MSEssGatewayClientContractsSignFileInfo": MSEssGatewayClientContractsSignFileInfo,
     "MSEssGatewayClientContractsSignRequestMessage": MSEssGatewayClientContractsSignRequestMessage,
     "MSEssGatewayClientContractsSignResultMessage": MSEssGatewayClientContractsSignResultMessage,
     "MSEssGatewayClientContractsSigningParameter": MSEssGatewayClientContractsSigningParameter,
     "MSEssGatewayClientContractsSlkRequestSlkRequestMessage": MSEssGatewayClientContractsSlkRequestSlkRequestMessage,
     "MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse": MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse,
     "MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_": MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_,
     "MSEssGatewayClientContractsStaticSigningOperation": MSEssGatewayClientContractsStaticSigningOperation,
     "MSEssGatewayClientContractsStorageShard": MSEssGatewayClientContractsStorageShard,
     "MSEssGatewayClientOnPremContractsDigestSignRequestMessage": MSEssGatewayClientOnPremContractsDigestSignRequestMessage,
     "MSEssGatewayClientOnPremContractsDigestSignResultMessage": MSEssGatewayClientOnPremContractsDigestSignResultMessage,
     "MSEssGatewayClientOnPremContractsHashInfo": MSEssGatewayClientOnPremContractsHashInfo,
     "MSEssGatewayClientOnPremContractsSignedDigest": MSEssGatewayClientOnPremContractsSignedDigest,
     "MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager": MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager,
     "MicrosoftAspNetCoreHttpConnectionInfo": MicrosoftAspNetCoreHttpConnectionInfo,
     "MicrosoftAspNetCoreHttpHostString": MicrosoftAspNetCoreHttpHostString,
     "MicrosoftAspNetCoreHttpHttpContext": MicrosoftAspNetCoreHttpHttpContext,
     "MicrosoftAspNetCoreHttpHttpRequest": MicrosoftAspNetCoreHttpHttpRequest,
     "MicrosoftAspNetCoreHttpHttpResponse": MicrosoftAspNetCoreHttpHttpResponse,
     "MicrosoftAspNetCoreHttpIResponseCookies": MicrosoftAspNetCoreHttpIResponseCookies,
     "MicrosoftAspNetCoreHttpISession": MicrosoftAspNetCoreHttpISession,
     "MicrosoftAspNetCoreHttpQueryString": MicrosoftAspNetCoreHttpQueryString,
     "MicrosoftAspNetCoreHttpWebSocketManager": MicrosoftAspNetCoreHttpWebSocketManager,
     "MicrosoftAspNetODataODataQueryContext": MicrosoftAspNetODataODataQueryContext,
     "MicrosoftAspNetODataQueryApplyQueryOption": MicrosoftAspNetODataQueryApplyQueryOption,
     "MicrosoftAspNetODataQueryCountQueryOption": MicrosoftAspNetODataQueryCountQueryOption,
     "MicrosoftAspNetODataQueryDefaultQuerySettings": MicrosoftAspNetODataQueryDefaultQuerySettings,
     "MicrosoftAspNetODataQueryFilterQueryOption": MicrosoftAspNetODataQueryFilterQueryOption,
     "MicrosoftAspNetODataQueryODataQueryOptions": MicrosoftAspNetODataQueryODataQueryOptions,
     "MicrosoftAspNetODataQueryODataQuerySettings": MicrosoftAspNetODataQueryODataQuerySettings,
     "MicrosoftAspNetODataQueryODataRawQueryOptions": MicrosoftAspNetODataQueryODataRawQueryOptions,
     "MicrosoftAspNetODataQueryOrderByNode": MicrosoftAspNetODataQueryOrderByNode,
     "MicrosoftAspNetODataQueryOrderByQueryOption": MicrosoftAspNetODataQueryOrderByQueryOption,
     "MicrosoftAspNetODataQuerySelectExpandQueryOption": MicrosoftAspNetODataQuerySelectExpandQueryOption,
     "MicrosoftAspNetODataQuerySkipQueryOption": MicrosoftAspNetODataQuerySkipQueryOption,
     "MicrosoftAspNetODataQuerySkipTokenQueryOption": MicrosoftAspNetODataQuerySkipTokenQueryOption,
     "MicrosoftAspNetODataQueryTopQueryOption": MicrosoftAspNetODataQueryTopQueryOption,
     "MicrosoftAspNetODataQueryValidatorsCountQueryValidator": MicrosoftAspNetODataQueryValidatorsCountQueryValidator,
     "MicrosoftAspNetODataQueryValidatorsFilterQueryValidator": MicrosoftAspNetODataQueryValidatorsFilterQueryValidator,
     "MicrosoftAspNetODataQueryValidatorsODataQueryValidator": MicrosoftAspNetODataQueryValidatorsODataQueryValidator,
     "MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator": MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator,
     "MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator": MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator,
     "MicrosoftAspNetODataQueryValidatorsSkipQueryValidator": MicrosoftAspNetODataQueryValidatorsSkipQueryValidator,
     "MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator": MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator,
     "MicrosoftAspNetODataQueryValidatorsTopQueryValidator": MicrosoftAspNetODataQueryValidatorsTopQueryValidator,
     "MicrosoftAspNetODataRoutingODataPath": MicrosoftAspNetODataRoutingODataPath,
     "MicrosoftODataEdmEdmReferentialConstraintPropertyPair": MicrosoftODataEdmEdmReferentialConstraintPropertyPair,
     "MicrosoftODataEdmIEdmEntityContainer": MicrosoftODataEdmIEdmEntityContainer,
     "MicrosoftODataEdmIEdmEntityContainerElement": MicrosoftODataEdmIEdmEntityContainerElement,
     "MicrosoftODataEdmIEdmExpression": MicrosoftODataEdmIEdmExpression,
     "MicrosoftODataEdmIEdmModel": MicrosoftODataEdmIEdmModel,
     "MicrosoftODataEdmIEdmNavigationProperty": MicrosoftODataEdmIEdmNavigationProperty,
     "MicrosoftODataEdmIEdmNavigationPropertyBinding": MicrosoftODataEdmIEdmNavigationPropertyBinding,
     "MicrosoftODataEdmIEdmNavigationSource": MicrosoftODataEdmIEdmNavigationSource,
     "MicrosoftODataEdmIEdmPathExpression": MicrosoftODataEdmIEdmPathExpression,
     "MicrosoftODataEdmIEdmProperty": MicrosoftODataEdmIEdmProperty,
     "MicrosoftODataEdmIEdmReferentialConstraint": MicrosoftODataEdmIEdmReferentialConstraint,
     "MicrosoftODataEdmIEdmSchemaElement": MicrosoftODataEdmIEdmSchemaElement,
     "MicrosoftODataEdmIEdmStructuralProperty": MicrosoftODataEdmIEdmStructuralProperty,
     "MicrosoftODataEdmIEdmStructuredType": MicrosoftODataEdmIEdmStructuredType,
     "MicrosoftODataEdmIEdmType": MicrosoftODataEdmIEdmType,
     "MicrosoftODataEdmIEdmTypeReference": MicrosoftODataEdmIEdmTypeReference,
     "MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager": MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager,
     "MicrosoftODataEdmVocabulariesIEdmTerm": MicrosoftODataEdmVocabulariesIEdmTerm,
     "MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable": MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable,
     "MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation": MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation,
     "MicrosoftODataUriParserAggregationApplyClause": MicrosoftODataUriParserAggregationApplyClause,
     "MicrosoftODataUriParserAggregationTransformationNode": MicrosoftODataUriParserAggregationTransformationNode,
     "MicrosoftODataUriParserFilterClause": MicrosoftODataUriParserFilterClause,
     "MicrosoftODataUriParserODataPathSegment": MicrosoftODataUriParserODataPathSegment,
     "MicrosoftODataUriParserOrderByClause": MicrosoftODataUriParserOrderByClause,
     "MicrosoftODataUriParserRangeVariable": MicrosoftODataUriParserRangeVariable,
     "MicrosoftODataUriParserSelectExpandClause": MicrosoftODataUriParserSelectExpandClause,
     "MicrosoftODataUriParserSelectItem": MicrosoftODataUriParserSelectItem,
     "MicrosoftODataUriParserSingleValueNode": MicrosoftODataUriParserSingleValueNode,
     "MicrosoftWin32SafeHandlesSafeWaitHandle": MicrosoftWin32SafeHandlesSafeWaitHandle,
     "SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_": SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_,
     "SystemCollectionsGenericKeyValuePair2SystemStringSystemString_": SystemCollectionsGenericKeyValuePair2SystemStringSystemString_,
     "SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_": SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_,
     "SystemIOStream": SystemIOStream,
     "SystemIServiceProvider": SystemIServiceProvider,
     "SystemNetIPAddress": SystemNetIPAddress,
     "SystemSecurityClaimsClaim": SystemSecurityClaimsClaim,
     "SystemSecurityClaimsClaimsIdentity": SystemSecurityClaimsClaimsIdentity,
     "SystemSecurityClaimsClaimsPrincipal": SystemSecurityClaimsClaimsPrincipal,
     "SystemSecurityPrincipalIIdentity": SystemSecurityPrincipalIIdentity,
     "SystemThreadingCancellationToken": SystemThreadingCancellationToken,
     "SystemThreadingWaitHandle": SystemThreadingWaitHandle,
 }
 
 export interface Authentication {
     /**
     * Apply authentication settings to header and query params.
     */
     applyToRequest(requestOptions: localVarRequest.Options): void;
 }
 
 export class HttpBasicAuth implements Authentication {
     public username: string = '';
     public password: string = '';
 
     applyToRequest(requestOptions: localVarRequest.Options): void {
         requestOptions.auth = {
             username: this.username, password: this.password
         }
     }
 }
 
 export class ApiKeyAuth implements Authentication {
     public apiKey: string = '';
 
     constructor(private location: string, private paramName: string) {
     }
 
     applyToRequest(requestOptions: localVarRequest.Options): void {
         if (this.location == "query") {
             (<any>requestOptions.qs)[this.paramName] = this.apiKey;
         } else if (this.location == "header" && requestOptions && requestOptions.headers) {
             requestOptions.headers[this.paramName] = this.apiKey;
         }
     }
 }
 
 export class OAuth implements Authentication {
     public accessToken: string = '';
 
     applyToRequest(requestOptions: localVarRequest.Options): void {
         if (requestOptions && requestOptions.headers) {
             requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
         }
     }
 }
 
 export class VoidAuth implements Authentication {
     public username: string = '';
     public password: string = '';
 
     applyToRequest(_: localVarRequest.Options): void {
         // Do nothing
     }
 }
 
 export enum CryptoApiApiKeys {
 }
 
 export class CryptoApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: CryptoApiApiKeys, value: string) {
         (this.authentications as any)[CryptoApiApiKeys[key]].apiKey = value;
     }
     /**
      * When crypto cipher operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
      * @summary Gets the details of cipher workflow.
      * @param operationid OperationId value for a cipher workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public cryptoGetCipherDetailsByOperationIdAsync (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsCipherDetailsMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/cipher/details/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling cryptoGetCipherDetailsByOperationIdAsync.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling cryptoGetCipherDetailsByOperationIdAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling cryptoGetCipherDetailsByOperationIdAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsCipherDetailsMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsCipherDetailsMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * When crypto cipher operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
      * @summary Gets the current status of cipher workflow.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public cryptoGetcipherstatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsCipherResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/cipher/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling cryptoGetcipherstatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling cryptoGetcipherstatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling cryptoGetcipherstatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsCipherResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsCipherResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * When crypto operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
      * @summary Gets the current status of crypto workflow.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public cryptoGetcryptostatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsCryptoResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/crypto/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling cryptoGetcryptostatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling cryptoGetcryptostatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling cryptoGetcryptostatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsCryptoResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsCryptoResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * Needs to be added
      * @summary Initiates crypto cipher request for given input files.
      * @param clientid client application AAD Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public cryptoPostCipherAsync (clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/cipher'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling cryptoPostCipherAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling cryptoPostCipherAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * Needs to be added
      * @summary Initiates crypto request for given input files.
      * @param clientid client application AAD Id
      * @param version 
      * @param cryptoRequestMessage crypto request message
      * @param {*} [options] Override http request options.
      */
     public cryptoPostCryptoAsync (clientid: string, version: string, cryptoRequestMessage?: MSEssGatewayClientContractsCryptoRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/crypto'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling cryptoPostCryptoAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling cryptoPostCryptoAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(cryptoRequestMessage, "MSEssGatewayClientContractsCryptoRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum DigestSignApiApiKeys {
 }
 
 export class DigestSignApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: DigestSignApiApiKeys, value: string) {
         (this.authentications as any)[DigestSignApiApiKeys[key]].apiKey = value;
     }
     /**
      * Gets the mapping of key codes for digest signing on client side
      * @summary Gets the mapping of key codes for digest signing on client side
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public digestSignGetDigestSignKeyCodeMappingsAsync (clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign/keycodes'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling digestSignGetDigestSignKeyCodeMappingsAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling digestSignGetDigestSignKeyCodeMappingsAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * When signing operation is successful, the response from this call contains certificate.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.
      * @summary Gets the current status of DigestSign Ceritificate workflow.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public digestSignGetdigestsigncertificatestatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsDigestSignCertificateResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign/certificate/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling digestSignGetdigestsigncertificatestatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling digestSignGetdigestsigncertificatestatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling digestSignGetdigestsigncertificatestatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsDigestSignCertificateResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsDigestSignCertificateResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
      * @summary Gets the current status of DigestSign workflow.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public digestSignGetdigestsignstatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientOnPremContractsDigestSignResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling digestSignGetdigestsignstatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling digestSignGetdigestsignstatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling digestSignGetdigestsignstatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientOnPremContractsDigestSignResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientOnPremContractsDigestSignResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * A signed file is returned only after scanning is passed. This operation initiates a stepwise long running operation on server.              \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id              upon successful acceptace of payload and expected to check status of the workflow at later time.
      * @summary Initiates digest signing for given input.
      * @param clientid client application AAD Id
      * @param version 
      * @param request digestSign request.
      * @param {*} [options] Override http request options.
      */
     public digestSignPostDigestSignAsync (clientid: string, version: string, request?: MSEssGatewayClientOnPremContractsDigestSignRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling digestSignPostDigestSignAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling digestSignPostDigestSignAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientOnPremContractsDigestSignRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * A digestsign certificate will be returned if the job passed. This operation initiates a stepwise long running operation on server.              \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id              upon successful acceptace of payload and expected to check status of the workflow at later time.
      * @summary Initiates digest sign certificate request for given input.
      * @param clientid client application AAD Id
      * @param version 
      * @param request digestSign request certificate message.
      * @param {*} [options] Override http request options.
      */
     public digestSignPostDigestSignCertificateAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsDigestSignCertificateRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign/certificate'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling digestSignPostDigestSignCertificateAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling digestSignPostDigestSignCertificateAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsDigestSignCertificateRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum FileTransferApiApiKeys {
 }
 
 export class FileTransferApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: FileTransferApiApiKeys, value: string) {
         (this.authentications as any)[FileTransferApiApiKeys[key]].apiKey = value;
     }
     /**
      * When file transfer/copying operation is finished, the response from this call contains the status or result of the operation.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully transferedcopied to destination location.
      * @summary Gets the current status of file transfer/copy workflow using operation Id given at the time of submission.
      * @param operationid OperationId value for a file transfer/copy.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public fileTransferGetfiletransferstatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsFileTransferFileTransferResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/filetransfer/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling fileTransferGetfiletransferstatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling fileTransferGetfiletransferstatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling fileTransferGetfiletransferstatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsFileTransferFileTransferResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsFileTransferFileTransferResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * When piece hash operation is finished, the response from this call contains the status or result of the operation.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and piece hash operation can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates that the file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates that the piece hash files are generated and uploaded to the destination locations.
      * @summary Gets the current status of piece hash workflow using operation Id given at the time of submission.
      * @param operationid OperationId value for piece hash.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public fileTransferGetpiecehashstatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/filetransfer/piecehash/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling fileTransferGetpiecehashstatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling fileTransferGetpiecehashstatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling fileTransferGetpiecehashstatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This operation initiates a stepwise long running operation on server.             \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id             upon successful acceptance of payload and user is expected to check status of the workflow at later time.
      * @summary Initiates file copy from source location to destination location provided in the payload.
      * @param clientid client application AAD Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public fileTransferPostFileTransfer (clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/filetransfer'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling fileTransferPostFileTransfer.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling fileTransferPostFileTransfer.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This operation initiates a stepwise long running operation on server.             \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id             upon successful acceptance of payload and user is expected to check status of the workflow at later time.
      * @summary Initiates Piece Hash file generation for a given source file (mentioned in source location) and upload the same to the destination locations provided in the payload.
      * @param clientid client application AAD Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public fileTransferPostPieceHash (clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/filetransfer/piecehash'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling fileTransferPostPieceHash.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling fileTransferPostPieceHash.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum GroupApiApiKeys {
 }
 
 export class GroupApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: GroupApiApiKeys, value: string) {
         (this.authentications as any)[GroupApiApiKeys[key]].apiKey = value;
     }
     /**
      * 
      * @param clientid 
      * @param id 
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public groupCloseGroupId (clientid: string, id: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/groups/{id}'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling groupCloseGroupId.');
         }
 
         // verify required parameter 'id' is not null or undefined
         if (id === null || id === undefined) {
             throw new Error('Required parameter id was null or undefined when calling groupCloseGroupId.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling groupCloseGroupId.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'PATCH',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * 
      * @param clientid 
      * @param id 
      * @param version 
      * @param queryOptions 
      * @param {*} [options] Override http request options.
      */
     public groupGetScanResultForGroup (clientid: string, id: string, version: string, queryOptions?: MicrosoftAspNetODataQueryODataQueryOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MSEssGatewayClientContractsScanGroupResult>;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/groups/{id}/workflows/scan/result'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling groupGetScanResultForGroup.');
         }
 
         // verify required parameter 'id' is not null or undefined
         if (id === null || id === undefined) {
             throw new Error('Required parameter id was null or undefined when calling groupGetScanResultForGroup.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling groupGetScanResultForGroup.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(queryOptions, "MicrosoftAspNetODataQueryODataQueryOptions")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: Array<MSEssGatewayClientContractsScanGroupResult>;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "Array<MSEssGatewayClientContractsScanGroupResult>");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum HealthApiApiKeys {
 }
 
 export class HealthApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: HealthApiApiKeys, value: string) {
         (this.authentications as any)[HealthApiApiKeys[key]].apiKey = value;
     }
     /**
      * 
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public healthHealthCheck (version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/healthcheck'
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling healthHealthCheck.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum KeyFulfilmentApiApiKeys {
 }
 
 export class KeyFulfilmentApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: KeyFulfilmentApiApiKeys, value: string) {
         (this.authentications as any)[KeyFulfilmentApiApiKeys[key]].apiKey = value;
     }
     /**
      * This requests is sent by Slk Portal.
      * @summary Get pending key fulfilment requests that might need approval or retry
      * @param clientid client application AAD Id
      * @param version 
      * @param userEmailId 
      * @param keyFulfilmentRequestId 
      * @param status 
      * @param limit 
      * @param pageNumber 
      * @param startDate 
      * @param endDate 
      * @param sortByStatus 
      * @param {*} [options] Override http request options.
      */
     public keyFulfilmentGetKeyFulfilmentAsync (clientid: string, version: string, userEmailId?: string, keyFulfilmentRequestId?: string, status?: 'NotStarted' | 'InProgress' | 'WaitingForRanges' | 'WaitingForApproval' | 'Failed' | 'Completed' | 'Cancelled' | 'Rejected', limit?: number, pageNumber?: number, startDate?: Date, endDate?: Date, sortByStatus?: 'Asc' | 'Desc', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyfulfilment/pending-requests'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling keyFulfilmentGetKeyFulfilmentAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling keyFulfilmentGetKeyFulfilmentAsync.');
         }
 
         if (userEmailId !== undefined) {
             localVarQueryParameters['UserEmailId'] = ObjectSerializer.serialize(userEmailId, "string");
         }
 
         if (keyFulfilmentRequestId !== undefined) {
             localVarQueryParameters['KeyFulfilmentRequestId'] = ObjectSerializer.serialize(keyFulfilmentRequestId, "string");
         }
 
         if (status !== undefined) {
             localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'NotStarted' | 'InProgress' | 'WaitingForRanges' | 'WaitingForApproval' | 'Failed' | 'Completed' | 'Cancelled' | 'Rejected'");
         }
 
         if (limit !== undefined) {
             localVarQueryParameters['Limit'] = ObjectSerializer.serialize(limit, "number");
         }
 
         if (pageNumber !== undefined) {
             localVarQueryParameters['PageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
         }
 
         if (startDate !== undefined) {
             localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
         }
 
         if (endDate !== undefined) {
             localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
         }
 
         if (sortByStatus !== undefined) {
             localVarQueryParameters['SortByStatus'] = ObjectSerializer.serialize(sortByStatus, "'Asc' | 'Desc'");
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This requests is sent by Slk tenants. It sends the request to Slk to generate Key which is then sent back to tenants.
      * @summary Initiates Key fulfilment request for Slk
      * @param clientid client application AAD Id
      * @param version 
      * @param request Request Information
      * @param {*} [options] Override http request options.
      */
     public keyFulfilmentRequestKeyFulfilmentAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsSlkRequestSlkRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyfulfilment'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling keyFulfilmentRequestKeyFulfilmentAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling keyFulfilmentRequestKeyFulfilmentAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This requests is sent by Slk Portal and generated by slk buisness
      * @summary Update key fulfilment request. All update requires KeyFulfilmentRequestId.  To approve or reject, set ApprovalStatus as approve/reject  To cancel or complete, set WorkflowStatus as Cancelled or Completed.  To retry, just set the KeyFulfilmentRequestId.  No other operations or status change is allowed.
      * @param clientid client application AAD Id
      * @param version 
      * @param request Request Information
      * @param {*} [options] Override http request options.
      */
     public keyFulfilmentUpdateKeyFulfilmentAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsSlkRequestSlkRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyfulfilment'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling keyFulfilmentUpdateKeyFulfilmentAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling keyFulfilmentUpdateKeyFulfilmentAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'PATCH',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum KeyValidationApiApiKeys {
 }
 
 export class KeyValidationApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: KeyValidationApiApiKeys, value: string) {
         (this.authentications as any)[KeyValidationApiApiKeys[key]].apiKey = value;
     }
     /**
      * This requests is sent by Slk Portal.
      * @summary Gets all keyvalidation request depending on the query request. (Paginated)
      * @param clientid client application AAD Id
      * @param version 
      * @param userEmailId 
      * @param keyValidationRequestId 
      * @param status 
      * @param limit 
      * @param pageNumber 
      * @param startDate 
      * @param endDate 
      * @param {*} [options] Override http request options.
      */
     public keyValidationGetKeyValidationsAsync (clientid: string, version: string, userEmailId?: string, keyValidationRequestId?: string, status?: 'NotStarted' | 'InProgress' | 'Completed' | 'Cancelled' | 'PartialCompleted' | 'Failed', limit?: number, pageNumber?: number, startDate?: Date, endDate?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyvalidations'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling keyValidationGetKeyValidationsAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling keyValidationGetKeyValidationsAsync.');
         }
 
         if (userEmailId !== undefined) {
             localVarQueryParameters['UserEmailId'] = ObjectSerializer.serialize(userEmailId, "string");
         }
 
         if (keyValidationRequestId !== undefined) {
             localVarQueryParameters['KeyValidationRequestId'] = ObjectSerializer.serialize(keyValidationRequestId, "string");
         }
 
         if (status !== undefined) {
             localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'NotStarted' | 'InProgress' | 'Completed' | 'Cancelled' | 'PartialCompleted' | 'Failed'");
         }
 
         if (limit !== undefined) {
             localVarQueryParameters['Limit'] = ObjectSerializer.serialize(limit, "number");
         }
 
         if (pageNumber !== undefined) {
             localVarQueryParameters['PageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
         }
 
         if (startDate !== undefined) {
             localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
         }
 
         if (endDate !== undefined) {
             localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This requests is sent by Slk Portal.
      * @summary Gets all pending keyvalidation request depending on the query request. (Paginated)
      * @param clientid client application AAD Id
      * @param version 
      * @param userEmailId 
      * @param keyValidationRequestId 
      * @param status 
      * @param limit 
      * @param pageNumber 
      * @param startDate 
      * @param endDate 
      * @param {*} [options] Override http request options.
      */
     public keyValidationGetPendingKeyValidationsAsync (clientid: string, version: string, userEmailId?: string, keyValidationRequestId?: string, status?: 'NotStarted' | 'InProgress' | 'Completed' | 'Cancelled' | 'PartialCompleted' | 'Failed', limit?: number, pageNumber?: number, startDate?: Date, endDate?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyvalidations/pending-requests'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling keyValidationGetPendingKeyValidationsAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling keyValidationGetPendingKeyValidationsAsync.');
         }
 
         if (userEmailId !== undefined) {
             localVarQueryParameters['UserEmailId'] = ObjectSerializer.serialize(userEmailId, "string");
         }
 
         if (keyValidationRequestId !== undefined) {
             localVarQueryParameters['KeyValidationRequestId'] = ObjectSerializer.serialize(keyValidationRequestId, "string");
         }
 
         if (status !== undefined) {
             localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'NotStarted' | 'InProgress' | 'Completed' | 'Cancelled' | 'PartialCompleted' | 'Failed'");
         }
 
         if (limit !== undefined) {
             localVarQueryParameters['Limit'] = ObjectSerializer.serialize(limit, "number");
         }
 
         if (pageNumber !== undefined) {
             localVarQueryParameters['PageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
         }
 
         if (startDate !== undefined) {
             localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
         }
 
         if (endDate !== undefined) {
             localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This requests is sent by Slk Portal. It sends the request to Slk to validate Key which is then notified back
      * @summary Submits a new Key validation request
      * @param clientid client application AAD Id
      * @param version 
      * @param request Request Information
      * @param {*} [options] Override http request options.
      */
     public keyValidationSubmitKeyValidationAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsSlkRequestSlkRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyvalidation'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling keyValidationSubmitKeyValidationAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling keyValidationSubmitKeyValidationAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This requests is sent by Slk Portal.
      * @summary Submits an update request for an existing key validation request  To cancel, set KeyValidationRequestStatus as Cancelled and KeyValidationRequestId   To retry, just set the KeyValidationRequestId.  No other operations or status change is allowed.
      * @param clientid client application AAD Id
      * @param version 
      * @param request request Information
      * @param {*} [options] Override http request options.
      */
     public keyValidationUpdateKeyValidationAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsSlkRequestSlkRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyvalidation'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling keyValidationUpdateKeyValidationAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling keyValidationUpdateKeyValidationAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'PATCH',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum PkitaCLMCertificateApiApiKeys {
 }
 
 export class PkitaCLMCertificateApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: PkitaCLMCertificateApiApiKeys, value: string) {
         (this.authentications as any)[PkitaCLMCertificateApiApiKeys[key]].apiKey = value;
     }
     /**
      * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
      * @summary Gets the current status of pkita clm certificate request workflow.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public pkitaCLMCertificateGetclmcertificatestatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/clmcertificate/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling pkitaCLMCertificateGetclmcertificatestatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling pkitaCLMCertificateGetclmcertificatestatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling pkitaCLMCertificateGetclmcertificatestatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * Request pkita clm to generate a certificate.
      * @summary Initiates pkita clm certificate request.
      * @param clientid client application AAD Id
      * @param version 
      * @param request pkita clm certificate request.
      * @param {*} [options] Override http request options.
      */
     public pkitaCLMCertificatePostCertificateAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/clmcertificate'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling pkitaCLMCertificatePostCertificateAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling pkitaCLMCertificatePostCertificateAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum PkitaCLMCertificateApprovalApiApiKeys {
 }
 
 export class PkitaCLMCertificateApprovalApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: PkitaCLMCertificateApprovalApiApiKeys, value: string) {
         (this.authentications as any)[PkitaCLMCertificateApprovalApiApiKeys[key]].apiKey = value;
     }
     /**
      * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
      * @summary Gets the current status of pkita clm certificate request approval workflow.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public pkitaCLMCertificateApprovalGetclmcertificateapprovalstatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/clmcertificateapproval/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling pkitaCLMCertificateApprovalGetclmcertificateapprovalstatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling pkitaCLMCertificateApprovalGetclmcertificateapprovalstatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling pkitaCLMCertificateApprovalGetclmcertificateapprovalstatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * Request pkita clm to generate a certificate request approval.
      * @summary Initiates pkita clm certificate request approval.
      * @param clientid client application AAD Id
      * @param version 
      * @param request pkita clm certificate request approval.
      * @param {*} [options] Override http request options.
      */
     public pkitaCLMCertificateApprovalPostCertificateAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/clmcertificateapproval'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling pkitaCLMCertificateApprovalPostCertificateAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling pkitaCLMCertificateApprovalPostCertificateAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum PkitaCertificateApiApiKeys {
 }
 
 export class PkitaCertificateApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: PkitaCertificateApiApiKeys, value: string) {
         (this.authentications as any)[PkitaCertificateApiApiKeys[key]].apiKey = value;
     }
     /**
      * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
      * @summary Gets the current status of pkita certificate request workflow.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public pkitaCertificateGetcertificatestatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/certificate/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling pkitaCertificateGetcertificatestatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling pkitaCertificateGetcertificatestatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling pkitaCertificateGetcertificatestatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * Request pkita to generate a certificate.
      * @summary Initiates pkita certificate request.
      * @param clientid client application AAD Id
      * @param version 
      * @param request pkita certificate request.
      * @param {*} [options] Override http request options.
      */
     public pkitaCertificatePostCertificateAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/certificate'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling pkitaCertificatePostCertificateAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling pkitaCertificatePostCertificateAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum PolicyApiApiKeys {
 }
 
 export class PolicyApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: PolicyApiApiKeys, value: string) {
         (this.authentications as any)[PolicyApiApiKeys[key]].apiKey = value;
     }
     /**
      * 
      * @summary Get the policy based upon the policy request
      * @param clientid 
      * @param version 
      * @param commandName 
      * @param audience 
      * @param contentOrigin 
      * @param contentType 
      * @param intent 
      * @param productState 
      * @param {*} [options] Override http request options.
      */
     public policyGetPolicyAsync (clientid: string, version: string, commandName?: string, audience?: string, contentOrigin?: string, contentType?: string, intent?: string, productState?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/policy'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling policyGetPolicyAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling policyGetPolicyAsync.');
         }
 
         if (commandName !== undefined) {
             localVarQueryParameters['commandName'] = ObjectSerializer.serialize(commandName, "string");
         }
 
         if (audience !== undefined) {
             localVarQueryParameters['audience'] = ObjectSerializer.serialize(audience, "string");
         }
 
         if (contentOrigin !== undefined) {
             localVarQueryParameters['contentOrigin'] = ObjectSerializer.serialize(contentOrigin, "string");
         }
 
         if (contentType !== undefined) {
             localVarQueryParameters['contentType'] = ObjectSerializer.serialize(contentType, "string");
         }
 
         if (intent !== undefined) {
             localVarQueryParameters['intent'] = ObjectSerializer.serialize(intent, "string");
         }
 
         if (productState !== undefined) {
             localVarQueryParameters['productState'] = ObjectSerializer.serialize(productState, "string");
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum ProductOnboardingApiApiKeys {
 }
 
 export class ProductOnboardingApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: ProductOnboardingApiApiKeys, value: string) {
         (this.authentications as any)[ProductOnboardingApiApiKeys[key]].apiKey = value;
     }
     /**
      * This request comes from PPP to onboard a new PKPN into SLK V2
      * @summary Initiates pkpn onboarding request
      * @param clientid client application AAD Id
      * @param version 
      * @param request Pkpn Information
      * @param {*} [options] Override http request options.
      */
     public productOnboardingOnboardPkpn (clientid: string, version: string, request?: MSEssGatewayClientContractsSlkRequestSlkRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/productonboarding'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling productOnboardingOnboardPkpn.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling productOnboardingOnboardPkpn.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum ProvisionStorageApiApiKeys {
 }
 
 export class ProvisionStorageApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: ProvisionStorageApiApiKeys, value: string) {
         (this.authentications as any)[ProvisionStorageApiApiKeys[key]].apiKey = value;
     }
     /**
      * it returns a list of blob storage shards so that user could decide which one to choose, either round robin or random partition.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates storage is created successfully
      * @summary Gets results of a storage shards for a given operation id.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public provisionStorageGetstoragestatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsProvisionStorageResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/storage/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling provisionStorageGetstoragestatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling provisionStorageGetstoragestatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling provisionStorageGetstoragestatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsProvisionStorageResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsProvisionStorageResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * Initiates creating storage provisioning request as a workflow with a stepwise long running operation. A stepwise operation is one that takes a long, and often unpredictable, length of time to complete, and doesnt offer state transition modeled in the resource.  \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id  upon successful acceptace of payload and expected to check status of the workflow at later time.
      * @summary Provisions the temporary storage for users to stage their files which will be ingested in ESRP system.   This API will return storage shards with read and write access to the caller for a specified duration.
      * @param clientid client application AAD Id
      * @param version 
      * @param provisionApiRequest Payload for storage provision with details like routing parameters and duration of access needed. check ProvisionStorageRequest type for details
      * @param {*} [options] Override http request options.
      */
     public provisionStoragePostStorageAsync (clientid: string, version: string, provisionApiRequest?: MSEssGatewayClientContractsProvisionStorageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/storage'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling provisionStoragePostStorageAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling provisionStoragePostStorageAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(provisionApiRequest, "MSEssGatewayClientContractsProvisionStorageRequest")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "string");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum ReleaseApiApiKeys {
 }
 
 export class ReleaseApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: ReleaseApiApiKeys, value: string) {
         (this.authentications as any)[ReleaseApiApiKeys[key]].apiKey = value;
     }
     /**
      * 
      * @summary To cancel the release process.
      * @param clientid client application AAD Id
      * @param version 
      * @param requests List of Release Information
      * @param {*} [options] Override http request options.
      */
     public releaseCancelReleaseAsync (clientid: string, version: string, requests?: Array<MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling releaseCancelReleaseAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling releaseCancelReleaseAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'DELETE',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(requests, "Array<MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage>")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * the response from this call contains complete release object and the various activities that are performed as part of the release workflow.                The release details will contain all metadata and also contain list of activities that were performed as part of the release workflow               <br /><b>\"Name\"</b>: Name / type of the activity that was performed.               <br /><b>\"IsComplete\"</b>: Whether the activity was completed or not               The release status will also contain error object which will contain detailed error in case the release processing fails               <br /><b>\"Code\"</b>: Error code indicating cause of failure               <br /><b>\"Message\"</b>: details error description
      * @summary Gets the complete details of a submitted release and it's workflow details.
      * @param operationid Release Id value for the release workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public releaseGetReleaseDetailsByReleaseIdAsync (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release/details/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling releaseGetReleaseDetailsByReleaseIdAsync.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling releaseGetReleaseDetailsByReleaseIdAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling releaseGetReleaseDetailsByReleaseIdAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * 
      * @param operationid 
      * @param clientid 
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public releaseGetReleaseEditStatusByOperationIdAsync (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release/operations/edit/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling releaseGetReleaseEditStatusByOperationIdAsync.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling releaseGetReleaseEditStatusByOperationIdAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling releaseGetReleaseEditStatusByOperationIdAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * 
      * @param operationid 
      * @param clientid 
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public releaseGetreleasestatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsReleaseResponseReleaseResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling releaseGetreleasestatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling releaseGetreleasestatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling releaseGetreleasestatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsReleaseResponseReleaseResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsReleaseResponseReleaseResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * A Release is completed only after the release workflow is completed. Release workflow is decided based on the input payload, tenant and routing information. Post Release operation initiates a stepwise long running operation on server.               \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id               upon successful acceptance of payload and expected to check status of the Release at later time.
      * @summary Initiates Release Processing based on the input payload.
      * @param clientid client application AAD Id
      * @param version 
      * @param requestMessage 
      * @param {*} [options] Override http request options.
      */
     public releasePostRelease2Async (clientid: string, version: string, requestMessage?: MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling releasePostRelease2Async.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling releasePostRelease2Async.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(requestMessage, "MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsOperationResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * 
      * @summary To cancel the release process.
      * @param clientid client application AAD Id
      * @param version 
      * @param operationid 
      * @param request A ReleaseEditRequestMessage
      * @param {*} [options] Override http request options.
      */
     public releaseReleaseEditAsync (clientid: string, version: string, operationid: string, request?: MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsReleaseResponseReleaseEditResponse;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release/operations/edit/{operationid}'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)))
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling releaseReleaseEditAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling releaseReleaseEditAsync.');
         }
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling releaseReleaseEditAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'PUT',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsReleaseResponseReleaseEditResponse;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsReleaseResponseReleaseEditResponse");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * 
      * @summary Approve or reject the release requests.
      * @param clientid client application AAD Id
      * @param version 
      * @param requests List of Release Information
      * @param {*} [options] Override http request options.
      */
     public releaseSignOffReleaseAsync (clientid: string, version: string, requests?: Array<MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MSEssGatewayClientContractsOperationResponse>;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling releaseSignOffReleaseAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling releaseSignOffReleaseAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'PUT',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(requests, "Array<MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage>")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: Array<MSEssGatewayClientContractsOperationResponse>;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "Array<MSEssGatewayClientContractsOperationResponse>");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum ScanApiApiKeys {
 }
 
 export class ScanApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: ScanApiApiKeys, value: string) {
         (this.authentications as any)[ScanApiApiKeys[key]].apiKey = value;
     }
     /**
      * When malware scanning operation is finished, the response from this call contains the status or result of the operation.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and determined clean.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
      * @summary Gets the current status of malware scanning workflow.
      * @param operationid OperationId value for a malware scanning workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public scanGetscanstatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsScanResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/scan/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling scanGetscanstatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling scanGetscanstatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling scanGetscanstatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsScanResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsScanResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This operation initiates a stepwise long running operation on server.             \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id             upon successful acceptace of payload and expected to check status of the workflow at later time.
      * @summary Initiates malware scanning of a given input files.
      * @param clientid client application AAD Id
      * @param version 
      * @param requests list of files to malware scan.
      * @param {*} [options] Override http request options.
      */
     public scanPostScan2Async (clientid: string, version: string, requests?: Array<MSEssGatewayClientContractsScanRequestMessage>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MSEssGatewayClientContractsOperationResponse>;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/scan'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling scanPostScan2Async.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling scanPostScan2Async.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(requests, "Array<MSEssGatewayClientContractsScanRequestMessage>")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: Array<MSEssGatewayClientContractsOperationResponse>;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "Array<MSEssGatewayClientContractsOperationResponse>");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum ScanDetectionApiApiApiKeys {
 }
 
 export class ScanDetectionApiApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: ScanDetectionApiApiApiKeys, value: string) {
         (this.authentications as any)[ScanDetectionApiApiApiKeys[key]].apiKey = value;
     }
     /**
      * 
      * @param operationId 
      * @param clientId 
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public scanDetectionApiGetdetectionresults (operationId: string, clientId: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientId}/workflows/scan/detection/operations/{operationId}'
             .replace('{' + 'operationId' + '}', encodeURIComponent(String(operationId)))
             .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationId' is not null or undefined
         if (operationId === null || operationId === undefined) {
             throw new Error('Required parameter operationId was null or undefined when calling scanDetectionApiGetdetectionresults.');
         }
 
         // verify required parameter 'clientId' is not null or undefined
         if (clientId === null || clientId === undefined) {
             throw new Error('Required parameter clientId was null or undefined when calling scanDetectionApiGetdetectionresults.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling scanDetectionApiGetdetectionresults.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum SessionApiApiKeys {
 }
 
 export class SessionApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: SessionApiApiKeys, value: string) {
         (this.authentications as any)[SessionApiApiKeys[key]].apiKey = value;
     }
     /**
      * 
      * @summary Create a session with policy, config, digesign mapping and storage containers for the client
      * @param clientid 
      * @param version 
      * @param request 
      * @param {*} [options] Override http request options.
      */
     public sessionCreateSessionAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsSessionRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: MSEssGatewayClientContractsSessionResultMessage ;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/session'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling sessionCreateSessionAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling sessionCreateSessionAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSessionRequestMessage")
         };

         //console.log(localVarRequestOptions.body);
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: MSEssGatewayClientContractsSessionResultMessage ;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * it returns a policy, config, digestsign mapping data and list of blob storage shards so that user could decide which one to choose, either round robin or random partition.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates storage is created successfully
      * @summary Gets results of a session for a given operation id.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public sessionGetSessionByOperationIdAsync (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsSessionResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/session/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling sessionGetSessionByOperationIdAsync.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling sessionGetSessionByOperationIdAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling sessionGetSessionByOperationIdAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsSessionResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsSessionResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum SignApiApiKeys {
 }
 
 export class SignApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: SignApiApiKeys, value: string) {
         (this.authentications as any)[SignApiApiKeys[key]].apiKey = value;
     }
     /**
      * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
      * @summary Gets the current status of sign workflow.
      * @param operationid OperationId value for a signing workflow.
      * @param clientid Client AAD Application Id
      * @param version 
      * @param {*} [options] Override http request options.
      */
     public signGetsignstatus (operationid: string, clientid: string, version: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsSignResultMessage;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/sign/operations/{operationid}'
             .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'operationid' is not null or undefined
         if (operationid === null || operationid === undefined) {
             throw new Error('Required parameter operationid was null or undefined when calling signGetsignstatus.');
         }
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling signGetsignstatus.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling signGetsignstatus.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: MSEssGatewayClientContractsSignResultMessage;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsSignResultMessage");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * A signed file is returned only after scanning is passed. This operation initiates a stepwise long running operation on server.              \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id              upon successful acceptace of payload and expected to check status of the workflow at later time.
      * @summary Initiates code signing and malware scanning of a given input files.
      * @param clientid client application AAD Id
      * @param version 
      * @param requests list of files to codesign.
      * @param {*} [options] Override http request options.
      */
     public signPostSign2Async (clientid: string, version: string, requests?: Array<MSEssGatewayClientContractsSignRequestMessage>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MSEssGatewayClientContractsOperationResponse>;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/sign'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling signPostSign2Async.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling signPostSign2Async.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(requests, "Array<MSEssGatewayClientContractsSignRequestMessage>")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: Array<MSEssGatewayClientContractsOperationResponse>;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "Array<MSEssGatewayClientContractsOperationResponse>");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum TenantOnboardingApiApiKeys {
 }
 
 export class TenantOnboardingApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: TenantOnboardingApiApiKeys, value: string) {
         (this.authentications as any)[TenantOnboardingApiApiKeys[key]].apiKey = value;
     }
     /**
      * This requests is sent by Slk Portal.
      * @summary Gets all the onboarded Tenants of SLK
      * @param clientid client application AAD Id
      * @param version 
      * @param tenantCode 
      * @param typeOfTenant 
      * @param {*} [options] Override http request options.
      */
     public tenantOnboardingGetAllTenants (clientid: string, version: string, tenantCode?: string, typeOfTenant?: 'SLK' | 'RSM' | 'JIT', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/tenantonboarding/gettenants'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling tenantOnboardingGetAllTenants.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling tenantOnboardingGetAllTenants.');
         }
 
         if (tenantCode !== undefined) {
             localVarQueryParameters['TenantCode'] = ObjectSerializer.serialize(tenantCode, "string");
         }
 
         if (typeOfTenant !== undefined) {
             localVarQueryParameters['TypeOfTenant'] = ObjectSerializer.serialize(typeOfTenant, "'SLK' | 'RSM' | 'JIT'");
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'GET',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This requests is sent by Slk Portal. It sends tenant onboardin request to slk api to persist the onboarding request.
      * @summary Creates Tenant Onboarding request for Slk
      * @param clientid client application AAD Id
      * @param version 
      * @param request Request Information
      * @param {*} [options] Override http request options.
      */
     public tenantOnboardingRequestTenantOnboardingAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsSlkRequestSlkRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/tenantonboarding'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling tenantOnboardingRequestTenantOnboardingAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling tenantOnboardingRequestTenantOnboardingAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
     /**
      * This requests is sent by Slk Portal. It sends update request to update the tenant onboarded to SLK
      * @summary Updates Tenant details for SLK tenant
      * @param clientid client application AAD Id
      * @param version 
      * @param request Request Information
      * @param {*} [options] Override http request options.
      */
     public tenantOnboardingRequestTenantOnboardingUpdateAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsSlkRequestSlkRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/tenantonboarding/updatetenant'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling tenantOnboardingRequestTenantOnboardingUpdateAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling tenantOnboardingRequestTenantOnboardingUpdateAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'PATCH',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 export enum VaultCallbackApiApiKeys {
 }
 
 export class VaultCallbackApi {
     protected _basePath = defaultBasePath;
     protected defaultHeaders : any = {};
     protected _useQuerystring : boolean = false;
 
     protected authentications = {
         'default': <Authentication>new VoidAuth(),
     }
 
     constructor(basePath?: string);
     constructor(basePathOrUsername: string, password?: string, basePath?: string) {
         if (password) {
             if (basePath) {
                 this.basePath = basePath;
             }
         } else {
             if (basePathOrUsername) {
                 this.basePath = basePathOrUsername
             }
         }
     }
 
     set useQuerystring(value: boolean) {
         this._useQuerystring = value;
     }
 
     set basePath(basePath: string) {
         this._basePath = basePath;
     }
 
     get basePath() {
         return this._basePath;
     }
 
     public setDefaultAuthentication(auth: Authentication) {
     this.authentications.default = auth;
     }
 
     public setApiKey(key: VaultCallbackApiApiKeys, value: string) {
         (this.authentications as any)[VaultCallbackApiApiKeys[key]].apiKey = value;
     }
     /**
      * 
      * @summary Callback notification for a file in a release.
      * @param clientid client application AAD Id
      * @param version 
      * @param request File callback information
      * @param {*} [options] Override http request options.
      */
     public vaultCallbackPostVaultCallbackAsync (clientid: string, version: string, request?: MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
         const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/vaultcallback'
             .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
             .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
         let localVarQueryParameters: any = {};
         let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
         let localVarFormParams: any = {};
 
         // verify required parameter 'clientid' is not null or undefined
         if (clientid === null || clientid === undefined) {
             throw new Error('Required parameter clientid was null or undefined when calling vaultCallbackPostVaultCallbackAsync.');
         }
 
         // verify required parameter 'version' is not null or undefined
         if (version === null || version === undefined) {
             throw new Error('Required parameter version was null or undefined when calling vaultCallbackPostVaultCallbackAsync.');
         }
 
         (<any>Object).assign(localVarHeaderParams, options.headers);
 
         let localVarUseFormData = false;
 
         let localVarRequestOptions: localVarRequest.Options = {
             method: 'POST',
             qs: localVarQueryParameters,
             headers: localVarHeaderParams,
             uri: localVarPath,
             useQuerystring: this._useQuerystring,
             json: true,
             body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage")
         };
 
         this.authentications.default.applyToRequest(localVarRequestOptions);
 
         if (Object.keys(localVarFormParams).length) {
             if (localVarUseFormData) {
                 (<any>localVarRequestOptions).formData = localVarFormParams;
             } else {
                 localVarRequestOptions.form = localVarFormParams;
             }
         }
         return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
             localVarRequest(localVarRequestOptions, (error, response, body) => {
                 if (error) {
                     reject(error);
                 } else {
                     body = ObjectSerializer.deserialize(body, "string");
                     if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                         resolve({ response: response, body: body });
                     } else {
                         reject({ response: response, body: body });
                     }
                 }
             });
         });
     }
 }
 