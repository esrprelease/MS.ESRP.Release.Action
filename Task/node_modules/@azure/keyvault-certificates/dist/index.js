'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var logger$1 = require('@azure/logger');
require('@azure/core-paging');
var coreLro = require('@azure/core-lro');
var url = require('url');
var coreTracing = require('@azure/core-tracing');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreHttp__namespace = /*#__PURE__*/_interopNamespace(coreHttp);
var url__namespace = /*#__PURE__*/_interopNamespace(url);

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("keyvault-certificates");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The latest supported KeyVault service API version
 */
const LATEST_API_VERSION = "7.3";
/**
 * Well known issuers for choosing a default
 */
exports.WellKnownIssuer = void 0;
(function (WellKnownIssuerNames) {
    /**
     * For self signed certificates
     */
    WellKnownIssuerNames["Self"] = "Self";
    /**
     * For certificates whose issuer will be defined later
     */
    WellKnownIssuerNames["Unknown"] = "Unknown";
})(exports.WellKnownIssuer || (exports.WellKnownIssuer = {}));
/**
 * The DefaultCertificatePolicy exports values that
 * are useful as default parameters to methods that
 * modify the certificate's policy.
 */
const DefaultCertificatePolicy = {
    issuerName: "Self",
    subject: "cn=MyCert",
};
/** Known values of {@link CertificateKeyCurveName} that the service accepts. */
exports.KnownCertificateKeyCurveNames = void 0;
(function (KnownCertificateKeyCurveNames) {
    /**
     * P-256 Key Curve.
     */
    KnownCertificateKeyCurveNames["P256"] = "P-256";
    /**
     * P-384 Key Curve.
     */
    KnownCertificateKeyCurveNames["P384"] = "P-384";
    /**
     * P-521 Key Curve.
     */
    KnownCertificateKeyCurveNames["P521"] = "P-521";
    /**
     * P-256K Key Curve.
     */
    KnownCertificateKeyCurveNames["P256K"] = "P-256K";
})(exports.KnownCertificateKeyCurveNames || (exports.KnownCertificateKeyCurveNames = {}));
/** Known values of {@link CertificateKeyType} that the service accepts. */
exports.KnownCertificateKeyTypes = void 0;
(function (KnownCertificateKeyTypes) {
    /**
     * EC Key Type.
     */
    KnownCertificateKeyTypes["EC"] = "EC";
    /**
     * EC-HSM Key Type.
     */
    KnownCertificateKeyTypes["ECHSM"] = "EC-HSM";
    /**
     * RSA Key Type.
     */
    KnownCertificateKeyTypes["RSA"] = "RSA";
    /**
     * RSA-HSM Key Type.
     */
    KnownCertificateKeyTypes["RSAHSM"] = "RSA-HSM";
    /**
     * oct Key Type
     */
    KnownCertificateKeyTypes["Oct"] = "oct";
    /**
     * oct-HSM Key Type
     */
    KnownCertificateKeyTypes["OctHSM"] = "oct-HSM";
})(exports.KnownCertificateKeyTypes || (exports.KnownCertificateKeyTypes = {}));
/** Known values of {@link KeyUsageType} that the service accepts. */
exports.KnownKeyUsageTypes = void 0;
(function (KnownKeyUsageTypes) {
    /**
     * DigitalSignature Usage Type.
     */
    KnownKeyUsageTypes["DigitalSignature"] = "digitalSignature";
    /**
     * NonRepudiation Usage Type.
     */
    KnownKeyUsageTypes["NonRepudiation"] = "nonRepudiation";
    /**
     * KeyEncipherment Usage Type.
     */
    KnownKeyUsageTypes["KeyEncipherment"] = "keyEncipherment";
    /**
     * DataEncipherment Usage Type.
     */
    KnownKeyUsageTypes["DataEncipherment"] = "dataEncipherment";
    /**
     * KeyAgreement Usage Type.
     */
    KnownKeyUsageTypes["KeyAgreement"] = "keyAgreement";
    /**
     * KeyCertSign Usage Type.
     */
    KnownKeyUsageTypes["KeyCertSign"] = "keyCertSign";
    /**
     * CRLSign Usage Type.
     */
    KnownKeyUsageTypes["CRLSign"] = "cRLSign";
    /**
     * EncipherOnly Usage Type.
     */
    KnownKeyUsageTypes["EncipherOnly"] = "encipherOnly";
    /**
     * DecipherOnly Usage Type.
     */
    KnownKeyUsageTypes["DecipherOnly"] = "decipherOnly";
})(exports.KnownKeyUsageTypes || (exports.KnownKeyUsageTypes = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ApiVersion73} that the service accepts. */
var KnownApiVersion73;
(function (KnownApiVersion73) {
    /** Api Version '7.3' */
    KnownApiVersion73["Seven3"] = "7.3";
})(KnownApiVersion73 || (KnownApiVersion73 = {}));
/** Known values of {@link DeletionRecoveryLevel} that the service accepts. */
exports.KnownDeletionRecoveryLevels = void 0;
(function (KnownDeletionRecoveryLevel) {
    /** Denotes a vault state in which deletion is an irreversible operation, without the possibility for recovery. This level corresponds to no protection being available against a Delete operation; the data is irretrievably lost upon accepting a Delete operation at the entity level or higher (vault, resource group, subscription etc.) */
    KnownDeletionRecoveryLevel["Purgeable"] = "Purgeable";
    /** Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval (90 days), unless a Purge operation is requested, or the subscription is cancelled. System wil permanently delete it after 90 days, if not recovered */
    KnownDeletionRecoveryLevel["RecoverablePurgeable"] = "Recoverable+Purgeable";
    /** Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge). This level guarantees the recoverability of the deleted entity during the retention interval(90 days) and while the subscription is still available. System wil permanently delete it after 90 days, if not recovered */
    KnownDeletionRecoveryLevel["Recoverable"] = "Recoverable";
    /** Denotes a vault and subscription state in which deletion is recoverable within retention interval (90 days), immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself  cannot be permanently canceled. System wil permanently delete it after 90 days, if not recovered */
    KnownDeletionRecoveryLevel["RecoverableProtectedSubscription"] = "Recoverable+ProtectedSubscription";
    /** Denotes a vault state in which deletion is recoverable, and which also permits immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90). This level guarantees the recoverability of the deleted entity during the retention interval, unless a Purge operation is requested, or the subscription is cancelled. */
    KnownDeletionRecoveryLevel["CustomizedRecoverablePurgeable"] = "CustomizedRecoverable+Purgeable";
    /** Denotes a vault state in which deletion is recoverable without the possibility for immediate and permanent deletion (i.e. purge when 7<= SoftDeleteRetentionInDays < 90).This level guarantees the recoverability of the deleted entity during the retention interval and while the subscription is still available. */
    KnownDeletionRecoveryLevel["CustomizedRecoverable"] = "CustomizedRecoverable";
    /** Denotes a vault and subscription state in which deletion is recoverable, immediate and permanent deletion (i.e. purge) is not permitted, and in which the subscription itself cannot be permanently canceled when 7<= SoftDeleteRetentionInDays < 90. This level guarantees the recoverability of the deleted entity during the retention interval, and also reflects the fact that the subscription itself cannot be cancelled. */
    KnownDeletionRecoveryLevel["CustomizedRecoverableProtectedSubscription"] = "CustomizedRecoverable+ProtectedSubscription";
})(exports.KnownDeletionRecoveryLevels || (exports.KnownDeletionRecoveryLevels = {}));
/** Known values of {@link JsonWebKeyType} that the service accepts. */
var KnownJsonWebKeyType;
(function (KnownJsonWebKeyType) {
    KnownJsonWebKeyType["EC"] = "EC";
    KnownJsonWebKeyType["ECHSM"] = "EC-HSM";
    KnownJsonWebKeyType["RSA"] = "RSA";
    KnownJsonWebKeyType["RSAHSM"] = "RSA-HSM";
    KnownJsonWebKeyType["Oct"] = "oct";
    KnownJsonWebKeyType["OctHSM"] = "oct-HSM";
})(KnownJsonWebKeyType || (KnownJsonWebKeyType = {}));
/** Known values of {@link JsonWebKeyCurveName} that the service accepts. */
var KnownJsonWebKeyCurveName;
(function (KnownJsonWebKeyCurveName) {
    KnownJsonWebKeyCurveName["P256"] = "P-256";
    KnownJsonWebKeyCurveName["P384"] = "P-384";
    KnownJsonWebKeyCurveName["P521"] = "P-521";
    KnownJsonWebKeyCurveName["P256K"] = "P-256K";
})(KnownJsonWebKeyCurveName || (KnownJsonWebKeyCurveName = {}));
/** Known values of {@link KeyUsageType} that the service accepts. */
var KnownKeyUsageType;
(function (KnownKeyUsageType) {
    KnownKeyUsageType["DigitalSignature"] = "digitalSignature";
    KnownKeyUsageType["NonRepudiation"] = "nonRepudiation";
    KnownKeyUsageType["KeyEncipherment"] = "keyEncipherment";
    KnownKeyUsageType["DataEncipherment"] = "dataEncipherment";
    KnownKeyUsageType["KeyAgreement"] = "keyAgreement";
    KnownKeyUsageType["KeyCertSign"] = "keyCertSign";
    KnownKeyUsageType["CRLSign"] = "cRLSign";
    KnownKeyUsageType["EncipherOnly"] = "encipherOnly";
    KnownKeyUsageType["DecipherOnly"] = "decipherOnly";
})(KnownKeyUsageType || (KnownKeyUsageType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const CertificateListResult = {
    type: {
        name: "Composite",
        className: "CertificateListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateItem = {
    type: {
        name: "Composite",
        className: "CertificateItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            x509Thumbprint: {
                serializedName: "x5t",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const Attributes = {
    type: {
        name: "Composite",
        className: "Attributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "UnixTime"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "UnixTime"
                }
            },
            created: {
                serializedName: "created",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                serializedName: "updated",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
const KeyVaultError = {
    type: {
        name: "Composite",
        className: "KeyVaultError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const CertificateBundle = {
    type: {
        name: "Composite",
        className: "CertificateBundle",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            kid: {
                serializedName: "kid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sid: {
                serializedName: "sid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            x509Thumbprint: {
                serializedName: "x5t",
                readOnly: true,
                type: {
                    name: "Base64Url"
                }
            },
            policy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            cer: {
                serializedName: "cer",
                type: {
                    name: "ByteArray"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CertificatePolicy = {
    type: {
        name: "Composite",
        className: "CertificatePolicy",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            keyProperties: {
                serializedName: "key_props",
                type: {
                    name: "Composite",
                    className: "KeyProperties"
                }
            },
            secretProperties: {
                serializedName: "secret_props",
                type: {
                    name: "Composite",
                    className: "SecretProperties"
                }
            },
            x509CertificateProperties: {
                serializedName: "x509_props",
                type: {
                    name: "Composite",
                    className: "X509CertificateProperties"
                }
            },
            lifetimeActions: {
                serializedName: "lifetime_actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LifetimeAction"
                        }
                    }
                }
            },
            issuerParameters: {
                serializedName: "issuer",
                type: {
                    name: "Composite",
                    className: "IssuerParameters"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            }
        }
    }
};
const KeyProperties = {
    type: {
        name: "Composite",
        className: "KeyProperties",
        modelProperties: {
            exportable: {
                serializedName: "exportable",
                type: {
                    name: "Boolean"
                }
            },
            keyType: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keySize: {
                serializedName: "key_size",
                type: {
                    name: "Number"
                }
            },
            reuseKey: {
                serializedName: "reuse_key",
                type: {
                    name: "Boolean"
                }
            },
            curve: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecretProperties = {
    type: {
        name: "Composite",
        className: "SecretProperties",
        modelProperties: {
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const X509CertificateProperties = {
    type: {
        name: "Composite",
        className: "X509CertificateProperties",
        modelProperties: {
            subject: {
                serializedName: "subject",
                type: {
                    name: "String"
                }
            },
            ekus: {
                serializedName: "ekus",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            subjectAlternativeNames: {
                serializedName: "sans",
                type: {
                    name: "Composite",
                    className: "SubjectAlternativeNames"
                }
            },
            keyUsage: {
                serializedName: "key_usage",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            validityInMonths: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "validity_months",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SubjectAlternativeNames = {
    type: {
        name: "Composite",
        className: "SubjectAlternativeNames",
        modelProperties: {
            emails: {
                serializedName: "emails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dnsNames: {
                serializedName: "dns_names",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            upns: {
                serializedName: "upns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const LifetimeAction = {
    type: {
        name: "Composite",
        className: "LifetimeAction",
        modelProperties: {
            trigger: {
                serializedName: "trigger",
                type: {
                    name: "Composite",
                    className: "Trigger"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "Action"
                }
            }
        }
    }
};
const Trigger = {
    type: {
        name: "Composite",
        className: "Trigger",
        modelProperties: {
            lifetimePercentage: {
                constraints: {
                    InclusiveMaximum: 99,
                    InclusiveMinimum: 1
                },
                serializedName: "lifetime_percentage",
                type: {
                    name: "Number"
                }
            },
            daysBeforeExpiry: {
                serializedName: "days_before_expiry",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Action = {
    type: {
        name: "Composite",
        className: "Action",
        modelProperties: {
            actionType: {
                serializedName: "action_type",
                type: {
                    name: "Enum",
                    allowedValues: ["EmailContacts", "AutoRenew"]
                }
            }
        }
    }
};
const IssuerParameters = {
    type: {
        name: "Composite",
        className: "IssuerParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            certificateType: {
                serializedName: "cty",
                type: {
                    name: "String"
                }
            },
            certificateTransparency: {
                serializedName: "cert_transparency",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const Contacts = {
    type: {
        name: "Composite",
        className: "Contacts",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            contactList: {
                serializedName: "contacts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Contact"
                        }
                    }
                }
            }
        }
    }
};
const Contact = {
    type: {
        name: "Composite",
        className: "Contact",
        modelProperties: {
            emailAddress: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateIssuerListResult = {
    type: {
        name: "Composite",
        className: "CertificateIssuerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateIssuerItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateIssuerItem = {
    type: {
        name: "Composite",
        className: "CertificateIssuerItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateIssuerSetParameters = {
    type: {
        name: "Composite",
        className: "CertificateIssuerSetParameters",
        modelProperties: {
            provider: {
                serializedName: "provider",
                required: true,
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
const IssuerCredentials = {
    type: {
        name: "Composite",
        className: "IssuerCredentials",
        modelProperties: {
            accountId: {
                serializedName: "account_id",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "pwd",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OrganizationDetails = {
    type: {
        name: "Composite",
        className: "OrganizationDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            adminDetails: {
                serializedName: "admin_details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdministratorDetails"
                        }
                    }
                }
            }
        }
    }
};
const AdministratorDetails = {
    type: {
        name: "Composite",
        className: "AdministratorDetails",
        modelProperties: {
            firstName: {
                serializedName: "first_name",
                type: {
                    name: "String"
                }
            },
            lastName: {
                serializedName: "last_name",
                type: {
                    name: "String"
                }
            },
            emailAddress: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IssuerAttributes = {
    type: {
        name: "Composite",
        className: "IssuerAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                serializedName: "created",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                serializedName: "updated",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
const IssuerBundle = {
    type: {
        name: "Composite",
        className: "IssuerBundle",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
const CertificateIssuerUpdateParameters = {
    type: {
        name: "Composite",
        className: "CertificateIssuerUpdateParameters",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "IssuerCredentials"
                }
            },
            organizationDetails: {
                serializedName: "org_details",
                type: {
                    name: "Composite",
                    className: "OrganizationDetails"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "IssuerAttributes"
                }
            }
        }
    }
};
const CertificateCreateParameters = {
    type: {
        name: "Composite",
        className: "CertificateCreateParameters",
        modelProperties: {
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CertificateOperation = {
    type: {
        name: "Composite",
        className: "CertificateOperation",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            issuerParameters: {
                serializedName: "issuer",
                type: {
                    name: "Composite",
                    className: "IssuerParameters"
                }
            },
            csr: {
                serializedName: "csr",
                type: {
                    name: "ByteArray"
                }
            },
            cancellationRequested: {
                serializedName: "cancellation_requested",
                type: {
                    name: "Boolean"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            statusDetails: {
                serializedName: "status_details",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "request_id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateImportParameters = {
    type: {
        name: "Composite",
        className: "CertificateImportParameters",
        modelProperties: {
            base64EncodedCertificate: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "pwd",
                type: {
                    name: "String"
                }
            },
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CertificateUpdateParameters = {
    type: {
        name: "Composite",
        className: "CertificateUpdateParameters",
        modelProperties: {
            certificatePolicy: {
                serializedName: "policy",
                type: {
                    name: "Composite",
                    className: "CertificatePolicy"
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CertificateOperationUpdateParameter = {
    type: {
        name: "Composite",
        className: "CertificateOperationUpdateParameter",
        modelProperties: {
            cancellationRequested: {
                serializedName: "cancellation_requested",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CertificateMergeParameters = {
    type: {
        name: "Composite",
        className: "CertificateMergeParameters",
        modelProperties: {
            x509Certificates: {
                serializedName: "x5c",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "ByteArray"
                        }
                    }
                }
            },
            certificateAttributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "CertificateAttributes"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const BackupCertificateResult = {
    type: {
        name: "Composite",
        className: "BackupCertificateResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const CertificateRestoreParameters = {
    type: {
        name: "Composite",
        className: "CertificateRestoreParameters",
        modelProperties: {
            certificateBundleBackup: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const DeletedCertificateListResult = {
    type: {
        name: "Composite",
        className: "DeletedCertificateListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedCertificateItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PendingCertificateSigningRequestResult = {
    type: {
        name: "Composite",
        className: "PendingCertificateSigningRequestResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedCertificateItem = {
    type: {
        name: "Composite",
        className: "DeletedCertificateItem",
        modelProperties: Object.assign(Object.assign({}, CertificateItem.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                serializedName: "scheduledPurgeDate",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                serializedName: "deletedDate",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            } })
    }
};
const CertificateAttributes = {
    type: {
        name: "Composite",
        className: "CertificateAttributes",
        modelProperties: Object.assign(Object.assign({}, Attributes.type.modelProperties), { recoverableDays: {
                serializedName: "recoverableDays",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, recoveryLevel: {
                serializedName: "recoveryLevel",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DeletedCertificateBundle = {
    type: {
        name: "Composite",
        className: "DeletedCertificateBundle",
        modelProperties: Object.assign(Object.assign({}, CertificateBundle.type.modelProperties), { recoveryId: {
                serializedName: "recoveryId",
                type: {
                    name: "String"
                }
            }, scheduledPurgeDate: {
                serializedName: "scheduledPurgeDate",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            }, deletedDate: {
                serializedName: "deletedDate",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CertificateListResult: CertificateListResult,
    CertificateItem: CertificateItem,
    Attributes: Attributes,
    KeyVaultError: KeyVaultError,
    ErrorModel: ErrorModel,
    CertificateBundle: CertificateBundle,
    CertificatePolicy: CertificatePolicy,
    KeyProperties: KeyProperties,
    SecretProperties: SecretProperties,
    X509CertificateProperties: X509CertificateProperties,
    SubjectAlternativeNames: SubjectAlternativeNames,
    LifetimeAction: LifetimeAction,
    Trigger: Trigger,
    Action: Action,
    IssuerParameters: IssuerParameters,
    Contacts: Contacts,
    Contact: Contact,
    CertificateIssuerListResult: CertificateIssuerListResult,
    CertificateIssuerItem: CertificateIssuerItem,
    CertificateIssuerSetParameters: CertificateIssuerSetParameters,
    IssuerCredentials: IssuerCredentials,
    OrganizationDetails: OrganizationDetails,
    AdministratorDetails: AdministratorDetails,
    IssuerAttributes: IssuerAttributes,
    IssuerBundle: IssuerBundle,
    CertificateIssuerUpdateParameters: CertificateIssuerUpdateParameters,
    CertificateCreateParameters: CertificateCreateParameters,
    CertificateOperation: CertificateOperation,
    CertificateImportParameters: CertificateImportParameters,
    CertificateUpdateParameters: CertificateUpdateParameters,
    CertificateOperationUpdateParameter: CertificateOperationUpdateParameter,
    CertificateMergeParameters: CertificateMergeParameters,
    BackupCertificateResult: BackupCertificateResult,
    CertificateRestoreParameters: CertificateRestoreParameters,
    DeletedCertificateListResult: DeletedCertificateListResult,
    PendingCertificateSigningRequestResult: PendingCertificateSigningRequestResult,
    DeletedCertificateItem: DeletedCertificateItem,
    CertificateAttributes: CertificateAttributes,
    DeletedCertificateBundle: DeletedCertificateBundle
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const vaultBaseUrl = {
    parameterPath: "vaultBaseUrl",
    mapper: {
        serializedName: "vaultBaseUrl",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const maxresults = {
    parameterPath: ["options", "maxresults"],
    mapper: {
        constraints: {
            InclusiveMaximum: 25,
            InclusiveMinimum: 1
        },
        serializedName: "maxresults",
        type: {
            name: "Number"
        }
    }
};
const includePending = {
    parameterPath: ["options", "includePending"],
    mapper: {
        serializedName: "includePending",
        type: {
            name: "Boolean"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const certificateName = {
    parameterPath: "certificateName",
    mapper: {
        serializedName: "certificate-name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const contacts = {
    parameterPath: "contacts",
    mapper: Contacts
};
const issuerName = {
    parameterPath: "issuerName",
    mapper: {
        serializedName: "issuer-name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const certificateName1 = {
    parameterPath: "certificateName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[0-9a-zA-Z-]+$")
        },
        serializedName: "certificate-name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const certificatePolicy2 = {
    parameterPath: "certificatePolicy",
    mapper: CertificatePolicy
};
const certificateVersion = {
    parameterPath: "certificateVersion",
    mapper: {
        serializedName: "certificate-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "@azure/keyvault-certificates";
const packageVersion = "4.4.0";
/** @internal */
class KeyVaultClientContext extends coreHttp__namespace.ServiceClient {
    /**
     * Initializes a new instance of the KeyVaultClientContext class.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(apiVersion, options) {
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaultUserAgent = `azsdk-js-${packageName.replace(/@.*\//, "")}/${packageVersion} ${coreHttp__namespace.getDefaultUserAgentValue()}`;
        super(undefined, Object.assign(Object.assign({}, options), { userAgent: options.userAgent
                ? `${options.userAgent} ${defaultUserAgent}`
                : `${defaultUserAgent}` }));
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{vaultBaseUrl}";
        // Parameter assignments
        this.apiVersion = apiVersion;
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class KeyVaultClient extends KeyVaultClientContext {
    /**
     * Initializes a new instance of the KeyVaultClient class.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(apiVersion, options) {
        super(apiVersion, options);
    }
    /**
     * The GetCertificates operation returns the set of certificates resources in the specified key vault.
     * This operation requires the certificates/list permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param options The options parameters.
     */
    getCertificates(vaultBaseUrl, options) {
        const operationArguments = {
            vaultBaseUrl,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificatesOperationSpec);
    }
    /**
     * Deletes all versions of a certificate object along with its associated policy. Delete certificate
     * cannot be used to remove individual versions of a certificate object. This operation requires the
     * certificates/delete permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param options The options parameters.
     */
    deleteCertificate(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, deleteCertificateOperationSpec);
    }
    /**
     * Sets the certificate contacts for the specified key vault. This operation requires the
     * certificates/managecontacts permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param contacts The contacts for the key vault certificate.
     * @param options The options parameters.
     */
    setCertificateContacts(vaultBaseUrl, contacts, options) {
        const operationArguments = {
            vaultBaseUrl,
            contacts,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, setCertificateContactsOperationSpec);
    }
    /**
     * The GetCertificateContacts operation returns the set of certificate contact resources in the
     * specified key vault. This operation requires the certificates/managecontacts permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param options The options parameters.
     */
    getCertificateContacts(vaultBaseUrl, options) {
        const operationArguments = {
            vaultBaseUrl,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificateContactsOperationSpec);
    }
    /**
     * Deletes the certificate contacts for a specified key vault certificate. This operation requires the
     * certificates/managecontacts permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param options The options parameters.
     */
    deleteCertificateContacts(vaultBaseUrl, options) {
        const operationArguments = {
            vaultBaseUrl,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, deleteCertificateContactsOperationSpec);
    }
    /**
     * The GetCertificateIssuers operation returns the set of certificate issuer resources in the specified
     * key vault. This operation requires the certificates/manageissuers/getissuers permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param options The options parameters.
     */
    getCertificateIssuers(vaultBaseUrl, options) {
        const operationArguments = {
            vaultBaseUrl,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificateIssuersOperationSpec);
    }
    /**
     * The SetCertificateIssuer operation adds or updates the specified certificate issuer. This operation
     * requires the certificates/setissuers permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param issuerName The name of the issuer.
     * @param provider The issuer provider.
     * @param options The options parameters.
     */
    setCertificateIssuer(vaultBaseUrl, issuerName, provider, options) {
        const operationArguments = {
            vaultBaseUrl,
            issuerName,
            provider,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, setCertificateIssuerOperationSpec);
    }
    /**
     * The UpdateCertificateIssuer operation performs an update on the specified certificate issuer entity.
     * This operation requires the certificates/setissuers permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param issuerName The name of the issuer.
     * @param options The options parameters.
     */
    updateCertificateIssuer(vaultBaseUrl, issuerName, options) {
        const operationArguments = {
            vaultBaseUrl,
            issuerName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, updateCertificateIssuerOperationSpec);
    }
    /**
     * The GetCertificateIssuer operation returns the specified certificate issuer resources in the
     * specified key vault. This operation requires the certificates/manageissuers/getissuers permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param issuerName The name of the issuer.
     * @param options The options parameters.
     */
    getCertificateIssuer(vaultBaseUrl, issuerName, options) {
        const operationArguments = {
            vaultBaseUrl,
            issuerName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificateIssuerOperationSpec);
    }
    /**
     * The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from the
     * vault. This operation requires the certificates/manageissuers/deleteissuers permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param issuerName The name of the issuer.
     * @param options The options parameters.
     */
    deleteCertificateIssuer(vaultBaseUrl, issuerName, options) {
        const operationArguments = {
            vaultBaseUrl,
            issuerName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, deleteCertificateIssuerOperationSpec);
    }
    /**
     * If this is the first version, the certificate resource is created. This operation requires the
     * certificates/create permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param options The options parameters.
     */
    createCertificate(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, createCertificateOperationSpec);
    }
    /**
     * Imports an existing valid certificate, containing a private key, into Azure Key Vault. This
     * operation requires the certificates/import permission. The certificate to be imported can be in
     * either PFX or PEM format. If the certificate is in PEM format the PEM file must contain the key as
     * well as x509 certificates. Key Vault will only accept a key in PKCS#8 format.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param base64EncodedCertificate Base64 encoded representation of the certificate object to import.
     *                                 This certificate needs to contain the private key.
     * @param options The options parameters.
     */
    importCertificate(vaultBaseUrl, certificateName, base64EncodedCertificate, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            base64EncodedCertificate,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, importCertificateOperationSpec);
    }
    /**
     * The GetCertificateVersions operation returns the versions of a certificate in the specified key
     * vault. This operation requires the certificates/list permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param options The options parameters.
     */
    getCertificateVersions(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificateVersionsOperationSpec);
    }
    /**
     * The GetCertificatePolicy operation returns the specified certificate policy resources in the
     * specified key vault. This operation requires the certificates/get permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate in a given key vault.
     * @param options The options parameters.
     */
    getCertificatePolicy(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificatePolicyOperationSpec);
    }
    /**
     * Set specified members in the certificate policy. Leave others as null. This operation requires the
     * certificates/update permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate in the given vault.
     * @param certificatePolicy The policy for the certificate.
     * @param options The options parameters.
     */
    updateCertificatePolicy(vaultBaseUrl, certificateName, certificatePolicy, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            certificatePolicy,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, updateCertificatePolicyOperationSpec);
    }
    /**
     * The UpdateCertificate operation applies the specified update on the given certificate; the only
     * elements updated are the certificate's attributes. This operation requires the certificates/update
     * permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate in the given key vault.
     * @param certificateVersion The version of the certificate.
     * @param options The options parameters.
     */
    updateCertificate(vaultBaseUrl, certificateName, certificateVersion, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            certificateVersion,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, updateCertificateOperationSpec);
    }
    /**
     * Gets information about a specific certificate. This operation requires the certificates/get
     * permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate in the given vault.
     * @param certificateVersion The version of the certificate. This URI fragment is optional. If not
     *                           specified, the latest version of the certificate is returned.
     * @param options The options parameters.
     */
    getCertificate(vaultBaseUrl, certificateName, certificateVersion, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            certificateVersion,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificateOperationSpec);
    }
    /**
     * Updates a certificate creation operation that is already in progress. This operation requires the
     * certificates/update permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param cancellationRequested Indicates if cancellation was requested on the certificate operation.
     * @param options The options parameters.
     */
    updateCertificateOperation(vaultBaseUrl, certificateName, cancellationRequested, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            cancellationRequested,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, updateCertificateOperationOperationSpec);
    }
    /**
     * Gets the creation operation associated with a specified certificate. This operation requires the
     * certificates/get permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param options The options parameters.
     */
    getCertificateOperation(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificateOperationOperationSpec);
    }
    /**
     * Deletes the creation operation for a specified certificate that is in the process of being created.
     * The certificate is no longer created. This operation requires the certificates/update permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param options The options parameters.
     */
    deleteCertificateOperation(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, deleteCertificateOperationOperationSpec);
    }
    /**
     * The MergeCertificate operation performs the merging of a certificate or certificate chain with a key
     * pair currently available in the service. This operation requires the certificates/create permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param x509Certificates The certificate or the certificate chain to merge.
     * @param options The options parameters.
     */
    mergeCertificate(vaultBaseUrl, certificateName, x509Certificates, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            x509Certificates,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, mergeCertificateOperationSpec);
    }
    /**
     * Requests that a backup of the specified certificate be downloaded to the client. All versions of the
     * certificate will be downloaded. This operation requires the certificates/backup permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param options The options parameters.
     */
    backupCertificate(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, backupCertificateOperationSpec);
    }
    /**
     * Restores a backed up certificate, and all its versions, to a vault. This operation requires the
     * certificates/restore permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateBundleBackup The backup blob associated with a certificate bundle.
     * @param options The options parameters.
     */
    restoreCertificate(vaultBaseUrl, certificateBundleBackup, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateBundleBackup,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, restoreCertificateOperationSpec);
    }
    /**
     * The GetDeletedCertificates operation retrieves the certificates in the current vault which are in a
     * deleted state and ready for recovery or purging. This operation includes deletion-specific
     * information. This operation requires the certificates/get/list permission. This operation can only
     * be enabled on soft-delete enabled vaults.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param options The options parameters.
     */
    getDeletedCertificates(vaultBaseUrl, options) {
        const operationArguments = {
            vaultBaseUrl,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getDeletedCertificatesOperationSpec);
    }
    /**
     * The GetDeletedCertificate operation retrieves the deleted certificate information plus its
     * attributes, such as retention interval, scheduled permanent deletion and the current deletion
     * recovery level. This operation requires the certificates/get permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate
     * @param options The options parameters.
     */
    getDeletedCertificate(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getDeletedCertificateOperationSpec);
    }
    /**
     * The PurgeDeletedCertificate operation performs an irreversible deletion of the specified
     * certificate, without possibility for recovery. The operation is not available if the recovery level
     * does not specify 'Purgeable'. This operation requires the certificate/purge permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate
     * @param options The options parameters.
     */
    purgeDeletedCertificate(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, purgeDeletedCertificateOperationSpec);
    }
    /**
     * The RecoverDeletedCertificate operation performs the reversal of the Delete operation. The operation
     * is applicable in vaults enabled for soft-delete, and must be issued during the retention interval
     * (available in the deleted certificate's attributes). This operation requires the
     * certificates/recover permission.
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the deleted certificate
     * @param options The options parameters.
     */
    recoverDeletedCertificate(vaultBaseUrl, certificateName, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, recoverDeletedCertificateOperationSpec);
    }
    /**
     * GetCertificatesNext
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param nextLink The nextLink from the previous successful call to the GetCertificates method.
     * @param options The options parameters.
     */
    getCertificatesNext(vaultBaseUrl, nextLink, options) {
        const operationArguments = {
            vaultBaseUrl,
            nextLink,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificatesNextOperationSpec);
    }
    /**
     * GetCertificateIssuersNext
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param nextLink The nextLink from the previous successful call to the GetCertificateIssuers method.
     * @param options The options parameters.
     */
    getCertificateIssuersNext(vaultBaseUrl, nextLink, options) {
        const operationArguments = {
            vaultBaseUrl,
            nextLink,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificateIssuersNextOperationSpec);
    }
    /**
     * GetCertificateVersionsNext
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param certificateName The name of the certificate.
     * @param nextLink The nextLink from the previous successful call to the GetCertificateVersions method.
     * @param options The options parameters.
     */
    getCertificateVersionsNext(vaultBaseUrl, certificateName, nextLink, options) {
        const operationArguments = {
            vaultBaseUrl,
            certificateName,
            nextLink,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getCertificateVersionsNextOperationSpec);
    }
    /**
     * GetDeletedCertificatesNext
     * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
     * @param nextLink The nextLink from the previous successful call to the GetDeletedCertificates method.
     * @param options The options parameters.
     */
    getDeletedCertificatesNext(vaultBaseUrl, nextLink, options) {
        const operationArguments = {
            vaultBaseUrl,
            nextLink,
            options: coreHttp__namespace.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getDeletedCertificatesNextOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp__namespace.Serializer(Mappers, /* isXml */ false);
const getCertificatesOperationSpec = {
    path: "/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [
        maxresults,
        includePending,
        apiVersion
    ],
    urlParameters: [vaultBaseUrl],
    headerParameters: [accept],
    serializer
};
const deleteCertificateOperationSpec = {
    path: "/certificates/{certificate-name}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: DeletedCertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept],
    serializer
};
const setCertificateContactsOperationSpec = {
    path: "/certificates/contacts",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: contacts,
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getCertificateContactsOperationSpec = {
    path: "/certificates/contacts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl],
    headerParameters: [accept],
    serializer
};
const deleteCertificateContactsOperationSpec = {
    path: "/certificates/contacts",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: Contacts
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl],
    headerParameters: [accept],
    serializer
};
const getCertificateIssuersOperationSpec = {
    path: "/certificates/issuers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateIssuerListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [maxresults, apiVersion],
    urlParameters: [vaultBaseUrl],
    headerParameters: [accept],
    serializer
};
const setCertificateIssuerOperationSpec = {
    path: "/certificates/issuers/{issuer-name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: {
        parameterPath: {
            provider: ["provider"],
            credentials: ["options", "credentials"],
            organizationDetails: ["options", "organizationDetails"],
            attributes: ["options", "attributes"]
        },
        mapper: Object.assign(Object.assign({}, CertificateIssuerSetParameters), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, issuerName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateCertificateIssuerOperationSpec = {
    path: "/certificates/issuers/{issuer-name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: {
        parameterPath: {
            provider: ["options", "provider"],
            credentials: ["options", "credentials"],
            organizationDetails: ["options", "organizationDetails"],
            attributes: ["options", "attributes"]
        },
        mapper: Object.assign(Object.assign({}, CertificateIssuerUpdateParameters), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, issuerName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getCertificateIssuerOperationSpec = {
    path: "/certificates/issuers/{issuer-name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, issuerName],
    headerParameters: [accept],
    serializer
};
const deleteCertificateIssuerOperationSpec = {
    path: "/certificates/issuers/{issuer-name}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: IssuerBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, issuerName],
    headerParameters: [accept],
    serializer
};
const createCertificateOperationSpec = {
    path: "/certificates/{certificate-name}/create",
    httpMethod: "POST",
    responses: {
        202: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: {
        parameterPath: {
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: Object.assign(Object.assign({}, CertificateCreateParameters), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName1],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const importCertificateOperationSpec = {
    path: "/certificates/{certificate-name}/import",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: {
        parameterPath: {
            base64EncodedCertificate: ["base64EncodedCertificate"],
            password: ["options", "password"],
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: Object.assign(Object.assign({}, CertificateImportParameters), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName1],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getCertificateVersionsOperationSpec = {
    path: "/certificates/{certificate-name}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [maxresults, apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept],
    serializer
};
const getCertificatePolicyOperationSpec = {
    path: "/certificates/{certificate-name}/policy",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificatePolicy
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept],
    serializer
};
const updateCertificatePolicyOperationSpec = {
    path: "/certificates/{certificate-name}/policy",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CertificatePolicy
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: certificatePolicy2,
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateCertificateOperationSpec = {
    path: "/certificates/{certificate-name}/{certificate-version}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: {
        parameterPath: {
            certificatePolicy: ["options", "certificatePolicy"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: Object.assign(Object.assign({}, CertificateUpdateParameters), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [
        vaultBaseUrl,
        certificateName,
        certificateVersion
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getCertificateOperationSpec = {
    path: "/certificates/{certificate-name}/{certificate-version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        vaultBaseUrl,
        certificateName,
        certificateVersion
    ],
    headerParameters: [accept],
    serializer
};
const updateCertificateOperationOperationSpec = {
    path: "/certificates/{certificate-name}/pending",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: {
        parameterPath: { cancellationRequested: ["cancellationRequested"] },
        mapper: Object.assign(Object.assign({}, CertificateOperationUpdateParameter), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getCertificateOperationOperationSpec = {
    path: "/certificates/{certificate-name}/pending",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept],
    serializer
};
const deleteCertificateOperationOperationSpec = {
    path: "/certificates/{certificate-name}/pending",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: CertificateOperation
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept],
    serializer
};
const mergeCertificateOperationSpec = {
    path: "/certificates/{certificate-name}/pending/merge",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: {
        parameterPath: {
            x509Certificates: ["x509Certificates"],
            certificateAttributes: ["options", "certificateAttributes"],
            tags: ["options", "tags"]
        },
        mapper: Object.assign(Object.assign({}, CertificateMergeParameters), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const backupCertificateOperationSpec = {
    path: "/certificates/{certificate-name}/backup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupCertificateResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept],
    serializer
};
const restoreCertificateOperationSpec = {
    path: "/certificates/restore",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    requestBody: {
        parameterPath: { certificateBundleBackup: ["certificateBundleBackup"] },
        mapper: Object.assign(Object.assign({}, CertificateRestoreParameters), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getDeletedCertificatesOperationSpec = {
    path: "/deletedcertificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedCertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [
        maxresults,
        includePending,
        apiVersion
    ],
    urlParameters: [vaultBaseUrl],
    headerParameters: [accept],
    serializer
};
const getDeletedCertificateOperationSpec = {
    path: "/deletedcertificates/{certificate-name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedCertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept],
    serializer
};
const purgeDeletedCertificateOperationSpec = {
    path: "/deletedcertificates/{certificate-name}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept],
    serializer
};
const recoverDeletedCertificateOperationSpec = {
    path: "/deletedcertificates/{certificate-name}/recover",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CertificateBundle
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [vaultBaseUrl, certificateName],
    headerParameters: [accept],
    serializer
};
const getCertificatesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [
        maxresults,
        includePending,
        apiVersion
    ],
    urlParameters: [vaultBaseUrl, nextLink],
    headerParameters: [accept],
    serializer
};
const getCertificateIssuersNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateIssuerListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [maxresults, apiVersion],
    urlParameters: [vaultBaseUrl, nextLink],
    headerParameters: [accept],
    serializer
};
const getCertificateVersionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [maxresults, apiVersion],
    urlParameters: [
        vaultBaseUrl,
        certificateName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const getDeletedCertificatesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedCertificateListResult
        },
        default: {
            bodyMapper: KeyVaultError
        }
    },
    queryParameters: [
        maxresults,
        includePending,
        apiVersion
    ],
    urlParameters: [vaultBaseUrl, nextLink],
    headerParameters: [accept],
    serializer
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "4.4.0";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 *
 * Valid key names in WWW-Authenticate header.
 */
const validParsedWWWAuthenticateProperties = [
    "authorization",
    "authorization_url",
    "resource",
    "scope",
    "tenantId",
];
/**
 * Parses an WWW-Authenticate response.
 * This transforms a string value like:
 * `Bearer authorization="https://some.url/tenantId", resource="https://some.url"`
 * into an object like:
 * `{ authorization: "https://some.url/tenantId", resource: "https://some.url" }`
 * @param wwwAuthenticate - String value in the WWW-Authenticate header
 */
function parseWWWAuthenticate(wwwAuthenticate) {
    const pairDelimiter = /,? +/;
    const parsed = wwwAuthenticate
        .split(pairDelimiter)
        .reduce((kvPairs, p) => {
        if (p.match(/\w="/)) {
            // 'sampleKey="sample_value"' -> [sampleKey, "sample_value"] -> { sampleKey: sample_value }
            const [key, value] = p.split("=");
            if (validParsedWWWAuthenticateProperties.includes(key)) {
                // The values will be wrapped in quotes, which need to be stripped out.
                return Object.assign(Object.assign({}, kvPairs), { [key]: value.slice(1, -1) });
            }
        }
        return kvPairs;
    }, {});
    // Finally, we pull the tenantId from the authorization header to support multi-tenant authentication.
    if (parsed.authorization) {
        try {
            const tenantId = new URL(parsed.authorization).pathname.substring(1);
            if (tenantId) {
                parsed.tenantId = tenantId;
            }
        }
        catch (_) {
            throw new Error(`The challenge authorization URI '${parsed.authorization}' is invalid.`);
        }
    }
    return parsed;
}

// Copyright (c) Microsoft Corporation.
/**
 * Representation of the Authentication Challenge
 */
class AuthenticationChallenge {
    constructor(authorization, scope, tenantId) {
        this.authorization = authorization;
        this.scope = scope;
        this.tenantId = tenantId;
    }
    /**
     * Checks that this AuthenticationChallenge is equal to another one given.
     * Only compares the scope.
     * This is exactly what C# is doing, as we can see here:
     * https://github.com/Azure/azure-sdk-for-net/blob/70e54b878ff1d01a45266fb3674a396b4ab9c1d2/sdk/keyvault/Azure.Security.KeyVault.Shared/src/ChallengeBasedAuthenticationPolicy.cs#L143-L147
     * @param other - The other AuthenticationChallenge
     */
    equalTo(other) {
        var _a, _b;
        return other
            ? this.scope.toLowerCase() === other.scope.toLowerCase() &&
                this.authorization.toLowerCase() === other.authorization.toLowerCase() &&
                ((_a = this.tenantId) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ((_b = other.tenantId) === null || _b === void 0 ? void 0 : _b.toLowerCase())
            : false;
    }
}
/**
 * Helps keep a copy of any previous authentication challenges,
 * so that we can compare on any further request.
 */
class AuthenticationChallengeCache {
    setCachedChallenge(challenge) {
        this.challenge = challenge;
    }
}
/**
 * Creates a new ChallengeBasedAuthenticationPolicy factory.
 *
 * @param credential - The TokenCredential implementation that can supply the challenge token.
 */
function challengeBasedAuthenticationPolicy(credential) {
    const tokenCache = new coreHttp.ExpiringAccessTokenCache();
    const challengeCache = new AuthenticationChallengeCache();
    return {
        create: (nextPolicy, options) => {
            return new ChallengeBasedAuthenticationPolicy(nextPolicy, options, credential, tokenCache, challengeCache);
        },
    };
}
/**
 *
 * Provides a RequestPolicy that can request a token from a TokenCredential
 * implementation and then apply it to the Authorization header of a request
 * as a Bearer token.
 *
 */
class ChallengeBasedAuthenticationPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Creates a new ChallengeBasedAuthenticationPolicy object.
     *
     * @param nextPolicy - The next RequestPolicy in the request pipeline.
     * @param options - Options for this RequestPolicy.
     * @param credential - The TokenCredential implementation that can supply the bearer token.
     * @param tokenCache - The cache for the most recent AccessToken returned by the TokenCredential.
     */
    constructor(nextPolicy, options, credential, tokenCache, challengeCache) {
        super(nextPolicy, options);
        this.credential = credential;
        this.tokenCache = tokenCache;
        this.challengeCache = challengeCache;
        this.parseWWWAuthenticate = parseWWWAuthenticate;
    }
    /**
     * Gets or updates the token from the token cache into the headers of the received web resource.
     */
    async loadToken(webResource) {
        let accessToken = this.tokenCache.getCachedToken();
        // If there's no cached token in the cache, we try to get a new one.
        if (accessToken === undefined) {
            const receivedToken = await this.credential.getToken(this.challengeCache.challenge.scope, {
                tenantId: this.challengeCache.challenge.tenantId,
            });
            accessToken = receivedToken || undefined;
            this.tokenCache.setCachedToken(accessToken);
        }
        if (accessToken) {
            webResource.headers.set(coreHttp.Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);
        }
    }
    /**
     * Parses the given WWW-Authenticate header, generates a new AuthenticationChallenge,
     * then if the challenge is different from the one cached, resets the token and forces
     * a re-authentication, otherwise continues with the existing challenge and token.
     * @param wwwAuthenticate - Value of the incoming WWW-Authenticate header.
     * @param webResource - Ongoing HTTP request.
     */
    async regenerateChallenge(wwwAuthenticate, webResource) {
        var _a;
        // The challenge based authentication will contain both:
        // - An authorization URI with a token,
        // - The resource to which that token is valid against (also called the scope).
        const parsedWWWAuth = this.parseWWWAuthenticate(wwwAuthenticate);
        const authorization = parsedWWWAuth.authorization;
        const resource = parsedWWWAuth.resource || parsedWWWAuth.scope;
        const tenantId = parsedWWWAuth.tenantId;
        if (!(authorization && resource)) {
            return this._nextPolicy.sendRequest(webResource);
        }
        const challenge = new AuthenticationChallenge(authorization, resource + "/.default", tenantId);
        // Either if there's no cached challenge at this point (could have happen in parallel),
        // or if the cached challenge has a different scope,
        // we store the just received challenge and reset the cached token, to force a re-authentication.
        if (!((_a = this.challengeCache.challenge) === null || _a === void 0 ? void 0 : _a.equalTo(challenge))) {
            this.challengeCache.setCachedChallenge(challenge);
            this.tokenCache.setCachedToken(undefined);
        }
        await this.loadToken(webResource);
        return this._nextPolicy.sendRequest(webResource);
    }
    /**
     * Applies the Bearer token to the request through the Authorization header.
     * @param webResource - Ongoing HTTP request.
     */
    async sendRequest(webResource) {
        // Ensure that we're about to use a secure connection.
        if (!webResource.url.startsWith("https:")) {
            throw new Error("The resource address for authorization must use the 'https' protocol.");
        }
        // The next request will happen differently whether we have a challenge or not.
        let response;
        if (this.challengeCache.challenge === undefined ||
            this.challengeCache.challenge === undefined) {
            // If there's no challenge in cache, a blank body will start the challenge.
            const originalBody = webResource.body;
            webResource.body = "";
            try {
                response = await this._nextPolicy.sendRequest(webResource);
            }
            finally {
                webResource.body = originalBody;
            }
        }
        else {
            // If we did have a challenge in memory,
            // we attempt to load the token from the cache into the request before we try to send the request.
            await this.loadToken(webResource);
            response = await this._nextPolicy.sendRequest(webResource);
        }
        // If we don't receive a response with a 401 status code,
        // then we can assume this response has nothing to do with the challenge authentication process.
        if (response.status !== 401) {
            return response;
        }
        // If the response status is 401, we only re-authenticate if the WWW-Authenticate header is present.
        const wwwAuthenticate = response.headers.get("WWW-Authenticate");
        if (!wwwAuthenticate) {
            return response;
        }
        // We re-generate the challenge and see if we have to re-authenticate.
        return this.regenerateChallenge(wwwAuthenticate, webResource);
    }
}

// Copyright (c) Microsoft Corporation.
function parseKeyvaultIdentifier(collection, identifier) {
    if (typeof collection !== "string" || !(collection = collection.trim())) {
        throw new Error("Invalid collection argument");
    }
    if (typeof identifier !== "string" || !(identifier = identifier.trim())) {
        throw new Error("Invalid identifier argument");
    }
    let baseUri;
    try {
        baseUri = url__namespace.parse(identifier, true, true);
    }
    catch (e) {
        throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);
    }
    // Path is of the form '/collection/name[/version]'
    const segments = (baseUri.pathname || "").split("/");
    if (segments.length !== 3 && segments.length !== 4) {
        throw new Error(`Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`);
    }
    if (collection !== segments[1]) {
        throw new Error(`Invalid ${collection} identifier: ${identifier}. segment [1] should be "${collection}", found "${segments[1]}"`);
    }
    const vaultUrl = `${baseUri.protocol}//${baseUri.host}`;
    const name = segments[2];
    const version = segments.length === 4 ? segments[3] : undefined;
    return {
        vaultUrl,
        name,
        version,
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Returns a function that can be used for tracing options.
 *
 * @param prefix - The prefix to use, likely the name of the class / client.
 *
 * @example const withTrace = createTraceFunction("Azure.KeyVault.Certificates.CertificateClient")
 *
 * @internal
 */
function createTraceFunction(prefix) {
    const createSpan = coreTracing.createSpanFunction({
        namespace: "Microsoft.KeyVault",
        packagePrefix: prefix,
    });
    return async function (operationName, options, cb) {
        const { updatedOptions, span } = createSpan(operationName, options);
        try {
            // NOTE: we really do need to await on this function here so we can handle any exceptions thrown and properly
            // close the span.
            const result = await cb(updatedOptions, span);
            // otel 0.16+ needs this or else the code ends up being set as UNSET
            span.setStatus({
                code: coreTracing.SpanStatusCode.OK,
            });
            return result;
        }
        catch (err) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: err.message,
            });
            throw err;
        }
        finally {
            span.end();
        }
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Generates a version of the state with only public properties. At least those common for all of the Key Vault Certificates pollers.
 */
// eslint-disable-next-line no-use-before-define
function cleanState(state) {
    return {
        certificateName: state.certificateName,
        isStarted: state.isStarted,
        isCancelled: state.isCancelled,
        isCompleted: state.isCompleted,
        error: state.error,
        result: state.result,
    };
}
/**
 * Common properties and methods of the Key Vault Certificate Pollers.
 */
class KeyVaultCertificatePoller extends coreLro.Poller {
    constructor() {
        super(...arguments);
        /**
         * Defines how much time the poller is going to wait before making a new request to the service.
         */
        this.intervalInMs = 2000;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     */
    async delay() {
        return coreHttp.delay(this.intervalInMs);
    }
    /**
     * Gets the public state of the polling operation
     */
    getOperationState() {
        return cleanState(this.operation.state);
    }
}
/**
 * Common properties and methods of the Key Vault Certificate Poller operations.
 */
class KeyVaultCertificatePollOperation {
    constructor(state, options = {}) {
        this.state = state;
        this.cancelMessage = "";
        if (options.cancelMessage) {
            this.cancelMessage = options.cancelMessage;
        }
    }
    /**
     * Meant to reach to the service and update the Poller operation.
     */
    async update() {
        throw new Error("Operation not supported.");
    }
    /**
     * Meant to reach to the service and cancel the Poller operation.
     */
    async cancel() {
        throw new Error(this.cancelMessage);
    }
    /**
     * Serializes the create certificate's poll operation
     */
    toString() {
        return JSON.stringify({
            state: cleanState(this.state),
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Parses the given Key Vault Certificate Id. An example is:
 *
 *   https://<keyvault-name>.vault.azure.net/certificates/<certificate-name>/<unique-version-id>
 *
 * On parsing the above Id, this function returns:
 *```ts
 *   {
 *      sourceId: "https://<keyvault-name>.vault.azure.net/certificates/<certificate-name>/<unique-version-id>",
 *      vaultUrl: "https://<keyvault-name>.vault.azure.net",
 *      version: "<unique-version-id>",
 *      name: "<certificate-name>"
 *   }
 *```
 * @param id - The Id of the Key Vault Certificate.
 */
function parseKeyVaultCertificateIdentifier(id) {
    const urlParts = id.split("/");
    const collection = urlParts[3];
    return Object.assign({ sourceId: id }, parseKeyvaultIdentifier(collection, id));
}

// Copyright (c) Microsoft Corporation.
function toCoreAttributes(properties) {
    return {
        recoveryLevel: properties.recoveryLevel,
        enabled: properties.enabled,
        notBefore: properties.notBefore,
        expires: properties.expiresOn,
        created: properties.createdOn,
        updated: properties.updatedOn,
    };
}
function toCorePolicy(id, policy, attributes = {}) {
    let subjectAlternativeNames = {};
    if (policy.subjectAlternativeNames) {
        subjectAlternativeNames = {
            emails: policy.subjectAlternativeNames.emails,
            dnsNames: policy.subjectAlternativeNames.dnsNames,
            upns: policy.subjectAlternativeNames.userPrincipalNames,
        };
    }
    return {
        id,
        lifetimeActions: policy.lifetimeActions
            ? policy.lifetimeActions.map((action) => ({
                action: { actionType: action.action },
                trigger: {
                    lifetimePercentage: action.lifetimePercentage,
                    daysBeforeExpiry: action.daysBeforeExpiry,
                },
            }))
            : undefined,
        keyProperties: {
            keyType: policy.keyType,
            keySize: policy.keySize,
            reuseKey: policy.reuseKey,
            curve: policy.keyCurveName,
            exportable: policy.exportable,
        },
        secretProperties: {
            contentType: policy.contentType,
        },
        x509CertificateProperties: {
            subject: policy.subject,
            ekus: policy.enhancedKeyUsage,
            subjectAlternativeNames,
            keyUsage: policy.keyUsage,
            validityInMonths: policy.validityInMonths,
        },
        issuerParameters: {
            name: policy.issuerName,
            certificateType: policy.certificateType,
            certificateTransparency: policy.certificateTransparency,
        },
        attributes,
    };
}
function toPublicPolicy(policy = {}) {
    let subjectAlternativeNames;
    const x509Properties = policy.x509CertificateProperties || {};
    if (policy.x509CertificateProperties) {
        if (x509Properties.subjectAlternativeNames) {
            const names = x509Properties.subjectAlternativeNames;
            if (names.emails && names.emails.length) {
                subjectAlternativeNames = Object.assign(Object.assign({}, subjectAlternativeNames), { emails: names.emails });
            }
            if (names.dnsNames && names.dnsNames.length) {
                subjectAlternativeNames = Object.assign(Object.assign({}, subjectAlternativeNames), { dnsNames: names.dnsNames });
            }
            if (names.upns && names.upns.length) {
                subjectAlternativeNames = Object.assign(Object.assign({}, subjectAlternativeNames), { userPrincipalNames: names.upns });
            }
        }
    }
    const certificatePolicy = {
        lifetimeActions: policy.lifetimeActions
            ? policy.lifetimeActions.map((action) => ({
                action: action.action ? action.action.actionType : undefined,
                daysBeforeExpiry: action.trigger ? action.trigger.daysBeforeExpiry : undefined,
                lifetimePercentage: action.trigger ? action.trigger.lifetimePercentage : undefined,
            }))
            : undefined,
        contentType: policy.secretProperties
            ? policy.secretProperties.contentType
            : undefined,
        enhancedKeyUsage: x509Properties.ekus,
        keyUsage: x509Properties.keyUsage,
        validityInMonths: x509Properties.validityInMonths,
        subject: x509Properties.subject,
        subjectAlternativeNames: subjectAlternativeNames,
    };
    if (policy.attributes) {
        certificatePolicy.enabled = policy.attributes.enabled;
    }
    if (policy.keyProperties) {
        certificatePolicy.keyType = policy.keyProperties.keyType;
        certificatePolicy.keySize = policy.keyProperties.keySize;
        certificatePolicy.reuseKey = policy.keyProperties.reuseKey;
        certificatePolicy.keyCurveName = policy.keyProperties.curve;
        certificatePolicy.exportable = policy.keyProperties.exportable;
    }
    if (policy.issuerParameters) {
        certificatePolicy.issuerName = policy.issuerParameters && policy.issuerParameters.name;
        certificatePolicy.certificateType = policy.issuerParameters
            .certificateType;
        certificatePolicy.certificateTransparency = policy.issuerParameters.certificateTransparency;
    }
    return certificatePolicy;
}
function toPublicIssuer(issuer = {}) {
    const parsedId = parseKeyVaultCertificateIdentifier(issuer.id);
    const attributes = issuer.attributes || {};
    const publicIssuer = {
        id: issuer.id,
        name: parsedId.name,
        provider: issuer.provider,
        accountId: issuer.credentials && issuer.credentials.accountId,
        password: issuer.credentials && issuer.credentials.password,
        enabled: attributes.enabled,
        createdOn: attributes.created,
        updatedOn: attributes.updated,
    };
    if (issuer.organizationDetails) {
        publicIssuer.organizationId = issuer.organizationDetails.id;
        publicIssuer.administratorContacts = issuer.organizationDetails.adminDetails
            ? issuer.organizationDetails.adminDetails.map((x) => ({
                email: x.emailAddress,
                phone: x.phone,
                firstName: x.firstName,
                lastName: x.lastName,
            }))
            : undefined;
    }
    return publicIssuer;
}
function getCertificateFromCertificateBundle(certificateBundle) {
    const parsedId = parseKeyVaultCertificateIdentifier(certificateBundle.id);
    const attributes = certificateBundle.attributes || {};
    const abstractProperties = {
        createdOn: attributes.created,
        updatedOn: attributes.updated,
        expiresOn: attributes.expires,
        id: certificateBundle.id,
        enabled: attributes.enabled,
        notBefore: attributes.notBefore,
        recoveryLevel: attributes.recoveryLevel,
        name: parsedId.name,
        vaultUrl: parsedId.vaultUrl,
        version: parsedId.version,
        tags: certificateBundle.tags,
        x509Thumbprint: certificateBundle.x509Thumbprint,
        recoverableDays: attributes.recoverableDays,
    };
    return {
        keyId: certificateBundle.kid,
        secretId: certificateBundle.sid,
        name: parsedId.name,
        cer: certificateBundle.cer,
        properties: abstractProperties,
    };
}
function getCertificateWithPolicyFromCertificateBundle(certificateBundle) {
    const parsedId = parseKeyVaultCertificateIdentifier(certificateBundle.id);
    const attributes = certificateBundle.attributes || {};
    const policy = toPublicPolicy(certificateBundle.policy || {});
    const abstractProperties = {
        createdOn: attributes.created,
        updatedOn: attributes.updated,
        expiresOn: attributes.expires,
        id: certificateBundle.id,
        enabled: attributes.enabled,
        notBefore: attributes.notBefore,
        recoveryLevel: attributes.recoveryLevel,
        name: parsedId.name,
        vaultUrl: parsedId.vaultUrl,
        version: parsedId.version,
        tags: certificateBundle.tags,
        x509Thumbprint: certificateBundle.x509Thumbprint,
        recoverableDays: attributes.recoverableDays,
    };
    return {
        keyId: certificateBundle.kid,
        secretId: certificateBundle.sid,
        name: parsedId.name,
        cer: certificateBundle.cer,
        policy,
        properties: abstractProperties,
    };
}
function getDeletedCertificateFromDeletedCertificateBundle(certificateBundle) {
    const certificate = getCertificateWithPolicyFromCertificateBundle(certificateBundle);
    return {
        policy: certificate.policy,
        cer: certificate.cer,
        id: certificate.id,
        keyId: certificate.keyId,
        secretId: certificate.secretId,
        name: certificate.name,
        properties: certificate.properties,
        recoveryId: certificateBundle.recoveryId,
        scheduledPurgeDate: certificateBundle.scheduledPurgeDate,
        deletedOn: certificateBundle.deletedDate,
    };
}
function getDeletedCertificateFromItem(item) {
    var _a, _b;
    const parsedId = parseKeyVaultCertificateIdentifier(item.id);
    const attributes = item.attributes || {};
    const abstractProperties = {
        createdOn: attributes.created,
        updatedOn: attributes.updated,
        expiresOn: attributes.expires,
        vaultUrl: parsedId.vaultUrl,
        version: parsedId.version,
        name: parsedId.name,
        id: item.id,
        tags: item.tags,
        x509Thumbprint: item.x509Thumbprint,
        recoverableDays: (_a = item.attributes) === null || _a === void 0 ? void 0 : _a.recoverableDays,
        recoveryLevel: (_b = item.attributes) === null || _b === void 0 ? void 0 : _b.recoveryLevel,
    };
    return {
        deletedOn: item.deletedDate,
        recoveryId: item.recoveryId,
        scheduledPurgeDate: item.scheduledPurgeDate,
        name: parsedId.name,
        properties: abstractProperties,
    };
}
function getCertificateOperationErrorFromErrorModel(error) {
    if (error) {
        return {
            code: error.code,
            innerError: getCertificateOperationErrorFromErrorModel(error.innerError),
            message: error.message,
        };
    }
    return undefined;
}
function getCertificateOperationFromCoreOperation(certificateName, vaultUrl, operation) {
    return {
        cancellationRequested: operation.cancellationRequested,
        name: certificateName,
        issuerName: operation.issuerParameters ? operation.issuerParameters.name : undefined,
        certificateTransparency: operation.issuerParameters
            ? operation.issuerParameters.certificateTransparency
            : undefined,
        certificateType: operation.issuerParameters
            ? operation.issuerParameters.certificateType
            : undefined,
        csr: operation.csr,
        error: getCertificateOperationErrorFromErrorModel(operation.error),
        id: operation.id,
        requestId: operation.requestId,
        status: operation.status,
        statusDetails: operation.statusDetails,
        target: operation.target,
        vaultUrl: vaultUrl,
    };
}
function coreContactsToCertificateContacts(contacts) {
    return contacts.contactList
        ? contacts.contactList.map((x) => ({ email: x.emailAddress, phone: x.phone, name: x.name }))
        : [];
}
function getPropertiesFromCertificateBundle(certificateBundle) {
    const parsedId = parseKeyVaultCertificateIdentifier(certificateBundle.id);
    const attributes = certificateBundle.attributes || {};
    const abstractProperties = {
        createdOn: attributes.created,
        updatedOn: attributes.updated,
        expiresOn: attributes.expires,
        id: certificateBundle.id,
        name: parsedId.name,
        enabled: attributes.enabled,
        notBefore: attributes.notBefore,
        recoveryLevel: attributes.recoveryLevel,
        vaultUrl: parsedId.vaultUrl,
        version: parsedId.version,
        tags: certificateBundle.tags,
        x509Thumbprint: certificateBundle.x509Thumbprint,
        recoverableDays: attributes.recoverableDays,
    };
    return abstractProperties;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
const withTrace$4 = createTraceFunction("Azure.KeyVault.Certificates.CreateCertificatePoller");
/**
 * An interface representing a create certificate's poll operation
 */
class CreateCertificatePollOperation extends KeyVaultCertificatePollOperation {
    constructor(state, vaultUrl, client, operationOptions = {}) {
        super(state);
        this.state = state;
        this.vaultUrl = vaultUrl;
        this.client = client;
        this.operationOptions = operationOptions;
    }
    /**
     * Creates a new certificate. If this is the first version, the certificate resource is created. This operation requires the certificates/create permission.
     */
    createCertificate(certificateName, certificatePolicy, options = {}) {
        return withTrace$4("createCertificate", options, async (updatedOptions) => {
            const id = options.id;
            const certificateAttributes = toCoreAttributes(options);
            const corePolicy = toCorePolicy(id, certificatePolicy, certificateAttributes);
            const result = await this.client.createCertificate(this.vaultUrl, certificateName, Object.assign(Object.assign({}, updatedOptions), { certificatePolicy: corePolicy, certificateAttributes }));
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.
     */
    getCertificate(certificateName, options = {}) {
        return withTrace$4("getCertificate", options, async (updatedOptions) => {
            const result = await this.client.getCertificate(this.vaultUrl, certificateName, "", updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * Gets the certificate operation.
     */
    getPlainCertificateOperation(certificateName, options = {}) {
        return withTrace$4("getPlainCertificateOperation", options, async (updatedOptions) => {
            const result = await this.client.getCertificateOperation(this.vaultUrl, certificateName, updatedOptions);
            return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, result._response.parsedBody);
        });
    }
    /**
     * Cancels a certificate creation operation that is already in progress. This operation requires the certificates/update permission.
     */
    cancelCertificateOperation(certificateName, options = {}) {
        return withTrace$4("cancelCertificateOperation", options, async (updatedOptions) => {
            const result = await this.client.updateCertificateOperation(this.vaultUrl, certificateName, true, updatedOptions);
            return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, result._response.parsedBody);
        });
    }
    /**
     * Reaches to the service and updates the create certificate's poll operation.
     */
    async update(options = {}) {
        const state = this.state;
        const { certificateName, certificatePolicy, createCertificateOptions } = state;
        if (options.abortSignal) {
            this.operationOptions.abortSignal = options.abortSignal;
            createCertificateOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            state.isStarted = true;
            state.result = await this.createCertificate(certificateName, certificatePolicy, createCertificateOptions);
            this.state.certificateOperation = await this.getPlainCertificateOperation(certificateName, this.operationOptions);
        }
        else if (!state.isCompleted) {
            this.state.certificateOperation = await this.getPlainCertificateOperation(certificateName, this.operationOptions);
        }
        if (state.certificateOperation && state.certificateOperation.status !== "inProgress") {
            state.isCompleted = true;
            state.result = await this.getCertificate(certificateName, this.operationOptions);
            if (state.certificateOperation.error) {
                state.error = new Error(state.certificateOperation.error.message);
            }
        }
        return this;
    }
    /**
     * Reaches to the service and cancels the certificate's operation, also updating the certificate's poll operation
     */
    async cancel(options = {}) {
        const state = this.state;
        const { certificateName } = state;
        if (options.abortSignal) {
            this.operationOptions.abortSignal = options.abortSignal;
        }
        state.certificateOperation = await this.cancelCertificateOperation(certificateName, this.operationOptions);
        this.state.isCancelled = true;
        return this;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a certificate finishes being deleted
 */
class CreateCertificatePoller extends KeyVaultCertificatePoller {
    constructor(options) {
        const { vaultUrl, client, certificateName, certificatePolicy, createCertificateOptions, operationOptions, intervalInMs = 2000, resumeFrom, } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = new CreateCertificatePollOperation(Object.assign(Object.assign({}, state), { certificateName,
            certificatePolicy,
            createCertificateOptions }), vaultUrl, client, operationOptions);
        super(operation);
        this.intervalInMs = intervalInMs;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
const withTrace$3 = createTraceFunction("Azure.KeyVault.Certificates.CertificateOperationPoller");
/**
 * An interface representing the active operation of a certificate's creation,
 * which is represented locally as the "operation" of an active LRO Poller.
 */
class CertificateOperationPollOperation extends KeyVaultCertificatePollOperation {
    constructor(state, vaultUrl, client, operationOptions = {}) {
        super(state);
        this.state = state;
        this.vaultUrl = vaultUrl;
        this.client = client;
        this.operationOptions = operationOptions;
    }
    /**
     * Cancels a certificate creation operation that is already in progress. This operation requires the certificates/update permission.
     */
    cancelCertificateOperation(certificateName, options = {}) {
        return withTrace$3("cancelCertificateOperation", options, async (updatedOptions) => {
            const result = await this.client.updateCertificateOperation(this.vaultUrl, certificateName, true, updatedOptions);
            return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, result._response.parsedBody);
        });
    }
    /**
     * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.
     */
    getCertificate(certificateName, options = {}) {
        return withTrace$3("getCertificate", options, async (updatedOptions) => {
            const result = await this.client.getCertificate(this.vaultUrl, certificateName, "", updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * Gets the certificate operation.
     */
    getPlainCertificateOperation(certificateName, options = {}) {
        return withTrace$3("getPlainCertificateOperation", options, async (updatedOptions) => {
            const result = await this.client.getCertificateOperation(this.vaultUrl, certificateName, updatedOptions);
            return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, result._response.parsedBody);
        });
    }
    /**
     * Reaches to the service and updates the poll operation.
     */
    async update(options = {}) {
        const state = this.state;
        const certificateName = state.certificateName;
        if (options.abortSignal) {
            this.operationOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            state.isStarted = true;
            state.result = await this.getCertificate(certificateName, this.operationOptions);
            state.certificateOperation = await this.getPlainCertificateOperation(certificateName, this.operationOptions);
        }
        else if (!state.isCompleted) {
            state.certificateOperation = await this.getPlainCertificateOperation(certificateName, this.operationOptions);
        }
        if (state.certificateOperation && state.certificateOperation.status !== "inProgress") {
            state.isCompleted = true;
            state.result = await this.getCertificate(certificateName, this.operationOptions);
            if (state.certificateOperation.error) {
                state.error = new Error(state.certificateOperation.error.message);
            }
        }
        return this;
    }
    /**
     * Reaches to the service and cancels the certificate's operation, also updating the poll operation.
     */
    async cancel(options = {}) {
        const state = this.state;
        const certificateName = state.certificateName;
        if (options.abortSignal) {
            this.operationOptions.abortSignal = options.abortSignal;
        }
        state.certificateOperation = await this.cancelCertificateOperation(certificateName, this.operationOptions);
        this.state.isCancelled = true;
        return this;
    }
    /**
     * Serializes the certificate's poll operation
     */
    toString() {
        const state = Object.assign({ certificateOperation: this.state.certificateOperation }, cleanState(this.state));
        return JSON.stringify({
            state,
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that creates a poller that waits until a certificate finishes being created
 */
class CertificateOperationPoller extends KeyVaultCertificatePoller {
    constructor(options) {
        const { vaultUrl, client, certificateName, operationOptions, intervalInMs = 2000, resumeFrom, } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = new CertificateOperationPollOperation(Object.assign(Object.assign({}, state), { certificateName }), vaultUrl, client, operationOptions);
        super(operation);
        this.intervalInMs = intervalInMs;
    }
    /**
     * Gets the public state of the polling operation
     */
    getOperationState() {
        return Object.assign(Object.assign({}, cleanState(this.operation.state)), { certificateOperation: this.operation.state.certificateOperation });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
const withTrace$2 = createTraceFunction("Azure.KeyVault.Certificates.DeleteCertificatePoller");
/**
 * An interface representing a delete certificate's poll operation
 */
class DeleteCertificatePollOperation extends KeyVaultCertificatePollOperation {
    constructor(state, vaultUrl, client, operationOptions = {}) {
        super(state, { cancelMessage: "Canceling the deletion of a certificate is not supported." });
        this.state = state;
        this.vaultUrl = vaultUrl;
        this.client = client;
        this.operationOptions = operationOptions;
    }
    /**
     * The DELETE operation applies to any certificate stored in Azure Key Vault. DELETE cannot be applied
     * to an individual version of a certificate. This operation requires the certificates/delete permission.
     */
    deleteCertificate(certificateName, options = {}) {
        return withTrace$2("deleteCertificate", options, async (updatedOptions) => {
            const response = await this.client.deleteCertificate(this.vaultUrl, certificateName, updatedOptions);
            return getDeletedCertificateFromDeletedCertificateBundle(response);
        });
    }
    /**
     * Retrieves the deleted certificate information plus its attributes, such as retention interval, scheduled permanent deletion and the
     * current deletion recovery level. This operation requires the certificates/get permission.
     */
    async getDeletedCertificate(certificateName, options = {}) {
        return withTrace$2("getDeletedCertificate", options, async (updatedOptions) => {
            const result = await this.client.getDeletedCertificate(this.vaultUrl, certificateName, updatedOptions);
            return getDeletedCertificateFromDeletedCertificateBundle(result._response.parsedBody);
        });
    }
    /**
     * Reaches to the service and updates the delete certificate's poll operation.
     */
    async update(options = {}) {
        const state = this.state;
        const { certificateName } = state;
        if (options.abortSignal) {
            this.operationOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            const deletedCertificate = await this.deleteCertificate(certificateName, this.operationOptions);
            state.isStarted = true;
            state.result = deletedCertificate;
            if (!deletedCertificate.recoveryId) {
                state.isCompleted = true;
            }
        }
        if (!state.isCompleted) {
            try {
                state.result = await this.getDeletedCertificate(certificateName, this.operationOptions);
                state.isCompleted = true;
            }
            catch (error) {
                if (error.statusCode === 403) {
                    // At this point, the resource exists but the user doesn't have access to it.
                    state.isCompleted = true;
                }
                else if (error.statusCode !== 404) {
                    state.error = error;
                    state.isCompleted = true;
                    throw error;
                }
            }
        }
        return this;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that deletes a poller that waits until a certificate finishes being deleted
 * @internal
 */
class DeleteCertificatePoller extends KeyVaultCertificatePoller {
    constructor(options) {
        const { vaultUrl, client, certificateName, operationOptions, intervalInMs = 2000, resumeFrom, } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = new DeleteCertificatePollOperation(Object.assign(Object.assign({}, state), { certificateName }), vaultUrl, client, operationOptions);
        super(operation);
        this.intervalInMs = intervalInMs;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
const withTrace$1 = createTraceFunction("Azure.KeyVault.Certificates.RecoverDeletedCertificatePoller");
/**
 * An interface representing the recovery of a deleted certificate's poll operation
 */
class RecoverDeletedCertificatePollOperation extends KeyVaultCertificatePollOperation {
    constructor(state, vaultUrl, client, operationOptions = {}) {
        super(state, {
            cancelMessage: "Canceling the recovery of a deleted certificate is not supported.",
        });
        this.state = state;
        this.vaultUrl = vaultUrl;
        this.client = client;
        this.operationOptions = operationOptions;
    }
    /**
     * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.
     */
    getCertificate(certificateName, options = {}) {
        return withTrace$1("getCertificate", options, async (updatedOptions) => {
            const result = await this.client.getCertificate(this.vaultUrl, certificateName, "", updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * Recovers the deleted certificate in the specified vault. This operation can only be performed on a soft-delete enabled vault. This operation
     * requires the certificate/recover permission.
     */
    recoverDeletedCertificate(certificateName, options = {}) {
        return withTrace$1("recoverDeletedCertificate", options, async (updatedOptions) => {
            const result = await this.client.recoverDeletedCertificate(this.vaultUrl, certificateName, updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result._response.parsedBody);
        });
    }
    /**
     * Reaches to the service and updates the poll operation.
     */
    async update(options = {}) {
        const state = this.state;
        const { certificateName } = state;
        if (options.abortSignal) {
            this.operationOptions.abortSignal = options.abortSignal;
        }
        if (!state.isStarted) {
            try {
                state.result = await this.getCertificate(certificateName, this.operationOptions);
                state.isCompleted = true;
            }
            catch (e) {
                // getCertificate will only work once the LRO is completed.
            }
            if (!state.isCompleted) {
                state.result = await this.recoverDeletedCertificate(certificateName, this.operationOptions);
                state.isStarted = true;
            }
        }
        if (!state.isCompleted) {
            try {
                state.result = await this.getCertificate(certificateName, this.operationOptions);
                state.isCompleted = true;
            }
            catch (error) {
                if (error.statusCode === 403) {
                    // At this point, the resource exists but the user doesn't have access to it.
                    state.isCompleted = true;
                }
                else if (error.statusCode !== 404) {
                    state.error = error;
                    state.isCompleted = true;
                    throw error;
                }
            }
        }
        return this;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that creates a poller that waits until a deleted certificate is fully recovered.
 */
class RecoverDeletedCertificatePoller extends KeyVaultCertificatePoller {
    constructor(options) {
        const { vaultUrl, client, certificateName, operationOptions, intervalInMs = 2000, resumeFrom, } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = new RecoverDeletedCertificatePollOperation(Object.assign(Object.assign({}, state), { certificateName }), vaultUrl, client, operationOptions);
        super(operation);
        this.intervalInMs = intervalInMs;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Decodes a Uint8Array into a Base64 string.
 * @internal
 */
function toBase64(bytes) {
    if (coreHttp.isNode) {
        return Buffer.from(bytes).toString("base64");
    }
    else {
        return btoa(String.fromCharCode.apply(null, bytes));
    }
}
/**
 * Decodes a Uint8Array into an ASCII string.
 * @internal
 */
function toAscii(bytes) {
    if (coreHttp.isNode) {
        return Buffer.from(bytes).toString("ascii");
    }
    else {
        return new TextDecoder("ascii").decode(bytes);
    }
}
/**
 * Parses the PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key
 * into a Base64 encoded string.
 *
 * @internal
 * @param certificateBytes - The PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key
 * @param contentType - "application/x-pem-file", "application/x-pkcs12" or undefined
 */
function parseCertificateBytes(certificateBytes, contentType) {
    if (contentType === "application/x-pem-file") {
        // PEM files have the certificate bytes already Base64 formatted.
        return toAscii(certificateBytes);
    }
    else {
        return toBase64(certificateBytes);
    }
}

// Copyright (c) Microsoft Corporation.
const withTrace = createTraceFunction("Azure.KeyVault.Certificates.CertificateClient");
/**
 * The client to interact with the KeyVault certificates functionality
 */
class CertificateClient {
    /**
     * Creates an instance of CertificateClient.
     * @param vaultUrl - the base URL to the vault.
     * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \@azure/identity package to create a credential that suits your needs.
     * @param pipelineOptions - Pipeline options used to configure Key Vault API requests.
     *                          Omit this parameter to use the default pipeline configuration.
     */
    constructor(vaultUrl, credential, pipelineOptions = {}) {
        this.vaultUrl = vaultUrl;
        const libInfo = `azsdk-js-keyvault-certificates/${SDK_VERSION}`;
        if (pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions.userAgentPrefix =
                pipelineOptions.userAgentOptions.userAgentPrefix !== undefined
                    ? `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`
                    : libInfo;
        }
        else {
            pipelineOptions.userAgentOptions = {
                userAgentPrefix: libInfo,
            };
        }
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? challengeBasedAuthenticationPolicy(credential)
            : coreHttp.signingPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), { loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: [
                    "x-ms-keyvault-region",
                    "x-ms-keyvault-network-info",
                    "x-ms-keyvault-service-version",
                ],
            } });
        this.client = new KeyVaultClient(pipelineOptions.serviceVersion || LATEST_API_VERSION, coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy));
    }
    listPropertiesOfCertificatesPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfCertificatesPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize, includePending: options.includePending }, options);
                const currentSetResponse = yield tslib.__await(withTrace("listPropertiesOfCertificates", optionsComplete, (updatedOptions) => this.client.getCertificates(this.vaultUrl, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(getPropertiesFromCertificateBundle, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(withTrace("listPropertiesOfCertificates", options, (updatedOptions) => this.client.getCertificates(continuationState.continuationToken, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(getPropertiesFromCertificateBundle, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listPropertiesOfCertificatesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfCertificatesAll_1() {
            var e_1, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listPropertiesOfCertificatesPage(f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const certificate of page) {
                        yield yield tslib.__await(certificate);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Iterates the latest version of all certificates in the vault.  The full certificate identifier and attributes are provided
     * in the response. No values are returned for the certificates. This operations requires the certificates/list permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * // All in one call
     * for await (const certificateProperties of client.listPropertiesOfCertificates()) {
     *   console.log(certificateProperties);
     * }
     * // By pages
     * for await (const page of client.listPropertiesOfCertificates().byPage()) {
     *   for (const certificateProperties of page) {
     *     console.log(certificateProperties);
     *   }
     * }
     * ```
     * List all versions of the specified certificate.
     * @param options - The optional parameters
     */
    listPropertiesOfCertificates(options = {}) {
        const iter = this.listPropertiesOfCertificatesAll(options);
        const result = {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfCertificatesPage(settings, options),
        };
        return result;
    }
    listPropertiesOfCertificateVersionsPage(certificateName, continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfCertificateVersionsPage_1() {
            if (continuationState.continuationToken == null) {
                const optionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield tslib.__await(withTrace("listPropertiesOfCertificateVersions", optionsComplete, (updatedOptions) => this.client.getCertificateVersions(this.vaultUrl, certificateName, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(getPropertiesFromCertificateBundle, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(withTrace("listPropertiesOfCertificateVersions", options, (updatedOptions) => this.client.getCertificateVersions(continuationState.continuationToken, certificateName, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(getPropertiesFromCertificateBundle, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listPropertiesOfCertificateVersionsAll(certificateName, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfCertificateVersionsAll_1() {
            var e_2, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listPropertiesOfCertificateVersionsPage(certificateName, f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns the versions of a certificate in the specified key
     * vault. This operation requires the certificates/list permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * for await (const certificateProperties of client.listPropertiesOfCertificateVersions("MyCertificate")) {
     *   console.log(certificateProperties.version!);
     * }
     * ```
     * List the versions of a certificate.
     * @param certificateName - The name of the certificate.
     * @param options - The optional parameters
     */
    listPropertiesOfCertificateVersions(certificateName, options = {}) {
        const iter = this.listPropertiesOfCertificateVersionsAll(certificateName, options);
        const result = {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfCertificateVersionsPage(certificateName, settings, options),
        };
        return result;
    }
    /**
     * The DELETE operation applies to any certificate stored in Azure Key Vault. DELETE cannot be applied
     * to an individual version of a certificate.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * This operation requires the certificates/delete permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const createPoller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await createPoller.pollUntilDone();
     *
     * const deletePoller = await client.beginDeleteCertificate("MyCertificate");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginDeleteCertificate("MyCertificate", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const deletedCertificate = await deletePoller.pollUntilDone();
     * console.log(deletedCertificate);
     * ```
     * Deletes a certificate from a specified key vault.
     * @param certificateName - The name of the certificate.
     * @param options - The optional parameters
     */
    async beginDeleteCertificate(certificateName, options = {}) {
        const poller = new DeleteCertificatePoller(Object.assign(Object.assign({ certificateName, client: this.client, vaultUrl: this.vaultUrl }, options), { operationOptions: options }));
        // This will initialize the poller's operation (the deletion of the secret).
        await poller.poll();
        return poller;
    }
    /**
     * Deletes all of the certificate contacts. This operation requires the certificates/managecontacts permission.
     *
     * Example usage:
     * ```ts
     * let client = new CertificateClient(url, credentials);
     * await client.setContacts([{
     *   email: "b@b.com",
     *   name: "b",
     *   phone: "222222222222"
     * }]);
     * await client.deleteContacts();
     * ```
     * Deletes all of the certificate contacts
     * @param options - The optional parameters
     */
    deleteContacts(options = {}) {
        return withTrace("deleteContacts", options, async (updatedOptions) => {
            const result = await this.client.deleteCertificateContacts(this.vaultUrl, updatedOptions);
            return coreContactsToCertificateContacts(result._response.parsedBody);
        });
    }
    /**
     * Sets the certificate contacts for the key vault. This operation requires the certificates/managecontacts permission.
     *
     * Example usage:
     * ```ts
     * let client = new CertificateClient(url, credentials);
     * await client.setContacts([{
     *   email: "b@b.com",
     *   name: "b",
     *   phone: "222222222222"
     * }]);
     * ```
     * Sets the certificate contacts.
     * @param contacts - The contacts to use
     * @param options - The optional parameters
     */
    setContacts(contacts, options = {}) {
        const coreContacts = contacts.map((x) => ({
            emailAddress: x ? x.email : undefined,
            name: x ? x.name : undefined,
            phone: x ? x.phone : undefined,
        }));
        return withTrace("setContacts", options, async (updatedOptions) => {
            const result = await this.client.setCertificateContacts(this.vaultUrl, { contactList: coreContacts }, updatedOptions);
            return coreContactsToCertificateContacts(result._response.parsedBody);
        });
    }
    /**
     * Returns the set of certificate contact resources in the specified key vault. This operation requires the certificates/managecontacts permission.
     *
     * Example usage:
     * ```ts
     * let client = new CertificateClient(url, credentials);
     * await client.setContacts([{
     *   email: "b@b.com",
     *   name: "b",
     *   phone: "222222222222"
     * }]);
     * const contacts = await client.getContacts();
     * console.log(contacts);
     * ```
     * Sets the certificate contacts.
     * @param options - The optional parameters
     */
    getContacts(options = {}) {
        return withTrace("getContacts", options, async (updatedOptions) => {
            const result = await this.client.getCertificateContacts(this.vaultUrl, updatedOptions);
            return coreContactsToCertificateContacts(result);
        });
    }
    listPropertiesOfIssuersPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfIssuersPage_1() {
            if (continuationState.continuationToken == null) {
                const requestOptionsComplete = Object.assign({ maxresults: continuationState.maxPageSize }, options);
                const currentSetResponse = yield tslib.__await(withTrace("listPropertiesOfIssuers", requestOptionsComplete, (updatedOptions) => this.client.getCertificateIssuers(this.vaultUrl, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value);
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(withTrace("listPropertiesOfIssuers", options, (updatedOptions) => this.client.getCertificateIssuers(continuationState.continuationToken, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value);
                }
                else {
                    break;
                }
            }
        });
    }
    listPropertiesOfIssuersAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listPropertiesOfIssuersAll_1() {
            var e_3, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listPropertiesOfIssuersPage(f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns the set of certificate issuer resources in the specified key vault. This operation requires the certificates/manageissuers/getissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * // All in one call
     * for await (const issuerProperties of client.listPropertiesOfIssuers()) {
     *   console.log(issuerProperties);
     * }
     * // By pages
     * for await (const page of client.listPropertiesOfIssuers().byPage()) {
     *   for (const issuerProperties of page) {
     *     console.log(issuerProperties);
     *   }
     * }
     * ```
     * List the certificate issuers.
     * @param options - The optional parameters
     */
    listPropertiesOfIssuers(options = {}) {
        const iter = this.listPropertiesOfIssuersAll(options);
        const result = {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listPropertiesOfIssuersPage(settings, options),
        };
        return result;
    }
    /**
     * The createIssuer operation adds or updates the specified certificate issuer. This
     * operation requires the certificates/setissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * ```
     * Sets the specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param provider - The issuer provider.
     * @param options - The optional parameters
     */
    createIssuer(issuerName, provider, options = {}) {
        return withTrace("createIssuer", options, async (updatedOptions) => {
            const { accountId, password } = updatedOptions;
            const generatedOptions = Object.assign(Object.assign({}, updatedOptions), { credentials: {
                    accountId,
                    password,
                } });
            if (updatedOptions.organizationId ||
                (updatedOptions.administratorContacts && updatedOptions.administratorContacts.length)) {
                generatedOptions.organizationDetails = {
                    id: updatedOptions.organizationId,
                    adminDetails: updatedOptions.administratorContacts
                        ? updatedOptions.administratorContacts.map((x) => ({
                            emailAddress: x.email,
                            phone: x.phone,
                            firstName: x.firstName,
                            lastName: x.lastName,
                        }))
                        : undefined,
                };
            }
            if (updatedOptions.enabled !== undefined) {
                generatedOptions.attributes = {
                    enabled: updatedOptions.enabled,
                };
            }
            const result = await this.client.setCertificateIssuer(this.vaultUrl, issuerName, provider, generatedOptions);
            return toPublicIssuer(result._response.parsedBody);
        });
    }
    /**
     * The updateIssuer operation performs an update on the specified certificate issuer
     * entity. This operation requires the certificates/setissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * await client.updateIssuer("IssuerName", {
     *   provider: "Provider2"
     * });
     * ```
     * Updates the specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param options - The optional parameters
     */
    async updateIssuer(issuerName, options = {}) {
        return withTrace("updateIssuer", options, async (updatedOptions) => {
            const { accountId, password } = options;
            const generatedOptions = Object.assign(Object.assign({}, updatedOptions), { credentials: {
                    accountId,
                    password,
                } });
            if (updatedOptions.organizationId ||
                (updatedOptions.administratorContacts && updatedOptions.administratorContacts.length)) {
                generatedOptions.organizationDetails = {
                    id: updatedOptions.organizationId,
                    adminDetails: updatedOptions.administratorContacts
                        ? updatedOptions.administratorContacts.map((x) => ({
                            emailAddress: x.email,
                            phone: x.phone,
                            firstName: x.firstName,
                            lastName: x.lastName,
                        }))
                        : undefined,
                };
            }
            if (updatedOptions.enabled) {
                generatedOptions.attributes = {
                    enabled: updatedOptions.enabled,
                };
            }
            const result = await this.client.updateCertificateIssuer(this.vaultUrl, issuerName, generatedOptions);
            return toPublicIssuer(result._response.parsedBody);
        });
    }
    /**
     * The getIssuer operation returns the specified certificate issuer resources in the
     * specified key vault. This operation requires the certificates/manageissuers/getissuers
     * permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Test");
     * const certificateIssuer = await client.getIssuer("IssuerName");
     * console.log(certificateIssuer);
     * ```
     * Gets he specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param options - The optional parameters
     */
    getIssuer(issuerName, options = {}) {
        return withTrace("getIssuer", options, async (updatedOptions) => {
            const result = await this.client.getCertificateIssuer(this.vaultUrl, issuerName, updatedOptions);
            return toPublicIssuer(result._response.parsedBody);
        });
    }
    /**
     * The deleteIssuer operation permanently removes the specified certificate issuer from
     * the vault. This operation requires the certificates/manageissuers/deleteissuers permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.createIssuer("IssuerName", "Provider");
     * await client.deleteIssuer("IssuerName");
     * ```
     * Deletes the specified certificate issuer.
     * @param issuerName - The name of the issuer.
     * @param options - The optional parameters
     */
    deleteIssuer(issuerName, options = {}) {
        return withTrace("deleteIssuer", options, async (updatedOptions) => {
            const result = await this.client.deleteCertificateIssuer(this.vaultUrl, issuerName, updatedOptions);
            return toPublicIssuer(result._response.parsedBody);
        });
    }
    /**
     * Creates a new certificate. If this is the first version, the certificate resource is created.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * **Note:** Sending `Self` as the `issuerName` of the certificate's policy will create a self-signed certificate.
     *
     * This operation requires the certificates/create permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const certificatePolicy = {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * };
     * const createPoller = await client.beginCreateCertificate("MyCertificate", certificatePolicy);
     *
     * // The pending certificate can be obtained by calling the following method:
     * const pendingCertificate = createPoller.getResult();
     *
     * // Serializing the poller
     * const serialized = createPoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginCreateCertificate("MyCertificate", certificatePolicy, { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const certificate = await createPoller.pollUntilDone();
     * console.log(certificate);
     * ```
     * Creates a certificate
     * @param certificateName - The name of the certificate
     * @param certificatePolicy - The certificate's policy
     * @param options - Optional parameters
     */
    async beginCreateCertificate(certificateName, policy, options = {}) {
        const poller = new CreateCertificatePoller({
            vaultUrl: this.vaultUrl,
            client: this.client,
            certificateName,
            certificatePolicy: policy,
            createCertificateOptions: options,
            operationOptions: options,
            intervalInMs: options.intervalInMs,
            resumeFrom: options.resumeFrom,
        });
        // This will initialize the poller's operation (the creation of the secret).
        await poller.poll();
        return poller;
    }
    /**
     * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const poller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await poller.pollUntilDone();
     * const certificate = await client.getCertificate("MyCertificate");
     * console.log(certificate);
     * ```
     * Retrieves a certificate from the certificate's name (includes the certificate policy)
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getCertificate(certificateName, options = {}) {
        return withTrace("getCertificate", options, async (updatedOptions) => {
            const result = await this.client.getCertificate(this.vaultUrl, certificateName, "", updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * Gets information about a specific certificate on a specific version. It won't return the certificate's policy. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const poller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await poller.pollUntilDone();
     * const certificateWithPolicy = await client.getCertificate("MyCertificate");
     * const certificate = await client.getCertificateVersion("MyCertificate", certificateWithPolicy.properties.version!);
     * console.log(certificate);
     * ```
     * Retrieves a certificate from the certificate's name and a specified version
     * @param certificateName - The name of the certificate
     * @param version - The specific version of the certificate
     * @param options - The optional parameters
     */
    getCertificateVersion(certificateName, version, options = {}) {
        return withTrace("getCertificateVersion", options, async (updatedOptions) => {
            if (!version) {
                throw new Error("The 'version' cannot be empty.");
            }
            const result = await this.client.getCertificate(this.vaultUrl, certificateName, version, updatedOptions);
            return getCertificateFromCertificateBundle(result);
        });
    }
    /**
     * Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format.
     * If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates. This operation requires the certificates/import permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * // See: @azure/keyvault-secrets
     * const certificateSecret = await secretClient.getSecret("MyCertificate");
     * const base64EncodedCertificate = certificateSecret.value!;
     * let buffer: Uint8Array;
     *
     * if (isNode) {
     *   buffer = Buffer.from(base64EncodedCertificate, "base64");
     * } else {
     *   buffer = Uint8Array.from(atob(base64EncodedCertificate), (c) => c.charCodeAt(0));
     * }
     *
     * await client.importCertificate("MyCertificate", buffer);
     * ```
     * Imports a certificate from a certificate's secret value
     * @param certificateName - The name of the certificate
     * @param certificateBytes - The PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key
     * @param options - The optional parameters
     */
    importCertificate(certificateName, certificateBytes, options = {}) {
        return withTrace("importCertificate", options, async (updatedOptions) => {
            var _a;
            const base64EncodedCertificate = parseCertificateBytes(certificateBytes, (_a = updatedOptions.policy) === null || _a === void 0 ? void 0 : _a.contentType);
            const result = await this.client.importCertificate(this.vaultUrl, certificateName, base64EncodedCertificate, updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result);
        });
    }
    /**
     * The getCertificatePolicy operation returns the specified certificate policy resources in the specified key vault. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * const policy = await client.getCertificatePolicy("MyCertificate");
     * console.log(policy);
     * ```
     * Gets a certificate's policy
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getCertificatePolicy(certificateName, options = {}) {
        return withTrace("getCertificatePolicy", options, async (updatedOptions) => {
            const result = await this.client.getCertificatePolicy(this.vaultUrl, certificateName, updatedOptions);
            return toPublicPolicy(result._response.parsedBody);
        });
    }
    /**
     * Updates the certificate policy for the specified certificate. This operation requires the certificates/update permission.
     * Gets a certificate's policy
     * @param certificateName - The name of the certificate
     * @param policy - The certificate policy
     * @param options - The optional parameters
     */
    updateCertificatePolicy(certificateName, policy, options = {}) {
        return withTrace("updateCertificatePolicy", options, async (updatedOptions) => {
            const corePolicy = toCorePolicy(undefined, policy);
            const result = await this.client.updateCertificatePolicy(this.vaultUrl, certificateName, corePolicy, updatedOptions);
            return toPublicPolicy(result._response.parsedBody);
        });
    }
    /**
     * Applies the specified update on the given certificate; the only elements updated are the
     * certificate's attributes. This operation requires the certificates/update permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     *
     * // You may pass an empty string for version which will update
     * // the latest version of the certificate
     * await client.updateCertificateProperties("MyCertificate", "", {
     *   tags: {
     *     customTag: "value"
     *   }
     * });
     * ```
     * Updates a certificate
     * @param certificateName - The name of the certificate
     * @param version - The version of the certificate to update (an empty string will update the latest version)
     * @param options - The options, including what to update
     */
    updateCertificateProperties(certificateName, version, options = {}) {
        return withTrace("updateCertificateProperties", options, async (updatedOptions) => {
            const result = await this.client.updateCertificate(this.vaultUrl, certificateName, version, Object.assign(Object.assign({}, updatedOptions), { certificateAttributes: toCoreAttributes(options) }));
            return getCertificateFromCertificateBundle(result._response.parsedBody);
        });
    }
    /**
     * Gets the creation operation associated with a specified certificate. This operation requires the certificates/get permission.
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const createPoller = await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     *
     * const poller = await client.getCertificateOperation("MyCertificate");
     * const pendingCertificate = poller.getResult();
     *
     * const certificateOperation = poller.getOperationState().certificateOperation;
     * console.log(certificateOperation);
     * ```
     * Gets a certificate's poller operation
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    async getCertificateOperation(certificateName, options = {}) {
        const poller = new CertificateOperationPoller({
            certificateName,
            client: this.client,
            vaultUrl: this.vaultUrl,
            intervalInMs: options.intervalInMs,
            resumeFrom: options.resumeFrom,
            operationOptions: options,
        });
        // This will initialize the poller's operation, which pre-populates some necessary properties.
        await poller.poll();
        return poller;
    }
    /**
     * Deletes the creation operation for a specified certificate that is in the process of being created.
     * The certificate is no longer created. This operation requires the certificates/update permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * await client.deleteCertificateOperation("MyCertificate");
     * await client.getCertificateOperation("MyCertificate"); // Throws error: Pending certificate not found: "MyCertificate"
     * ```
     * Delete a certificate's operation
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    deleteCertificateOperation(certificateName, options = {}) {
        return withTrace("deleteCertificateOperation", options, async (updatedOptions) => {
            const result = await this.client.deleteCertificateOperation(this.vaultUrl, certificateName, updatedOptions);
            return getCertificateOperationFromCoreOperation(certificateName, this.vaultUrl, result._response.parsedBody);
        });
    }
    /**
     * Performs the merging of a certificate or certificate chain with a key pair currently available in the service. This operation requires the certificates/create permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Unknown",
     *   subject: "cn=MyCert"
     * });
     * const poller = await client.getCertificateOperation("MyCertificate");
     * const { csr } = poller.getOperationState().certificateOperation!;
     * const base64Csr = Buffer.from(csr!).toString("base64");
     * const wrappedCsr = ["-----BEGIN CERTIFICATE REQUEST-----", base64Csr, "-----END CERTIFICATE REQUEST-----"].join("\n");
     *
     * const fs = require("fs");
     * fs.writeFileSync("test.csr", wrappedCsr);
     *
     * // Certificate available locally made using:
     * //   openssl genrsa -out ca.key 2048
     * //   openssl req -new -x509 -key ca.key -out ca.crt
     * // You can read more about how to create a fake certificate authority here: https://gist.github.com/Soarez/9688998
     *
     * const childProcess = require("child_process");
     * childProcess.execSync("openssl x509 -req -in test.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out test.crt");
     * const base64Crt = fs.readFileSync("test.crt").toString().split("\n").slice(1, -1).join("");
     *
     * await client.mergeCertificate("MyCertificate", [Buffer.from(base64Crt)]);
     * ```
     * Merges a signed certificate request into a pending certificate
     * @param certificateName - The name of the certificate
     * @param x509Certificates - The certificate(s) to merge
     * @param options - The optional parameters
     */
    mergeCertificate(certificateName, x509Certificates, options = {}) {
        return withTrace("mergeCertificate", options, async (updatedOptions) => {
            const result = await this.client.mergeCertificate(this.vaultUrl, certificateName, x509Certificates, updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result._response.parsedBody);
        });
    }
    /**
     * Requests that a backup of the specified certificate be downloaded to the client. All versions of the certificate will be downloaded.
     * This operation requires the certificates/backup permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * const backup = await client.backupCertificate("MyCertificate");
     * ```
     * Generates a backup of a certificate
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    backupCertificate(certificateName, options = {}) {
        return withTrace("backupCertificate", options, async (updatedOptions) => {
            const result = await this.client.backupCertificate(this.vaultUrl, certificateName, updatedOptions);
            return result._response.parsedBody.value;
        });
    }
    /**
     * Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * await client.beginCreateCertificate("MyCertificate", {
     *   issuerName: "Self",
     *   subject: "cn=MyCert"
     * });
     * const backup = await client.backupCertificate("MyCertificate");
     * const poller = await client.beginDeleteCertificate("MyCertificate");
     * await poller.pollUntilDone();
     * // Some time is required before we're able to restore the certificate
     * await client.restoreCertificateBackup(backup!);
     * ```
     * Restores a certificate from a backup
     * @param backup - The back-up certificate to restore from
     * @param options - The optional parameters
     */
    restoreCertificateBackup(backup, options = {}) {
        return withTrace("restoreCertificateBackup", options, async (updatedOptions) => {
            const result = await this.client.restoreCertificate(this.vaultUrl, backup, updatedOptions);
            return getCertificateWithPolicyFromCertificateBundle(result._response.parsedBody);
        });
    }
    listDeletedCertificatesPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedCertificatesPage_1() {
            if (continuationState.continuationToken == null) {
                const requestOptionsComplete = Object.assign({ maxresults: continuationState.maxPageSize, includePending: options.includePending }, options);
                const currentSetResponse = yield tslib.__await(withTrace("listDeletedCertificates", requestOptionsComplete, (updatedOptions) => this.client.getDeletedCertificates(this.vaultUrl, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(getDeletedCertificateFromItem, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(withTrace("listDeletedCertificates", options, (updatedOptions) => this.client.getDeletedCertificates(continuationState.continuationToken, updatedOptions)));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(getDeletedCertificateFromItem, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listDeletedCertificatesAll(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedCertificatesAll_1() {
            var e_4, _a;
            const f = {};
            try {
                for (var _b = tslib.__asyncValues(this.listDeletedCertificatesPage(f, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Retrieves the certificates in the current vault which are in a deleted state and ready for recovery or purging. This operation includes deletion-specific
     * information. This operation requires the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * for await (const deletedCertificate of client.listDeletedCertificates()) {
     *   console.log(deletedCertificate);
     * }
     * for await (const page of client.listDeletedCertificates().byPage()) {
     *   for (const deletedCertificate of page) {
     *     console.log(deletedCertificate);
     *   }
     * }
     * ```
     * Lists deleted certificates
     * @param options - The optional parameters
     */
    listDeletedCertificates(options = {}) {
        const iter = this.listDeletedCertificatesAll(options);
        const result = {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listDeletedCertificatesPage(settings, options),
        };
        return result;
    }
    /**
     * retrieves the deleted certificate information plus its attributes, such as retention interval, scheduled permanent deletion and the
     * current deletion recovery level. This operation requires the certificates/get permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const deletedCertificate = await client.getDeletedCertificate("MyDeletedCertificate");
     * console.log("Deleted certificate:", deletedCertificate);
     * ```
     * Gets a deleted certificate
     * @param certificateName - The name of the certificate
     * @param options - The optional parameters
     */
    getDeletedCertificate(certificateName, options = {}) {
        return withTrace("getDeletedCertificate", options, async (updatedOptions) => {
            const result = await this.client.getDeletedCertificate(this.vaultUrl, certificateName, updatedOptions);
            return getDeletedCertificateFromDeletedCertificateBundle(result._response.parsedBody);
        });
    }
    /**
     * Performs an irreversible deletion of the specified certificate, without possibility for recovery. The operation is not available if the
     * recovery level does not specify 'Purgeable'. This operation requires the certificate/purge permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     * const deletePoller = await client.beginDeleteCertificate("MyCertificate");
     * await deletePoller.pollUntilDone();
     * // Deleting a certificate takes time, make sure to wait before purging it
     * client.purgeDeletedCertificate("MyCertificate");
     * ```
     * Gets a deleted certificate
     * @param certificateName - The name of the deleted certificate to purge
     * @param options - The optional parameters
     */
    async purgeDeletedCertificate(certificateName, options = {}) {
        return withTrace("purgeDeletedCertificate", options, async (updatedOptions) => {
            await this.client.purgeDeletedCertificate(this.vaultUrl, certificateName, updatedOptions);
            return null;
        });
    }
    /**
     * Recovers the deleted certificate in the specified vault. This operation can only be performed on a soft-delete enabled vault. This operation
     * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.
     *
     * This operation requires the certificates/recover permission.
     *
     * Example usage:
     * ```ts
     * const client = new CertificateClient(url, credentials);
     *
     * const deletePoller = await client.beginDeleteCertificate("MyCertificate");
     * await deletePoller.pollUntilDone();
     *
     * const recoverPoller = await client.beginRecoverDeletedCertificate("MyCertificate");
     *
     * // Serializing the poller
     * const serialized = deletePoller.toString();
     *
     * // A new poller can be created with:
     * // const newPoller = await client.beginRecoverDeletedCertificate("MyCertificate", { resumeFrom: serialized });
     *
     * // Waiting until it's done
     * const certificate = await recoverPoller.pollUntilDone();
     * console.log(certificate);
     * ```
     * Recovers a deleted certificate
     * @param certificateName - The name of the deleted certificate
     * @param options - The optional parameters
     */
    async beginRecoverDeletedCertificate(certificateName, options = {}) {
        const poller = new RecoverDeletedCertificatePoller(Object.assign(Object.assign({ certificateName, client: this.client, vaultUrl: this.vaultUrl }, options), { operationOptions: options }));
        // This will initialize the poller's operation (the recovery of the deleted secret).
        await poller.poll();
        return poller;
    }
}

exports.CertificateClient = CertificateClient;
exports.DefaultCertificatePolicy = DefaultCertificatePolicy;
exports.logger = logger;
exports.parseKeyVaultCertificateIdentifier = parseKeyVaultCertificateIdentifier;
//# sourceMappingURL=index.js.map
