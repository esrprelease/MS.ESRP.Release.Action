{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/utils.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,MAAM,EAAE,MAAM,kBAAkB,CAAC;AAG1C;;;GAGG;AACH,MAAM,UAAU,QAAQ,CAAC,KAAiB;IACxC,IAAI,MAAM,EAAE;QACV,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;KAC9C;SAAM;QACL,OAAO,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,KAAwB,CAAC,CAAC,CAAC;KACxE;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,OAAO,CAAC,KAAiB;IACvC,IAAI,MAAM,EAAE;QACV,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;KAC7C;SAAM;QACL,OAAO,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;KAC/C;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,kBAAkB,CAAC,KAAa;IAC9C,IAAI,MAAM,EAAE;QACV,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAC3B;SAAM;QACL,OAAO,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;KACxC;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,kBAAkB,CAAC,KAAa;IAC9C,IAAI,MAAM,EAAE;QACV,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;KACrC;SAAM;QACL,OAAO,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;KAC7D;AACH,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,qBAAqB,CACnC,gBAA4B,EAC5B,WAAmC;IAEnC,IAAI,WAAW,KAAK,wBAAwB,EAAE;QAC5C,iEAAiE;QACjE,OAAO,OAAO,CAAC,gBAAgB,CAAC,CAAC;KAClC;SAAM;QACL,OAAO,QAAQ,CAAC,gBAAgB,CAAC,CAAC;KACnC;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isNode } from \"@azure/core-http\";\nimport { CertificateContentType } from \"./certificatesModels\";\n\n/**\n * Decodes a Uint8Array into a Base64 string.\n * @internal\n */\nexport function toBase64(bytes: Uint8Array): string {\n  if (isNode) {\n    return Buffer.from(bytes).toString(\"base64\");\n  } else {\n    return btoa(String.fromCharCode.apply(null, bytes as any as number[]));\n  }\n}\n\n/**\n * Decodes a Uint8Array into an ASCII string.\n * @internal\n */\nexport function toAscii(bytes: Uint8Array): string {\n  if (isNode) {\n    return Buffer.from(bytes).toString(\"ascii\");\n  } else {\n    return new TextDecoder(\"ascii\").decode(bytes);\n  }\n}\n\n/**\n * Encodes a JavaScript string into a Uint8Array.\n * @internal\n */\nexport function stringToUint8Array(value: string): Uint8Array {\n  if (isNode) {\n    return Buffer.from(value);\n  } else {\n    return new TextEncoder().encode(value);\n  }\n}\n\n/**\n * Encodes a Base64 string into a Uint8Array.\n * @internal\n */\nexport function base64ToUint8Array(value: string): Uint8Array {\n  if (isNode) {\n    return Buffer.from(value, \"base64\");\n  } else {\n    return Uint8Array.from(atob(value), (c) => c.charCodeAt(0));\n  }\n}\n\n/**\n * Parses the PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key\n * into a Base64 encoded string.\n *\n * @internal\n * @param certificateBytes - The PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key\n * @param contentType - \"application/x-pem-file\", \"application/x-pkcs12\" or undefined\n */\nexport function parseCertificateBytes(\n  certificateBytes: Uint8Array,\n  contentType: CertificateContentType\n): string {\n  if (contentType === \"application/x-pem-file\") {\n    // PEM files have the certificate bytes already Base64 formatted.\n    return toAscii(certificateBytes);\n  } else {\n    return toBase64(certificateBytes);\n  }\n}\n"]}