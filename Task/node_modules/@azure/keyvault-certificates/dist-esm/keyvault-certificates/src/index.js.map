{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// The eslint plugin mentioned below doesn't follow through the extended types.\n/* eslint-disable @azure/azure-sdk/ts-apisurface-supportcancellation */\n\n// This file makes more sense if ordered based on how meaningful are some methods in relation to others.\n/* eslint-disable @typescript-eslint/member-ordering */\n\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport {\n  TokenCredential,\n  isTokenCredential,\n  signingPolicy,\n  PipelineOptions,\n  createPipelineFromOptions,\n  InternalPipelineOptions,\n} from \"@azure/core-http\";\n\nimport { logger } from \"./log\";\nimport { PollerLike, PollOperationState } from \"@azure/core-lro\";\n\nimport {\n  KeyVaultCertificate,\n  KeyVaultCertificateWithPolicy,\n  AdministratorContact,\n  BackupCertificateOptions,\n  BeginCreateCertificateOptions,\n  BeginDeleteCertificateOptions,\n  BeginRecoverDeletedCertificateOptions,\n  CertificateIssuer,\n  CertificateContact,\n  CertificateContentType,\n  CertificatePolicy,\n  CertificateProperties,\n  CreateCertificateOptions,\n  DeleteCertificateOperationOptions,\n  DeleteContactsOptions,\n  DeleteIssuerOptions,\n  DeletedCertificate,\n  GetContactsOptions,\n  GetIssuerOptions,\n  GetCertificateOperationOptions,\n  GetPlainCertificateOperationOptions,\n  GetCertificateOptions,\n  GetCertificatePolicyOptions,\n  GetCertificateVersionOptions,\n  GetDeletedCertificateOptions,\n  CertificateTags,\n  ImportCertificateOptions,\n  ListPropertiesOfCertificatesOptions,\n  ErrorModel,\n  ListPropertiesOfCertificateVersionsOptions,\n  ListPropertiesOfIssuersOptions,\n  ListDeletedCertificatesOptions,\n  MergeCertificateOptions,\n  PurgeDeletedCertificateOptions,\n  RestoreCertificateBackupOptions,\n  SetContactsOptions,\n  CreateIssuerOptions,\n  CertificateOperation,\n  CertificateOperationError,\n  SubjectAlternativeNames,\n  UpdateIssuerOptions,\n  UpdateCertificatePropertiesOptions,\n  UpdateCertificatePolicyOptions,\n  WellKnownIssuerNames,\n  CertificatePollerOptions,\n  IssuerProperties,\n  CertificateContactAll,\n  CertificatePolicyAction,\n  LifetimeAction,\n  RequireAtLeastOne,\n  ArrayOneOrMore,\n  SubjectAlternativeNamesAll,\n  CertificatePolicyProperties,\n  PolicySubjectProperties,\n  DefaultCertificatePolicy,\n  CertificateClientOptions,\n  LATEST_API_VERSION,\n  CancelCertificateOperationOptions,\n  ImportCertificatePolicy,\n  KnownCertificateKeyCurveNames,\n  KnownCertificateKeyTypes,\n  KnownKeyUsageTypes,\n} from \"./certificatesModels\";\n\nimport {\n  GetCertificatesOptionalParams,\n  GetCertificateIssuersOptionalParams,\n  GetCertificateVersionsOptionalParams,\n  SetCertificateIssuerOptionalParams,\n  BackupCertificateResult,\n  GetDeletedCertificatesOptionalParams,\n  IssuerParameters,\n  IssuerCredentials,\n  IssuerAttributes,\n  X509CertificateProperties,\n  SubjectAlternativeNames as CoreSubjectAlternativeNames,\n  ActionType,\n  DeletionRecoveryLevel,\n  JsonWebKeyType as CertificateKeyType,\n  JsonWebKeyCurveName as CertificateKeyCurveName,\n  KnownDeletionRecoveryLevel as KnownDeletionRecoveryLevels,\n  KeyUsageType,\n} from \"./generated/models\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { SDK_VERSION } from \"./constants\";\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { challengeBasedAuthenticationPolicy, createTraceFunction } from \"../../keyvault-common/src\";\nimport { CreateCertificatePoller } from \"./lro/create/poller\";\nimport { CertificateOperationPoller } from \"./lro/operation/poller\";\nimport { DeleteCertificatePoller } from \"./lro/delete/poller\";\nimport { RecoverDeletedCertificatePoller } from \"./lro/recover/poller\";\nimport { CertificateOperationState } from \"./lro/operation/operation\";\nimport { DeleteCertificateState } from \"./lro/delete/operation\";\nimport { CreateCertificateState } from \"./lro/create/operation\";\nimport { RecoverDeletedCertificateState } from \"./lro/recover/operation\";\nimport { parseCertificateBytes } from \"./utils\";\nimport { KeyVaultCertificateIdentifier, parseKeyVaultCertificateIdentifier } from \"./identifier\";\nimport {\n  coreContactsToCertificateContacts,\n  getCertificateFromCertificateBundle,\n  getCertificateOperationFromCoreOperation,\n  getCertificateWithPolicyFromCertificateBundle,\n  getDeletedCertificateFromDeletedCertificateBundle,\n  getDeletedCertificateFromItem,\n  getPropertiesFromCertificateBundle,\n  toCoreAttributes,\n  toCorePolicy,\n  toPublicIssuer,\n  toPublicPolicy,\n} from \"./transformations\";\nimport { KeyVaultCertificatePollOperationState } from \"./lro/keyVaultCertificatePoller\";\n\nexport {\n  CertificateClientOptions,\n  ActionType,\n  AdministratorContact,\n  ArrayOneOrMore,\n  BackupCertificateResult,\n  BeginCreateCertificateOptions,\n  BeginDeleteCertificateOptions,\n  BeginRecoverDeletedCertificateOptions,\n  KeyVaultCertificate,\n  KeyVaultCertificateWithPolicy,\n  BackupCertificateOptions,\n  CertificateContentType,\n  CertificateProperties,\n  CertificateIssuer,\n  CertificateOperation,\n  CertificateOperationError,\n  CertificatePolicy,\n  ImportCertificatePolicy,\n  CertificatePolicyAction,\n  CertificatePolicyProperties,\n  PolicySubjectProperties,\n  CertificateTags,\n  CreateCertificateOptions,\n  CertificatePollerOptions,\n  KeyVaultCertificateIdentifier,\n  parseKeyVaultCertificateIdentifier,\n  PollerLike,\n  CreateCertificateState,\n  DeleteCertificateState,\n  RecoverDeletedCertificateState,\n  CertificateOperationState,\n  CoreSubjectAlternativeNames,\n  RequireAtLeastOne,\n  CertificateContactAll,\n  CertificateContact,\n  DeleteCertificateOperationOptions,\n  DeleteContactsOptions,\n  DeleteIssuerOptions,\n  DeletedCertificate,\n  DeletionRecoveryLevel,\n  DefaultCertificatePolicy,\n  ErrorModel,\n  GetContactsOptions,\n  GetIssuerOptions,\n  GetCertificateOperationOptions,\n  GetPlainCertificateOperationOptions,\n  GetCertificateOptions,\n  GetCertificatePolicyOptions,\n  GetCertificateVersionOptions,\n  GetDeletedCertificateOptions,\n  ImportCertificateOptions,\n  IssuerAttributes,\n  IssuerCredentials,\n  IssuerParameters,\n  IssuerProperties,\n  CertificateKeyType,\n  CertificateKeyCurveName,\n  KeyUsageType,\n  LifetimeAction,\n  ListPropertiesOfCertificatesOptions,\n  ListPropertiesOfCertificateVersionsOptions,\n  ListPropertiesOfIssuersOptions,\n  ListDeletedCertificatesOptions,\n  MergeCertificateOptions,\n  PipelineOptions,\n  PurgeDeletedCertificateOptions,\n  RestoreCertificateBackupOptions,\n  SetContactsOptions,\n  SubjectAlternativeNamesAll,\n  CreateIssuerOptions,\n  SubjectAlternativeNames,\n  UpdateIssuerOptions,\n  UpdateCertificatePropertiesOptions as UpdateCertificateOptions,\n  UpdateCertificatePolicyOptions,\n  WellKnownIssuerNames as WellKnownIssuer,\n  X509CertificateProperties,\n  logger,\n  CancelCertificateOperationOptions,\n  KeyVaultCertificatePollOperationState,\n  KnownCertificateKeyCurveNames,\n  KnownDeletionRecoveryLevels,\n  KnownCertificateKeyTypes,\n  KnownKeyUsageTypes,\n};\n\n/**\n * Deprecated KeyVault copy of core-lro's PollerLike.\n */\n// eslint-disable-next-line no-use-before-define\nexport type KVPollerLike<TState extends PollOperationState<TResult>, TResult> = PollerLike<\n  TState,\n  TResult\n>;\n\nconst withTrace = createTraceFunction(\"Azure.KeyVault.Certificates.CertificateClient\");\n\n/**\n * The client to interact with the KeyVault certificates functionality\n */\nexport class CertificateClient {\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  private readonly client: KeyVaultClient;\n\n  /**\n   * Creates an instance of CertificateClient.\n   * @param vaultUrl - the base URL to the vault.\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests.\n   *                          Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(\n    vaultUrl: string,\n    credential: TokenCredential,\n    pipelineOptions: CertificateClientOptions = {}\n  ) {\n    this.vaultUrl = vaultUrl;\n\n    const libInfo = `azsdk-js-keyvault-certificates/${SDK_VERSION}`;\n    if (pipelineOptions.userAgentOptions) {\n      pipelineOptions.userAgentOptions.userAgentPrefix =\n        pipelineOptions.userAgentOptions.userAgentPrefix !== undefined\n          ? `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo;\n    } else {\n      pipelineOptions.userAgentOptions = {\n        userAgentPrefix: libInfo,\n      };\n    }\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions: InternalPipelineOptions = {\n      ...pipelineOptions,\n      loggingOptions: {\n        logger: logger.info,\n        allowedHeaderNames: [\n          \"x-ms-keyvault-region\",\n          \"x-ms-keyvault-network-info\",\n          \"x-ms-keyvault-service-version\",\n        ],\n      },\n    };\n\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      createPipelineFromOptions(internalPipelineOptions, authPolicy)\n    );\n  }\n\n  private async *listPropertiesOfCertificatesPage(\n    continuationState: PageSettings,\n    options: ListPropertiesOfCertificatesOptions = {}\n  ): AsyncIterableIterator<CertificateProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: GetCertificatesOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        includePending: options.includePending,\n        ...options,\n      };\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfCertificates\",\n        optionsComplete,\n        (updatedOptions) => this.client.getCertificates(this.vaultUrl, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getPropertiesFromCertificateBundle, this);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfCertificates\",\n        options,\n        (updatedOptions) =>\n          this.client.getCertificates(continuationState.continuationToken!, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getPropertiesFromCertificateBundle, this);\n      } else {\n        break;\n      }\n    }\n  }\n\n  private async *listPropertiesOfCertificatesAll(\n    options: ListPropertiesOfCertificatesOptions = {}\n  ): AsyncIterableIterator<CertificateProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfCertificatesPage(f, options)) {\n      for (const certificate of page) {\n        yield certificate;\n      }\n    }\n  }\n\n  /**\n   * Iterates the latest version of all certificates in the vault.  The full certificate identifier and attributes are provided\n   * in the response. No values are returned for the certificates. This operations requires the certificates/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * // All in one call\n   * for await (const certificateProperties of client.listPropertiesOfCertificates()) {\n   *   console.log(certificateProperties);\n   * }\n   * // By pages\n   * for await (const page of client.listPropertiesOfCertificates().byPage()) {\n   *   for (const certificateProperties of page) {\n   *     console.log(certificateProperties);\n   *   }\n   * }\n   * ```\n   * List all versions of the specified certificate.\n   * @param options - The optional parameters\n   */\n  public listPropertiesOfCertificates(\n    options: ListPropertiesOfCertificatesOptions = {}\n  ): PagedAsyncIterableIterator<CertificateProperties> {\n    const iter = this.listPropertiesOfCertificatesAll(options);\n\n    const result = {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfCertificatesPage(settings, options),\n    };\n\n    return result;\n  }\n\n  private async *listPropertiesOfCertificateVersionsPage(\n    certificateName: string,\n    continuationState: PageSettings,\n    options: ListPropertiesOfCertificateVersionsOptions = {}\n  ): AsyncIterableIterator<CertificateProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: GetCertificateVersionsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options,\n      };\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfCertificateVersions\",\n        optionsComplete,\n        (updatedOptions) =>\n          this.client.getCertificateVersions(this.vaultUrl, certificateName, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getPropertiesFromCertificateBundle, this);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfCertificateVersions\",\n        options,\n        (updatedOptions) =>\n          this.client.getCertificateVersions(\n            continuationState.continuationToken!,\n            certificateName,\n            updatedOptions\n          )\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getPropertiesFromCertificateBundle, this);\n      } else {\n        break;\n      }\n    }\n  }\n\n  private async *listPropertiesOfCertificateVersionsAll(\n    certificateName: string,\n    options: ListPropertiesOfCertificateVersionsOptions = {}\n  ): AsyncIterableIterator<CertificateProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfCertificateVersionsPage(\n      certificateName,\n      f,\n      options\n    )) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Returns the versions of a certificate in the specified key\n   * vault. This operation requires the certificates/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * for await (const certificateProperties of client.listPropertiesOfCertificateVersions(\"MyCertificate\")) {\n   *   console.log(certificateProperties.version!);\n   * }\n   * ```\n   * List the versions of a certificate.\n   * @param certificateName - The name of the certificate.\n   * @param options - The optional parameters\n   */\n  public listPropertiesOfCertificateVersions(\n    certificateName: string,\n    options: ListPropertiesOfCertificateVersionsOptions = {}\n  ): PagedAsyncIterableIterator<CertificateProperties> {\n    const iter = this.listPropertiesOfCertificateVersionsAll(certificateName, options);\n\n    const result = {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfCertificateVersionsPage(certificateName, settings, options),\n    };\n\n    return result;\n  }\n\n  /**\n   * The DELETE operation applies to any certificate stored in Azure Key Vault. DELETE cannot be applied\n   * to an individual version of a certificate.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.\n   *\n   * This operation requires the certificates/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * const createPoller = await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * });\n   * await createPoller.pollUntilDone();\n   *\n   * const deletePoller = await client.beginDeleteCertificate(\"MyCertificate\");\n   *\n   * // Serializing the poller\n   * const serialized = deletePoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginDeleteCertificate(\"MyCertificate\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedCertificate = await deletePoller.pollUntilDone();\n   * console.log(deletedCertificate);\n   * ```\n   * Deletes a certificate from a specified key vault.\n   * @param certificateName - The name of the certificate.\n   * @param options - The optional parameters\n   */\n  public async beginDeleteCertificate(\n    certificateName: string,\n    options: BeginDeleteCertificateOptions = {}\n  ): Promise<PollerLike<DeleteCertificateState, DeletedCertificate>> {\n    const poller = new DeleteCertificatePoller({\n      certificateName,\n      client: this.client,\n      vaultUrl: this.vaultUrl,\n      ...options,\n      operationOptions: options,\n    });\n    // This will initialize the poller's operation (the deletion of the secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Deletes all of the certificate contacts. This operation requires the certificates/managecontacts permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CertificateClient(url, credentials);\n   * await client.setContacts([{\n   *   email: \"b@b.com\",\n   *   name: \"b\",\n   *   phone: \"222222222222\"\n   * }]);\n   * await client.deleteContacts();\n   * ```\n   * Deletes all of the certificate contacts\n   * @param options - The optional parameters\n   */\n  public deleteContacts(\n    options: DeleteContactsOptions = {}\n  ): Promise<CertificateContact[] | undefined> {\n    return withTrace(\"deleteContacts\", options, async (updatedOptions) => {\n      const result = await this.client.deleteCertificateContacts(this.vaultUrl, updatedOptions);\n      return coreContactsToCertificateContacts(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * Sets the certificate contacts for the key vault. This operation requires the certificates/managecontacts permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CertificateClient(url, credentials);\n   * await client.setContacts([{\n   *   email: \"b@b.com\",\n   *   name: \"b\",\n   *   phone: \"222222222222\"\n   * }]);\n   * ```\n   * Sets the certificate contacts.\n   * @param contacts - The contacts to use\n   * @param options - The optional parameters\n   */\n  public setContacts(\n    contacts: CertificateContact[],\n    options: SetContactsOptions = {}\n  ): Promise<CertificateContact[] | undefined> {\n    const coreContacts = contacts.map((x) => ({\n      emailAddress: x ? x.email : undefined,\n      name: x ? x.name : undefined,\n      phone: x ? x.phone : undefined,\n    }));\n\n    return withTrace(\"setContacts\", options, async (updatedOptions) => {\n      const result = await this.client.setCertificateContacts(\n        this.vaultUrl,\n        { contactList: coreContacts },\n        updatedOptions\n      );\n      return coreContactsToCertificateContacts(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * Returns the set of certificate contact resources in the specified key vault. This operation requires the certificates/managecontacts permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CertificateClient(url, credentials);\n   * await client.setContacts([{\n   *   email: \"b@b.com\",\n   *   name: \"b\",\n   *   phone: \"222222222222\"\n   * }]);\n   * const contacts = await client.getContacts();\n   * console.log(contacts);\n   * ```\n   * Sets the certificate contacts.\n   * @param options - The optional parameters\n   */\n  public getContacts(options: GetContactsOptions = {}): Promise<CertificateContact[] | undefined> {\n    return withTrace(\"getContacts\", options, async (updatedOptions) => {\n      const result = await this.client.getCertificateContacts(this.vaultUrl, updatedOptions);\n      return coreContactsToCertificateContacts(result);\n    });\n  }\n\n  private async *listPropertiesOfIssuersPage(\n    continuationState: PageSettings,\n    options: ListPropertiesOfIssuersOptions = {}\n  ): AsyncIterableIterator<IssuerProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const requestOptionsComplete: GetCertificateIssuersOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options,\n      };\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfIssuers\",\n        requestOptionsComplete,\n        (updatedOptions) => this.client.getCertificateIssuers(this.vaultUrl, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value;\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfIssuers\",\n        options,\n        (updatedOptions) =>\n          this.client.getCertificateIssuers(continuationState.continuationToken!, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value;\n      } else {\n        break;\n      }\n    }\n  }\n\n  private async *listPropertiesOfIssuersAll(\n    options: ListPropertiesOfIssuersOptions = {}\n  ): AsyncIterableIterator<IssuerProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfIssuersPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Returns the set of certificate issuer resources in the specified key vault. This operation requires the certificates/manageissuers/getissuers permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.createIssuer(\"IssuerName\", \"Test\");\n   * // All in one call\n   * for await (const issuerProperties of client.listPropertiesOfIssuers()) {\n   *   console.log(issuerProperties);\n   * }\n   * // By pages\n   * for await (const page of client.listPropertiesOfIssuers().byPage()) {\n   *   for (const issuerProperties of page) {\n   *     console.log(issuerProperties);\n   *   }\n   * }\n   * ```\n   * List the certificate issuers.\n   * @param options - The optional parameters\n   */\n  public listPropertiesOfIssuers(\n    options: ListPropertiesOfIssuersOptions = {}\n  ): PagedAsyncIterableIterator<IssuerProperties> {\n    const iter = this.listPropertiesOfIssuersAll(options);\n\n    const result = {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listPropertiesOfIssuersPage(settings, options),\n    };\n\n    return result;\n  }\n\n  /**\n   * The createIssuer operation adds or updates the specified certificate issuer. This\n   * operation requires the certificates/setissuers permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.createIssuer(\"IssuerName\", \"Test\");\n   * ```\n   * Sets the specified certificate issuer.\n   * @param issuerName - The name of the issuer.\n   * @param provider - The issuer provider.\n   * @param options - The optional parameters\n   */\n  public createIssuer(\n    issuerName: string,\n    provider: string,\n    options: CreateIssuerOptions = {}\n  ): Promise<CertificateIssuer> {\n    return withTrace(\"createIssuer\", options, async (updatedOptions) => {\n      const { accountId, password } = updatedOptions;\n\n      const generatedOptions: SetCertificateIssuerOptionalParams = {\n        ...updatedOptions,\n        credentials: {\n          accountId,\n          password,\n        },\n      };\n\n      if (\n        updatedOptions.organizationId ||\n        (updatedOptions.administratorContacts && updatedOptions.administratorContacts.length)\n      ) {\n        generatedOptions.organizationDetails = {\n          id: updatedOptions.organizationId,\n          adminDetails: updatedOptions.administratorContacts\n            ? updatedOptions.administratorContacts.map((x) => ({\n                emailAddress: x.email,\n                phone: x.phone,\n                firstName: x.firstName,\n                lastName: x.lastName,\n              }))\n            : undefined,\n        };\n      }\n\n      if (updatedOptions.enabled !== undefined) {\n        generatedOptions.attributes = {\n          enabled: updatedOptions.enabled,\n        };\n      }\n\n      const result = await this.client.setCertificateIssuer(\n        this.vaultUrl,\n        issuerName,\n        provider,\n        generatedOptions\n      );\n      return toPublicIssuer(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * The updateIssuer operation performs an update on the specified certificate issuer\n   * entity. This operation requires the certificates/setissuers permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.createIssuer(\"IssuerName\", \"Test\");\n   * await client.updateIssuer(\"IssuerName\", {\n   *   provider: \"Provider2\"\n   * });\n   * ```\n   * Updates the specified certificate issuer.\n   * @param issuerName - The name of the issuer.\n   * @param options - The optional parameters\n   */\n  public async updateIssuer(\n    issuerName: string,\n    options: UpdateIssuerOptions = {}\n  ): Promise<CertificateIssuer> {\n    return withTrace(\"updateIssuer\", options, async (updatedOptions) => {\n      const { accountId, password } = options;\n\n      const generatedOptions: SetCertificateIssuerOptionalParams = {\n        ...updatedOptions,\n        credentials: {\n          accountId,\n          password,\n        },\n      };\n\n      if (\n        updatedOptions.organizationId ||\n        (updatedOptions.administratorContacts && updatedOptions.administratorContacts.length)\n      ) {\n        generatedOptions.organizationDetails = {\n          id: updatedOptions.organizationId,\n          adminDetails: updatedOptions.administratorContacts\n            ? updatedOptions.administratorContacts.map((x) => ({\n                emailAddress: x.email,\n                phone: x.phone,\n                firstName: x.firstName,\n                lastName: x.lastName,\n              }))\n            : undefined,\n        };\n      }\n\n      if (updatedOptions.enabled) {\n        generatedOptions.attributes = {\n          enabled: updatedOptions.enabled,\n        };\n      }\n\n      const result = await this.client.updateCertificateIssuer(\n        this.vaultUrl,\n        issuerName,\n        generatedOptions\n      );\n\n      return toPublicIssuer(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * The getIssuer operation returns the specified certificate issuer resources in the\n   * specified key vault. This operation requires the certificates/manageissuers/getissuers\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.createIssuer(\"IssuerName\", \"Test\");\n   * const certificateIssuer = await client.getIssuer(\"IssuerName\");\n   * console.log(certificateIssuer);\n   * ```\n   * Gets he specified certificate issuer.\n   * @param issuerName - The name of the issuer.\n   * @param options - The optional parameters\n   */\n  public getIssuer(issuerName: string, options: GetIssuerOptions = {}): Promise<CertificateIssuer> {\n    return withTrace(\"getIssuer\", options, async (updatedOptions) => {\n      const result = await this.client.getCertificateIssuer(\n        this.vaultUrl,\n        issuerName,\n        updatedOptions\n      );\n      return toPublicIssuer(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * The deleteIssuer operation permanently removes the specified certificate issuer from\n   * the vault. This operation requires the certificates/manageissuers/deleteissuers permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.createIssuer(\"IssuerName\", \"Provider\");\n   * await client.deleteIssuer(\"IssuerName\");\n   * ```\n   * Deletes the specified certificate issuer.\n   * @param issuerName - The name of the issuer.\n   * @param options - The optional parameters\n   */\n  public deleteIssuer(\n    issuerName: string,\n    options: DeleteIssuerOptions = {}\n  ): Promise<CertificateIssuer> {\n    return withTrace(\"deleteIssuer\", options, async (updatedOptions) => {\n      const result = await this.client.deleteCertificateIssuer(\n        this.vaultUrl,\n        issuerName,\n        updatedOptions\n      );\n      return toPublicIssuer(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * Creates a new certificate. If this is the first version, the certificate resource is created.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.\n   *\n   * **Note:** Sending `Self` as the `issuerName` of the certificate's policy will create a self-signed certificate.\n   *\n   * This operation requires the certificates/create permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * const certificatePolicy = {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * };\n   * const createPoller = await client.beginCreateCertificate(\"MyCertificate\", certificatePolicy);\n   *\n   * // The pending certificate can be obtained by calling the following method:\n   * const pendingCertificate = createPoller.getResult();\n   *\n   * // Serializing the poller\n   * const serialized = createPoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginCreateCertificate(\"MyCertificate\", certificatePolicy, { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const certificate = await createPoller.pollUntilDone();\n   * console.log(certificate);\n   * ```\n   * Creates a certificate\n   * @param certificateName - The name of the certificate\n   * @param certificatePolicy - The certificate's policy\n   * @param options - Optional parameters\n   */\n  public async beginCreateCertificate(\n    certificateName: string,\n    policy: CertificatePolicy,\n    options: BeginCreateCertificateOptions = {}\n  ): Promise<PollerLike<CreateCertificateState, KeyVaultCertificateWithPolicy>> {\n    const poller = new CreateCertificatePoller({\n      vaultUrl: this.vaultUrl,\n      client: this.client,\n      certificateName,\n      certificatePolicy: policy,\n      createCertificateOptions: options,\n      operationOptions: options,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n    });\n    // This will initialize the poller's operation (the creation of the secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Gets the latest information available from a specific certificate, including the certificate's policy. This operation requires the certificates/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * const poller = await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * });\n   * await poller.pollUntilDone();\n   * const certificate = await client.getCertificate(\"MyCertificate\");\n   * console.log(certificate);\n   * ```\n   * Retrieves a certificate from the certificate's name (includes the certificate policy)\n   * @param certificateName - The name of the certificate\n   * @param options - The optional parameters\n   */\n  public getCertificate(\n    certificateName: string,\n    options: GetCertificateOptions = {}\n  ): Promise<KeyVaultCertificateWithPolicy> {\n    return withTrace(\"getCertificate\", options, async (updatedOptions) => {\n      const result = await this.client.getCertificate(\n        this.vaultUrl,\n        certificateName,\n        \"\",\n        updatedOptions\n      );\n      return getCertificateWithPolicyFromCertificateBundle(result);\n    });\n  }\n\n  /**\n   * Gets information about a specific certificate on a specific version. It won't return the certificate's policy. This operation requires the certificates/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * const poller = await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * });\n   * await poller.pollUntilDone();\n   * const certificateWithPolicy = await client.getCertificate(\"MyCertificate\");\n   * const certificate = await client.getCertificateVersion(\"MyCertificate\", certificateWithPolicy.properties.version!);\n   * console.log(certificate);\n   * ```\n   * Retrieves a certificate from the certificate's name and a specified version\n   * @param certificateName - The name of the certificate\n   * @param version - The specific version of the certificate\n   * @param options - The optional parameters\n   */\n  public getCertificateVersion(\n    certificateName: string,\n    version: string,\n    options: GetCertificateVersionOptions = {}\n  ): Promise<KeyVaultCertificate> {\n    return withTrace(\"getCertificateVersion\", options, async (updatedOptions) => {\n      if (!version) {\n        throw new Error(\"The 'version' cannot be empty.\");\n      }\n      const result = await this.client.getCertificate(\n        this.vaultUrl,\n        certificateName,\n        version,\n        updatedOptions\n      );\n      return getCertificateFromCertificateBundle(result);\n    });\n  }\n\n  /**\n   * Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate to be imported can be in either PFX or PEM format.\n   * If the certificate is in PEM format the PEM file must contain the key as well as x509 certificates. This operation requires the certificates/import permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * // See: @azure/keyvault-secrets\n   * const certificateSecret = await secretClient.getSecret(\"MyCertificate\");\n   * const base64EncodedCertificate = certificateSecret.value!;\n   * let buffer: Uint8Array;\n   *\n   * if (isNode) {\n   *   buffer = Buffer.from(base64EncodedCertificate, \"base64\");\n   * } else {\n   *   buffer = Uint8Array.from(atob(base64EncodedCertificate), (c) => c.charCodeAt(0));\n   * }\n   *\n   * await client.importCertificate(\"MyCertificate\", buffer);\n   * ```\n   * Imports a certificate from a certificate's secret value\n   * @param certificateName - The name of the certificate\n   * @param certificateBytes - The PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key\n   * @param options - The optional parameters\n   */\n  public importCertificate(\n    certificateName: string,\n    certificateBytes: Uint8Array,\n    options: ImportCertificateOptions = {}\n  ): Promise<KeyVaultCertificateWithPolicy> {\n    return withTrace(\"importCertificate\", options, async (updatedOptions) => {\n      const base64EncodedCertificate = parseCertificateBytes(\n        certificateBytes,\n        updatedOptions.policy?.contentType\n      );\n      const result = await this.client.importCertificate(\n        this.vaultUrl,\n        certificateName,\n        base64EncodedCertificate,\n        updatedOptions\n      );\n      return getCertificateWithPolicyFromCertificateBundle(result);\n    });\n  }\n\n  /**\n   * The getCertificatePolicy operation returns the specified certificate policy resources in the specified key vault. This operation requires the certificates/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * });\n   * const policy = await client.getCertificatePolicy(\"MyCertificate\");\n   * console.log(policy);\n   * ```\n   * Gets a certificate's policy\n   * @param certificateName - The name of the certificate\n   * @param options - The optional parameters\n   */\n  public getCertificatePolicy(\n    certificateName: string,\n    options: GetCertificatePolicyOptions = {}\n  ): Promise<CertificatePolicy> {\n    return withTrace(\"getCertificatePolicy\", options, async (updatedOptions) => {\n      const result = await this.client.getCertificatePolicy(\n        this.vaultUrl,\n        certificateName,\n        updatedOptions\n      );\n      return toPublicPolicy(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * Updates the certificate policy for the specified certificate. This operation requires the certificates/update permission.\n   * Gets a certificate's policy\n   * @param certificateName - The name of the certificate\n   * @param policy - The certificate policy\n   * @param options - The optional parameters\n   */\n  public updateCertificatePolicy(\n    certificateName: string,\n    policy: CertificatePolicy,\n    options: UpdateCertificatePolicyOptions = {}\n  ): Promise<CertificatePolicy> {\n    return withTrace(\"updateCertificatePolicy\", options, async (updatedOptions) => {\n      const corePolicy = toCorePolicy(undefined, policy);\n      const result = await this.client.updateCertificatePolicy(\n        this.vaultUrl,\n        certificateName,\n        corePolicy,\n        updatedOptions\n      );\n      return toPublicPolicy(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * Applies the specified update on the given certificate; the only elements updated are the\n   * certificate's attributes. This operation requires the certificates/update permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * });\n   *\n   * // You may pass an empty string for version which will update\n   * // the latest version of the certificate\n   * await client.updateCertificateProperties(\"MyCertificate\", \"\", {\n   *   tags: {\n   *     customTag: \"value\"\n   *   }\n   * });\n   * ```\n   * Updates a certificate\n   * @param certificateName - The name of the certificate\n   * @param version - The version of the certificate to update (an empty string will update the latest version)\n   * @param options - The options, including what to update\n   */\n  public updateCertificateProperties(\n    certificateName: string,\n    version: string,\n    options: UpdateCertificatePropertiesOptions = {}\n  ): Promise<KeyVaultCertificate> {\n    return withTrace(\"updateCertificateProperties\", options, async (updatedOptions) => {\n      const result = await this.client.updateCertificate(this.vaultUrl, certificateName, version, {\n        ...updatedOptions,\n        certificateAttributes: toCoreAttributes(options),\n      });\n      return getCertificateFromCertificateBundle(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * Gets the creation operation associated with a specified certificate. This operation requires the certificates/get permission.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * const createPoller = await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * });\n   *\n   * const poller = await client.getCertificateOperation(\"MyCertificate\");\n   * const pendingCertificate = poller.getResult();\n   *\n   * const certificateOperation = poller.getOperationState().certificateOperation;\n   * console.log(certificateOperation);\n   * ```\n   * Gets a certificate's poller operation\n   * @param certificateName - The name of the certificate\n   * @param options - The optional parameters\n   */\n  public async getCertificateOperation(\n    certificateName: string,\n    options: GetCertificateOperationOptions = {}\n  ): Promise<PollerLike<CertificateOperationState, KeyVaultCertificateWithPolicy>> {\n    const poller = new CertificateOperationPoller({\n      certificateName,\n      client: this.client,\n      vaultUrl: this.vaultUrl,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      operationOptions: options,\n    });\n    // This will initialize the poller's operation, which pre-populates some necessary properties.\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Deletes the creation operation for a specified certificate that is in the process of being created.\n   * The certificate is no longer created. This operation requires the certificates/update permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * });\n   * await client.deleteCertificateOperation(\"MyCertificate\");\n   * await client.getCertificateOperation(\"MyCertificate\"); // Throws error: Pending certificate not found: \"MyCertificate\"\n   * ```\n   * Delete a certificate's operation\n   * @param certificateName - The name of the certificate\n   * @param options - The optional parameters\n   */\n  public deleteCertificateOperation(\n    certificateName: string,\n    options: DeleteCertificateOperationOptions = {}\n  ): Promise<CertificateOperation> {\n    return withTrace(\"deleteCertificateOperation\", options, async (updatedOptions) => {\n      const result = await this.client.deleteCertificateOperation(\n        this.vaultUrl,\n        certificateName,\n        updatedOptions\n      );\n      return getCertificateOperationFromCoreOperation(\n        certificateName,\n        this.vaultUrl,\n        result._response.parsedBody\n      );\n    });\n  }\n\n  /**\n   * Performs the merging of a certificate or certificate chain with a key pair currently available in the service. This operation requires the certificates/create permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Unknown\",\n   *   subject: \"cn=MyCert\"\n   * });\n   * const poller = await client.getCertificateOperation(\"MyCertificate\");\n   * const { csr } = poller.getOperationState().certificateOperation!;\n   * const base64Csr = Buffer.from(csr!).toString(\"base64\");\n   * const wrappedCsr = [\"-----BEGIN CERTIFICATE REQUEST-----\", base64Csr, \"-----END CERTIFICATE REQUEST-----\"].join(\"\\n\");\n   *\n   * const fs = require(\"fs\");\n   * fs.writeFileSync(\"test.csr\", wrappedCsr);\n   *\n   * // Certificate available locally made using:\n   * //   openssl genrsa -out ca.key 2048\n   * //   openssl req -new -x509 -key ca.key -out ca.crt\n   * // You can read more about how to create a fake certificate authority here: https://gist.github.com/Soarez/9688998\n   *\n   * const childProcess = require(\"child_process\");\n   * childProcess.execSync(\"openssl x509 -req -in test.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out test.crt\");\n   * const base64Crt = fs.readFileSync(\"test.crt\").toString().split(\"\\n\").slice(1, -1).join(\"\");\n   *\n   * await client.mergeCertificate(\"MyCertificate\", [Buffer.from(base64Crt)]);\n   * ```\n   * Merges a signed certificate request into a pending certificate\n   * @param certificateName - The name of the certificate\n   * @param x509Certificates - The certificate(s) to merge\n   * @param options - The optional parameters\n   */\n  public mergeCertificate(\n    certificateName: string,\n    x509Certificates: Uint8Array[],\n    options: MergeCertificateOptions = {}\n  ): Promise<KeyVaultCertificateWithPolicy> {\n    return withTrace(\"mergeCertificate\", options, async (updatedOptions) => {\n      const result = await this.client.mergeCertificate(\n        this.vaultUrl,\n        certificateName,\n        x509Certificates,\n        updatedOptions\n      );\n      return getCertificateWithPolicyFromCertificateBundle(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * Requests that a backup of the specified certificate be downloaded to the client. All versions of the certificate will be downloaded.\n   * This operation requires the certificates/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * });\n   * const backup = await client.backupCertificate(\"MyCertificate\");\n   * ```\n   * Generates a backup of a certificate\n   * @param certificateName - The name of the certificate\n   * @param options - The optional parameters\n   */\n  public backupCertificate(\n    certificateName: string,\n    options: BackupCertificateOptions = {}\n  ): Promise<Uint8Array | undefined> {\n    return withTrace(\"backupCertificate\", options, async (updatedOptions) => {\n      const result = await this.client.backupCertificate(\n        this.vaultUrl,\n        certificateName,\n        updatedOptions\n      );\n      return result._response.parsedBody.value;\n    });\n  }\n\n  /**\n   * Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * await client.beginCreateCertificate(\"MyCertificate\", {\n   *   issuerName: \"Self\",\n   *   subject: \"cn=MyCert\"\n   * });\n   * const backup = await client.backupCertificate(\"MyCertificate\");\n   * const poller = await client.beginDeleteCertificate(\"MyCertificate\");\n   * await poller.pollUntilDone();\n   * // Some time is required before we're able to restore the certificate\n   * await client.restoreCertificateBackup(backup!);\n   * ```\n   * Restores a certificate from a backup\n   * @param backup - The back-up certificate to restore from\n   * @param options - The optional parameters\n   */\n  public restoreCertificateBackup(\n    backup: Uint8Array,\n    options: RestoreCertificateBackupOptions = {}\n  ): Promise<KeyVaultCertificateWithPolicy> {\n    return withTrace(\"restoreCertificateBackup\", options, async (updatedOptions) => {\n      const result = await this.client.restoreCertificate(this.vaultUrl, backup, updatedOptions);\n      return getCertificateWithPolicyFromCertificateBundle(result._response.parsedBody);\n    });\n  }\n\n  private async *listDeletedCertificatesPage(\n    continuationState: PageSettings,\n    options: ListDeletedCertificatesOptions = {}\n  ): AsyncIterableIterator<DeletedCertificate[]> {\n    if (continuationState.continuationToken == null) {\n      const requestOptionsComplete: GetDeletedCertificatesOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        includePending: options.includePending,\n        ...options,\n      };\n      const currentSetResponse = await withTrace(\n        \"listDeletedCertificates\",\n        requestOptionsComplete,\n        (updatedOptions) => this.client.getDeletedCertificates(this.vaultUrl, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getDeletedCertificateFromItem, this);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\n        \"listDeletedCertificates\",\n        options,\n        (updatedOptions) =>\n          this.client.getDeletedCertificates(continuationState.continuationToken!, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getDeletedCertificateFromItem, this);\n      } else {\n        break;\n      }\n    }\n  }\n\n  private async *listDeletedCertificatesAll(\n    options: ListDeletedCertificatesOptions = {}\n  ): AsyncIterableIterator<DeletedCertificate> {\n    const f = {};\n\n    for await (const page of this.listDeletedCertificatesPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Retrieves the certificates in the current vault which are in a deleted state and ready for recovery or purging. This operation includes deletion-specific\n   * information. This operation requires the certificates/get/list permission. This operation can only be enabled on soft-delete enabled vaults.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * for await (const deletedCertificate of client.listDeletedCertificates()) {\n   *   console.log(deletedCertificate);\n   * }\n   * for await (const page of client.listDeletedCertificates().byPage()) {\n   *   for (const deletedCertificate of page) {\n   *     console.log(deletedCertificate);\n   *   }\n   * }\n   * ```\n   * Lists deleted certificates\n   * @param options - The optional parameters\n   */\n  public listDeletedCertificates(\n    options: ListDeletedCertificatesOptions = {}\n  ): PagedAsyncIterableIterator<DeletedCertificate> {\n    const iter = this.listDeletedCertificatesAll(options);\n\n    const result = {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listDeletedCertificatesPage(settings, options),\n    };\n\n    return result;\n  }\n\n  /**\n   * retrieves the deleted certificate information plus its attributes, such as retention interval, scheduled permanent deletion and the\n   * current deletion recovery level. This operation requires the certificates/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * const deletedCertificate = await client.getDeletedCertificate(\"MyDeletedCertificate\");\n   * console.log(\"Deleted certificate:\", deletedCertificate);\n   * ```\n   * Gets a deleted certificate\n   * @param certificateName - The name of the certificate\n   * @param options - The optional parameters\n   */\n  public getDeletedCertificate(\n    certificateName: string,\n    options: GetDeletedCertificateOptions = {}\n  ): Promise<DeletedCertificate> {\n    return withTrace(\"getDeletedCertificate\", options, async (updatedOptions) => {\n      const result = await this.client.getDeletedCertificate(\n        this.vaultUrl,\n        certificateName,\n        updatedOptions\n      );\n      return getDeletedCertificateFromDeletedCertificateBundle(result._response.parsedBody);\n    });\n  }\n\n  /**\n   * Performs an irreversible deletion of the specified certificate, without possibility for recovery. The operation is not available if the\n   * recovery level does not specify 'Purgeable'. This operation requires the certificate/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   * const deletePoller = await client.beginDeleteCertificate(\"MyCertificate\");\n   * await deletePoller.pollUntilDone();\n   * // Deleting a certificate takes time, make sure to wait before purging it\n   * client.purgeDeletedCertificate(\"MyCertificate\");\n   * ```\n   * Gets a deleted certificate\n   * @param certificateName - The name of the deleted certificate to purge\n   * @param options - The optional parameters\n   */\n  public async purgeDeletedCertificate(\n    certificateName: string,\n    options: PurgeDeletedCertificateOptions = {}\n  ): Promise<null> {\n    return withTrace(\"purgeDeletedCertificate\", options, async (updatedOptions) => {\n      await this.client.purgeDeletedCertificate(this.vaultUrl, certificateName, updatedOptions);\n      return null;\n    });\n  }\n\n  /**\n   * Recovers the deleted certificate in the specified vault. This operation can only be performed on a soft-delete enabled vault. This operation\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the certificate is fully recovered.\n   *\n   * This operation requires the certificates/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new CertificateClient(url, credentials);\n   *\n   * const deletePoller = await client.beginDeleteCertificate(\"MyCertificate\");\n   * await deletePoller.pollUntilDone();\n   *\n   * const recoverPoller = await client.beginRecoverDeletedCertificate(\"MyCertificate\");\n   *\n   * // Serializing the poller\n   * const serialized = deletePoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginRecoverDeletedCertificate(\"MyCertificate\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const certificate = await recoverPoller.pollUntilDone();\n   * console.log(certificate);\n   * ```\n   * Recovers a deleted certificate\n   * @param certificateName - The name of the deleted certificate\n   * @param options - The optional parameters\n   */\n  public async beginRecoverDeletedCertificate(\n    certificateName: string,\n    options: BeginRecoverDeletedCertificateOptions = {}\n  ): Promise<PollerLike<RecoverDeletedCertificateState, KeyVaultCertificateWithPolicy>> {\n    const poller = new RecoverDeletedCertificatePoller({\n      certificateName,\n      client: this.client,\n      vaultUrl: this.vaultUrl,\n      ...options,\n      operationOptions: options,\n    });\n    // This will initialize the poller's operation (the recovery of the deleted secret).\n    await poller.poll();\n    return poller;\n  }\n}\n"]}