"use strict";
/**
 * ESRP Gateway API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MSEssGatewayClientContractsReleaseFileSignStatus = exports.MSEssGatewayClientContractsReleaseFileScanStatus = exports.MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus = exports.MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus = exports.MSEssGatewayClientContractsReleaseEditOwnerInfo = exports.MSEssGatewayClientContractsReleaseEditChannelDownloadEntity = exports.MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo = exports.MSEssGatewayClientContractsReleaseEditApproverInfo = exports.MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo = exports.MSEssGatewayClientContractsReleaseApproverInfo = exports.MSEssGatewayClientContractsReleaseAccessPermissionsInfo = exports.MSEssGatewayClientContractsProvisionStorageResultMessage = exports.MSEssGatewayClientContractsProvisionStorageRequest = exports.MSEssGatewayClientContractsPolicyResultMessage = exports.MSEssGatewayClientContractsPolicy = exports.MSEssGatewayClientContractsPkitaCertificateCertificateInfo = exports.MSEssGatewayClientContractsPKITACertificateValidityDuration = exports.MSEssGatewayClientContractsPKITACertificatePolicyExtension = exports.MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage = exports.MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage = exports.MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage = exports.MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage = exports.MSEssGatewayClientContractsPKITACertificateFailedCsrFile = exports.MSEssGatewayClientContractsPKITACertificateCsrFile = exports.MSEssGatewayClientContractsPKITACertificateClmApprovalInfo = exports.MSEssGatewayClientContractsOperationTemplate = exports.MSEssGatewayClientContractsOperationResponse = exports.MSEssGatewayClientContractsLegacyCopsMappingData = exports.MSEssGatewayClientContractsInnerServiceError = exports.MSEssGatewayClientContractsIFeature = exports.MSEssGatewayClientContractsGatewayError = exports.MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage = exports.MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult = exports.MSEssGatewayClientContractsFileTransferFileTransferResultMessage = exports.MSEssGatewayClientContractsFileLocation = exports.MSEssGatewayClientContractsEventHubTelemetryConnectionShard = exports.MSEssGatewayClientContractsEsrpClientConfigInfo3 = exports.MSEssGatewayClientContractsDynamicSigningOperation = exports.MSEssGatewayClientContractsDigestSignOperationErrorPatterns = exports.MSEssGatewayClientContractsDigestSignMapping = exports.MSEssGatewayClientContractsDigestSignCertificateResultMessage = exports.MSEssGatewayClientContractsDigestSignCertificateRequestMessage = exports.MSEssGatewayClientContractsCryptoResultMessage = exports.MSEssGatewayClientContractsCryptoRequestMessage = exports.MSEssGatewayClientContractsCryptoParameter = exports.MSEssGatewayClientContractsCryptoOperation = exports.MSEssGatewayClientContractsCryptoFileInfo = exports.MSEssGatewayClientContractsCipherResultMessage = exports.MSEssGatewayClientContractsCipherInfo = exports.MSEssGatewayClientContractsCipherDetailsMessage = void 0;
exports.MicrosoftAspNetCoreHttpIResponseCookies = exports.MicrosoftAspNetCoreHttpHttpResponse = exports.MicrosoftAspNetCoreHttpHttpRequest = exports.MicrosoftAspNetCoreHttpHttpContext = exports.MicrosoftAspNetCoreHttpHostString = exports.MicrosoftAspNetCoreHttpConnectionInfo = exports.MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager = exports.MSEssGatewayClientOnPremContractsSignedDigest = exports.MSEssGatewayClientOnPremContractsHashInfo = exports.MSEssGatewayClientOnPremContractsDigestSignResultMessage = exports.MSEssGatewayClientOnPremContractsDigestSignRequestMessage = exports.MSEssGatewayClientContractsStorageShard = exports.MSEssGatewayClientContractsStaticSigningOperation = exports.MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_ = exports.MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse = exports.MSEssGatewayClientContractsSlkRequestSlkRequestMessage = exports.MSEssGatewayClientContractsSigningParameter = exports.MSEssGatewayClientContractsSignResultMessage = exports.MSEssGatewayClientContractsSignRequestMessage = exports.MSEssGatewayClientContractsSignFileInfo = exports.MSEssGatewayClientContractsSessionResultMessage = exports.MSEssGatewayClientContractsSessionRequestMessage = exports.MSEssGatewayClientContractsScanResultMessage = exports.MSEssGatewayClientContractsScanRequestMessage = exports.MSEssGatewayClientContractsScanGroupResult = exports.MSEssGatewayClientContractsScanFileInfo = exports.MSEssGatewayClientContractsRoutingInfo = exports.MSEssGatewayClientContractsRequestDetails = exports.MSEssGatewayClientContractsReleaseUserInfo = exports.MSEssGatewayClientContractsReleaseResponseReleaseResultMessage = exports.MSEssGatewayClientContractsReleaseResponseReleaseError = exports.MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo = exports.MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage = exports.MSEssGatewayClientContractsReleaseResponseReleaseEditResponse = exports.MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage = exports.MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo = exports.MSEssGatewayClientContractsReleaseResponseApproverInfoDetails = exports.MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage = exports.MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage = exports.MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage = exports.MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage = exports.MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage = exports.MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo = exports.MSEssGatewayClientContractsReleaseReleaseInfoProperties = exports.MSEssGatewayClientContractsReleaseReleaseInfo = exports.MSEssGatewayClientContractsReleaseReleaseFileInfo = exports.MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo = exports.MSEssGatewayClientContractsReleaseProductInfo = exports.MSEssGatewayClientContractsReleaseOwnerInfo = exports.MSEssGatewayClientContractsReleaseFileVaultStatusInfo = void 0;
exports.MicrosoftODataUriParserODataPathSegment = exports.MicrosoftODataUriParserFilterClause = exports.MicrosoftODataUriParserAggregationTransformationNode = exports.MicrosoftODataUriParserAggregationApplyClause = exports.MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation = exports.MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable = exports.MicrosoftODataEdmVocabulariesIEdmTerm = exports.MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager = exports.MicrosoftODataEdmIEdmTypeReference = exports.MicrosoftODataEdmIEdmType = exports.MicrosoftODataEdmIEdmStructuredType = exports.MicrosoftODataEdmIEdmStructuralProperty = exports.MicrosoftODataEdmIEdmSchemaElement = exports.MicrosoftODataEdmIEdmReferentialConstraint = exports.MicrosoftODataEdmIEdmProperty = exports.MicrosoftODataEdmIEdmPathExpression = exports.MicrosoftODataEdmIEdmNavigationSource = exports.MicrosoftODataEdmIEdmNavigationPropertyBinding = exports.MicrosoftODataEdmIEdmNavigationProperty = exports.MicrosoftODataEdmIEdmModel = exports.MicrosoftODataEdmIEdmExpression = exports.MicrosoftODataEdmIEdmEntityContainerElement = exports.MicrosoftODataEdmIEdmEntityContainer = exports.MicrosoftODataEdmEdmReferentialConstraintPropertyPair = exports.MicrosoftAspNetODataRoutingODataPath = exports.MicrosoftAspNetODataQueryValidatorsTopQueryValidator = exports.MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator = exports.MicrosoftAspNetODataQueryValidatorsSkipQueryValidator = exports.MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator = exports.MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator = exports.MicrosoftAspNetODataQueryValidatorsODataQueryValidator = exports.MicrosoftAspNetODataQueryValidatorsFilterQueryValidator = exports.MicrosoftAspNetODataQueryValidatorsCountQueryValidator = exports.MicrosoftAspNetODataQueryTopQueryOption = exports.MicrosoftAspNetODataQuerySkipTokenQueryOption = exports.MicrosoftAspNetODataQuerySkipQueryOption = exports.MicrosoftAspNetODataQuerySelectExpandQueryOption = exports.MicrosoftAspNetODataQueryOrderByQueryOption = exports.MicrosoftAspNetODataQueryOrderByNode = exports.MicrosoftAspNetODataQueryODataRawQueryOptions = exports.MicrosoftAspNetODataQueryODataQuerySettings = exports.MicrosoftAspNetODataQueryODataQueryOptions = exports.MicrosoftAspNetODataQueryFilterQueryOption = exports.MicrosoftAspNetODataQueryDefaultQuerySettings = exports.MicrosoftAspNetODataQueryCountQueryOption = exports.MicrosoftAspNetODataQueryApplyQueryOption = exports.MicrosoftAspNetODataODataQueryContext = exports.MicrosoftAspNetCoreHttpWebSocketManager = exports.MicrosoftAspNetCoreHttpQueryString = exports.MicrosoftAspNetCoreHttpISession = void 0;
exports.ReleaseApi = exports.ReleaseApiApiKeys = exports.ProvisionStorageApi = exports.ProvisionStorageApiApiKeys = exports.ProductOnboardingApi = exports.ProductOnboardingApiApiKeys = exports.PolicyApi = exports.PolicyApiApiKeys = exports.PkitaCertificateApi = exports.PkitaCertificateApiApiKeys = exports.PkitaCLMCertificateApprovalApi = exports.PkitaCLMCertificateApprovalApiApiKeys = exports.PkitaCLMCertificateApi = exports.PkitaCLMCertificateApiApiKeys = exports.KeyValidationApi = exports.KeyValidationApiApiKeys = exports.KeyFulfilmentApi = exports.KeyFulfilmentApiApiKeys = exports.HealthApi = exports.HealthApiApiKeys = exports.GroupApi = exports.GroupApiApiKeys = exports.FileTransferApi = exports.FileTransferApiApiKeys = exports.DigestSignApi = exports.DigestSignApiApiKeys = exports.CryptoApi = exports.CryptoApiApiKeys = exports.VoidAuth = exports.OAuth = exports.ApiKeyAuth = exports.HttpBasicAuth = exports.SystemThreadingWaitHandle = exports.SystemThreadingCancellationToken = exports.SystemSecurityPrincipalIIdentity = exports.SystemSecurityClaimsClaimsPrincipal = exports.SystemSecurityClaimsClaimsIdentity = exports.SystemSecurityClaimsClaim = exports.SystemNetIPAddress = exports.SystemIServiceProvider = exports.SystemIOStream = exports.SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_ = exports.SystemCollectionsGenericKeyValuePair2SystemStringSystemString_ = exports.SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_ = exports.MicrosoftWin32SafeHandlesSafeWaitHandle = exports.MicrosoftODataUriParserSingleValueNode = exports.MicrosoftODataUriParserSelectItem = exports.MicrosoftODataUriParserSelectExpandClause = exports.MicrosoftODataUriParserRangeVariable = exports.MicrosoftODataUriParserOrderByClause = void 0;
exports.VaultCallbackApi = exports.VaultCallbackApiApiKeys = exports.TenantOnboardingApi = exports.TenantOnboardingApiApiKeys = exports.SignApi = exports.SignApiApiKeys = exports.SessionApi = exports.SessionApiApiKeys = exports.ScanDetectionApiApi = exports.ScanDetectionApiApiApiKeys = exports.ScanApi = exports.ScanApiApiKeys = void 0;
const localVarRequest = require("request");
const Promise = require("bluebird");
let defaultBasePath = 'https://localhost';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
class ObjectSerializer {
    static findCorrectType(data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }
    static serialize(data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }
    static deserialize(data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}
class MSEssGatewayClientContractsCipherDetailsMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsCipherDetailsMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsCipherDetailsMessage = MSEssGatewayClientContractsCipherDetailsMessage;
MSEssGatewayClientContractsCipherDetailsMessage.discriminator = undefined;
MSEssGatewayClientContractsCipherDetailsMessage.attributeTypeMap = [
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "clusterRegion",
        "baseName": "clusterRegion",
        "type": "string"
    },
    {
        "name": "correlationVector",
        "baseName": "correlationVector",
        "type": "string"
    },
    {
        "name": "releaseCompletedAt",
        "baseName": "releaseCompletedAt",
        "type": "Date"
    },
    {
        "name": "releaseInfo",
        "baseName": "releaseInfo",
        "type": "MSEssGatewayClientContractsReleaseReleaseInfo"
    },
    {
        "name": "productInfo",
        "baseName": "productInfo",
        "type": "MSEssGatewayClientContractsReleaseProductInfo"
    },
    {
        "name": "createdBy",
        "baseName": "createdBy",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    },
    {
        "name": "owners",
        "baseName": "owners",
        "type": "Array<MSEssGatewayClientContractsReleaseOwnerInfo>"
    },
    {
        "name": "approvers",
        "baseName": "approvers",
        "type": "Array<MSEssGatewayClientContractsReleaseResponseApproverInfoDetails>"
    },
    {
        "name": "authorizedDownloadUsers",
        "baseName": "authorizedDownloadUsers",
        "type": "Array<MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo>"
    },
    {
        "name": "accessPermissionsInfo",
        "baseName": "accessPermissionsInfo",
        "type": "MSEssGatewayClientContractsReleaseAccessPermissionsInfo"
    },
    {
        "name": "files",
        "baseName": "files",
        "type": "Array<MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo>"
    },
    {
        "name": "comments",
        "baseName": "comments",
        "type": "Array<string>"
    },
    {
        "name": "cancellationReason",
        "baseName": "cancellationReason",
        "type": "string"
    },
    {
        "name": "totalReleaseSize",
        "baseName": "totalReleaseSize",
        "type": "number"
    },
    {
        "name": "totalFileCount",
        "baseName": "totalFileCount",
        "type": "number"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "activities",
        "baseName": "activities",
        "type": "Array<MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo>"
    },
    {
        "name": "releaseError",
        "baseName": "releaseError",
        "type": "MSEssGatewayClientContractsReleaseResponseReleaseError"
    },
    {
        "name": "childworkflowType",
        "baseName": "childworkflowType",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsCipherDetailsMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsCipherDetailsMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsCipherDetailsMessage.StatusEnum || (MSEssGatewayClientContractsCipherDetailsMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsCipherDetailsMessage = exports.MSEssGatewayClientContractsCipherDetailsMessage || (exports.MSEssGatewayClientContractsCipherDetailsMessage = {}));
class MSEssGatewayClientContractsCipherInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsCipherInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsCipherInfo = MSEssGatewayClientContractsCipherInfo;
MSEssGatewayClientContractsCipherInfo.discriminator = undefined;
MSEssGatewayClientContractsCipherInfo.attributeTypeMap = [
    {
        "name": "cipherType",
        "baseName": "cipherType",
        "type": "MSEssGatewayClientContractsCipherInfo.CipherTypeEnum"
    },
    {
        "name": "algorithm",
        "baseName": "algorithm",
        "type": "string"
    },
    {
        "name": "parameters",
        "baseName": "parameters",
        "type": "{ [key: string]: string; }"
    }
];
(function (MSEssGatewayClientContractsCipherInfo) {
    let CipherTypeEnum;
    (function (CipherTypeEnum) {
        CipherTypeEnum[CipherTypeEnum["Encryption"] = 'encryption'] = "Encryption";
        CipherTypeEnum[CipherTypeEnum["Decryption"] = 'decryption'] = "Decryption";
    })(CipherTypeEnum = MSEssGatewayClientContractsCipherInfo.CipherTypeEnum || (MSEssGatewayClientContractsCipherInfo.CipherTypeEnum = {}));
})(MSEssGatewayClientContractsCipherInfo = exports.MSEssGatewayClientContractsCipherInfo || (exports.MSEssGatewayClientContractsCipherInfo = {}));
class MSEssGatewayClientContractsCipherResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsCipherResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsCipherResultMessage = MSEssGatewayClientContractsCipherResultMessage;
MSEssGatewayClientContractsCipherResultMessage.discriminator = undefined;
MSEssGatewayClientContractsCipherResultMessage.attributeTypeMap = [
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsCipherResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsCipherResultMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsCipherResultMessage.StatusEnum || (MSEssGatewayClientContractsCipherResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsCipherResultMessage = exports.MSEssGatewayClientContractsCipherResultMessage || (exports.MSEssGatewayClientContractsCipherResultMessage = {}));
class MSEssGatewayClientContractsCryptoFileInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsCryptoFileInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsCryptoFileInfo = MSEssGatewayClientContractsCryptoFileInfo;
MSEssGatewayClientContractsCryptoFileInfo.discriminator = undefined;
MSEssGatewayClientContractsCryptoFileInfo.attributeTypeMap = [
    {
        "name": "destinationLocation",
        "baseName": "destinationLocation",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "cryptoOperations",
        "baseName": "cryptoOperations",
        "type": "Array<MSEssGatewayClientContractsCryptoOperation>"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "hash",
        "baseName": "hash",
        "type": "string"
    },
    {
        "name": "sourceLocation",
        "baseName": "sourceLocation",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "sizeInBytes",
        "baseName": "sizeInBytes",
        "type": "number"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsCryptoFileInfo.HashTypeEnum"
    }
];
(function (MSEssGatewayClientContractsCryptoFileInfo) {
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsCryptoFileInfo.HashTypeEnum || (MSEssGatewayClientContractsCryptoFileInfo.HashTypeEnum = {}));
})(MSEssGatewayClientContractsCryptoFileInfo = exports.MSEssGatewayClientContractsCryptoFileInfo || (exports.MSEssGatewayClientContractsCryptoFileInfo = {}));
class MSEssGatewayClientContractsCryptoOperation {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsCryptoOperation.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsCryptoOperation = MSEssGatewayClientContractsCryptoOperation;
MSEssGatewayClientContractsCryptoOperation.discriminator = undefined;
MSEssGatewayClientContractsCryptoOperation.attributeTypeMap = [
    {
        "name": "primitive",
        "baseName": "primitive",
        "type": "MSEssGatewayClientContractsCryptoOperation.PrimitiveEnum"
    },
    {
        "name": "parameters",
        "baseName": "parameters",
        "type": "Array<MSEssGatewayClientContractsCryptoParameter>"
    }
];
(function (MSEssGatewayClientContractsCryptoOperation) {
    let PrimitiveEnum;
    (function (PrimitiveEnum) {
        PrimitiveEnum[PrimitiveEnum["KeyDerivation"] = 'keyDerivation'] = "KeyDerivation";
        PrimitiveEnum[PrimitiveEnum["ReDerivation"] = 'reDerivation'] = "ReDerivation";
        PrimitiveEnum[PrimitiveEnum["InPlaceEncryption"] = 'inPlaceEncryption'] = "InPlaceEncryption";
        PrimitiveEnum[PrimitiveEnum["InPlaceDecryption"] = 'inPlaceDecryption'] = "InPlaceDecryption";
        PrimitiveEnum[PrimitiveEnum["Encryption"] = 'encryption'] = "Encryption";
    })(PrimitiveEnum = MSEssGatewayClientContractsCryptoOperation.PrimitiveEnum || (MSEssGatewayClientContractsCryptoOperation.PrimitiveEnum = {}));
})(MSEssGatewayClientContractsCryptoOperation = exports.MSEssGatewayClientContractsCryptoOperation || (exports.MSEssGatewayClientContractsCryptoOperation = {}));
class MSEssGatewayClientContractsCryptoParameter {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsCryptoParameter.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsCryptoParameter = MSEssGatewayClientContractsCryptoParameter;
MSEssGatewayClientContractsCryptoParameter.discriminator = undefined;
MSEssGatewayClientContractsCryptoParameter.attributeTypeMap = [
    {
        "name": "parameterName",
        "baseName": "parameterName",
        "type": "string"
    },
    {
        "name": "parameterValue",
        "baseName": "parameterValue",
        "type": "string"
    }
];
class MSEssGatewayClientContractsCryptoRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsCryptoRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsCryptoRequestMessage = MSEssGatewayClientContractsCryptoRequestMessage;
MSEssGatewayClientContractsCryptoRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsCryptoRequestMessage.attributeTypeMap = [
    {
        "name": "cryptoOperations",
        "baseName": "cryptoOperations",
        "type": "Array<MSEssGatewayClientContractsCryptoOperation>"
    },
    {
        "name": "file",
        "baseName": "file",
        "type": "MSEssGatewayClientContractsCryptoFileInfo"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "region",
        "baseName": "region",
        "type": "MSEssGatewayClientContractsCryptoRequestMessage.RegionEnum"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "requestExpiresAt",
        "baseName": "requestExpiresAt",
        "type": "Date"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
(function (MSEssGatewayClientContractsCryptoRequestMessage) {
    let RegionEnum;
    (function (RegionEnum) {
        RegionEnum[RegionEnum["None"] = 'none'] = "None";
        RegionEnum[RegionEnum["PuertoRico"] = 'puertoRico'] = "PuertoRico";
        RegionEnum[RegionEnum["Us"] = 'us'] = "Us";
        RegionEnum[RegionEnum["Dublin"] = 'dublin'] = "Dublin";
        RegionEnum[RegionEnum["Singapore"] = 'singapore'] = "Singapore";
    })(RegionEnum = MSEssGatewayClientContractsCryptoRequestMessage.RegionEnum || (MSEssGatewayClientContractsCryptoRequestMessage.RegionEnum = {}));
})(MSEssGatewayClientContractsCryptoRequestMessage = exports.MSEssGatewayClientContractsCryptoRequestMessage || (exports.MSEssGatewayClientContractsCryptoRequestMessage = {}));
class MSEssGatewayClientContractsCryptoResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsCryptoResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsCryptoResultMessage = MSEssGatewayClientContractsCryptoResultMessage;
MSEssGatewayClientContractsCryptoResultMessage.discriminator = undefined;
MSEssGatewayClientContractsCryptoResultMessage.attributeTypeMap = [
    {
        "name": "sourceFileHash",
        "baseName": "sourceFileHash",
        "type": "string"
    },
    {
        "name": "destinationFileHash",
        "baseName": "destinationFileHash",
        "type": "string"
    },
    {
        "name": "destinationFileLocationType",
        "baseName": "destinationFileLocationType",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsCryptoResultMessage.HashTypeEnum"
    },
    {
        "name": "fileName",
        "baseName": "fileName",
        "type": "string"
    },
    {
        "name": "fileSize",
        "baseName": "fileSize",
        "type": "number"
    },
    {
        "name": "destinationFileLocation",
        "baseName": "destinationFileLocation",
        "type": "string"
    },
    {
        "name": "cryptoOperations",
        "baseName": "cryptoOperations",
        "type": "Array<MSEssGatewayClientContractsCryptoOperation>"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsCryptoResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsCryptoResultMessage) {
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsCryptoResultMessage.HashTypeEnum || (MSEssGatewayClientContractsCryptoResultMessage.HashTypeEnum = {}));
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsCryptoResultMessage.StatusEnum || (MSEssGatewayClientContractsCryptoResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsCryptoResultMessage = exports.MSEssGatewayClientContractsCryptoResultMessage || (exports.MSEssGatewayClientContractsCryptoResultMessage = {}));
class MSEssGatewayClientContractsDigestSignCertificateRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsDigestSignCertificateRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsDigestSignCertificateRequestMessage = MSEssGatewayClientContractsDigestSignCertificateRequestMessage;
MSEssGatewayClientContractsDigestSignCertificateRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsDigestSignCertificateRequestMessage.attributeTypeMap = [
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "certificateSubjectName",
        "baseName": "certificateSubjectName",
        "type": "string"
    },
    {
        "name": "certificateTemplateName",
        "baseName": "certificateTemplateName",
        "type": "string"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "requestExpiresAt",
        "baseName": "requestExpiresAt",
        "type": "Date"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
class MSEssGatewayClientContractsDigestSignCertificateResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsDigestSignCertificateResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsDigestSignCertificateResultMessage = MSEssGatewayClientContractsDigestSignCertificateResultMessage;
MSEssGatewayClientContractsDigestSignCertificateResultMessage.discriminator = undefined;
MSEssGatewayClientContractsDigestSignCertificateResultMessage.attributeTypeMap = [
    {
        "name": "certificate",
        "baseName": "certificate",
        "type": "string"
    },
    {
        "name": "keyCode",
        "baseName": "keyCode",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsDigestSignCertificateResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsDigestSignCertificateResultMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsDigestSignCertificateResultMessage.StatusEnum || (MSEssGatewayClientContractsDigestSignCertificateResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsDigestSignCertificateResultMessage = exports.MSEssGatewayClientContractsDigestSignCertificateResultMessage || (exports.MSEssGatewayClientContractsDigestSignCertificateResultMessage = {}));
class MSEssGatewayClientContractsDigestSignMapping {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsDigestSignMapping.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsDigestSignMapping = MSEssGatewayClientContractsDigestSignMapping;
MSEssGatewayClientContractsDigestSignMapping.discriminator = undefined;
MSEssGatewayClientContractsDigestSignMapping.attributeTypeMap = [
    {
        "name": "operationTemplates",
        "baseName": "operationTemplates",
        "type": "Array<MSEssGatewayClientContractsOperationTemplate>"
    },
    {
        "name": "keyCodes",
        "baseName": "keyCodes",
        "type": "Array<string>"
    }
];
class MSEssGatewayClientContractsDigestSignOperationErrorPatterns {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsDigestSignOperationErrorPatterns.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsDigestSignOperationErrorPatterns = MSEssGatewayClientContractsDigestSignOperationErrorPatterns;
MSEssGatewayClientContractsDigestSignOperationErrorPatterns.discriminator = undefined;
MSEssGatewayClientContractsDigestSignOperationErrorPatterns.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "number"
    },
    {
        "name": "operationCodes",
        "baseName": "operationCodes",
        "type": "Array<string>"
    },
    {
        "name": "signtoolOutputRegexPattern",
        "baseName": "signtoolOutputRegexPattern",
        "type": "string"
    },
    {
        "name": "statusCode",
        "baseName": "statusCode",
        "type": "MSEssGatewayClientContractsDigestSignOperationErrorPatterns.StatusCodeEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    }
];
(function (MSEssGatewayClientContractsDigestSignOperationErrorPatterns) {
    let StatusCodeEnum;
    (function (StatusCodeEnum) {
        StatusCodeEnum[StatusCodeEnum["Pass"] = 'pass'] = "Pass";
        StatusCodeEnum[StatusCodeEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusCodeEnum[StatusCodeEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusCodeEnum[StatusCodeEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusCodeEnum[StatusCodeEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusCodeEnum[StatusCodeEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusCodeEnum = MSEssGatewayClientContractsDigestSignOperationErrorPatterns.StatusCodeEnum || (MSEssGatewayClientContractsDigestSignOperationErrorPatterns.StatusCodeEnum = {}));
})(MSEssGatewayClientContractsDigestSignOperationErrorPatterns = exports.MSEssGatewayClientContractsDigestSignOperationErrorPatterns || (exports.MSEssGatewayClientContractsDigestSignOperationErrorPatterns = {}));
class MSEssGatewayClientContractsDynamicSigningOperation {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsDynamicSigningOperation.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsDynamicSigningOperation = MSEssGatewayClientContractsDynamicSigningOperation;
MSEssGatewayClientContractsDynamicSigningOperation.discriminator = undefined;
MSEssGatewayClientContractsDynamicSigningOperation.attributeTypeMap = [
    {
        "name": "certificateSubjectName",
        "baseName": "certificateSubjectName",
        "type": "string"
    },
    {
        "name": "certificateTemplateName",
        "baseName": "certificateTemplateName",
        "type": "string"
    },
    {
        "name": "keyCode",
        "baseName": "keyCode",
        "type": "string"
    },
    {
        "name": "operationSetCode",
        "baseName": "operationSetCode",
        "type": "string"
    },
    {
        "name": "parameters",
        "baseName": "parameters",
        "type": "Array<MSEssGatewayClientContractsSigningParameter>"
    },
    {
        "name": "toolName",
        "baseName": "toolName",
        "type": "string"
    },
    {
        "name": "toolVersion",
        "baseName": "toolVersion",
        "type": "string"
    }
];
class MSEssGatewayClientContractsEsrpClientConfigInfo3 {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsEsrpClientConfigInfo3.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsEsrpClientConfigInfo3 = MSEssGatewayClientContractsEsrpClientConfigInfo3;
MSEssGatewayClientContractsEsrpClientConfigInfo3.discriminator = undefined;
MSEssGatewayClientContractsEsrpClientConfigInfo3.attributeTypeMap = [
    {
        "name": "eventHubTelemetryConnectionShard",
        "baseName": "eventHubTelemetryConnectionShard",
        "type": "Array<MSEssGatewayClientContractsEventHubTelemetryConnectionShard>"
    },
    {
        "name": "apiBaseUri",
        "baseName": "apiBaseUri",
        "type": "string"
    },
    {
        "name": "sessionTimeout",
        "baseName": "sessionTimeout",
        "type": "string"
    },
    {
        "name": "maxDegreeOfParallelism",
        "baseName": "maxDegreeOfParallelism",
        "type": "number"
    },
    {
        "name": "servicePointManagerDefaultConnectionLimit",
        "baseName": "servicePointManagerDefaultConnectionLimit",
        "type": "number"
    },
    {
        "name": "exponentialFirstFastRetry",
        "baseName": "exponentialFirstFastRetry",
        "type": "boolean"
    },
    {
        "name": "exponentialRetryCount",
        "baseName": "exponentialRetryCount",
        "type": "number"
    },
    {
        "name": "exponentialRetryMinBackOff",
        "baseName": "exponentialRetryMinBackOff",
        "type": "string"
    },
    {
        "name": "exponentialRetryMaxBackOff",
        "baseName": "exponentialRetryMaxBackOff",
        "type": "string"
    },
    {
        "name": "exponentialRetryDeltaBackOff",
        "baseName": "exponentialRetryDeltaBackOff",
        "type": "string"
    },
    {
        "name": "slaFor0MbTo5Mb",
        "baseName": "slaFor0MbTo5Mb",
        "type": "string"
    },
    {
        "name": "slaFor5MbTo50Mb",
        "baseName": "slaFor5MbTo50Mb",
        "type": "string"
    },
    {
        "name": "slaFor50MbTo250Mb",
        "baseName": "slaFor50MbTo250Mb",
        "type": "string"
    },
    {
        "name": "slaFor250MbTo500Mb",
        "baseName": "slaFor250MbTo500Mb",
        "type": "string"
    },
    {
        "name": "slaFor500MbTo1Gb",
        "baseName": "slaFor500MbTo1Gb",
        "type": "string"
    },
    {
        "name": "slaFor1GbTo4Gb",
        "baseName": "slaFor1GbTo4Gb",
        "type": "string"
    },
    {
        "name": "slaFor4GbTo16Gb",
        "baseName": "slaFor4GbTo16Gb",
        "type": "string"
    },
    {
        "name": "slaFor16GbTo32Gb",
        "baseName": "slaFor16GbTo32Gb",
        "type": "string"
    },
    {
        "name": "slaFor32GbTo50Gb",
        "baseName": "slaFor32GbTo50Gb",
        "type": "string"
    },
    {
        "name": "slaFor50GbTo100Gb",
        "baseName": "slaFor50GbTo100Gb",
        "type": "string"
    },
    {
        "name": "slaFor100GbTo150Gb",
        "baseName": "slaFor100GbTo150Gb",
        "type": "string"
    },
    {
        "name": "exitOnFlaggedFile",
        "baseName": "exitOnFlaggedFile",
        "type": "boolean"
    },
    {
        "name": "flaggedFileClientWaitTimeout",
        "baseName": "flaggedFileClientWaitTimeout",
        "type": "string"
    }
];
class MSEssGatewayClientContractsEventHubTelemetryConnectionShard {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsEventHubTelemetryConnectionShard.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsEventHubTelemetryConnectionShard = MSEssGatewayClientContractsEventHubTelemetryConnectionShard;
MSEssGatewayClientContractsEventHubTelemetryConnectionShard.discriminator = undefined;
MSEssGatewayClientContractsEventHubTelemetryConnectionShard.attributeTypeMap = [
    {
        "name": "connectionString",
        "baseName": "connectionString",
        "type": "string"
    },
    {
        "name": "lowKey",
        "baseName": "lowKey",
        "type": "number"
    },
    {
        "name": "highKey",
        "baseName": "highKey",
        "type": "number"
    }
];
class MSEssGatewayClientContractsFileLocation {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsFileLocation.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsFileLocation = MSEssGatewayClientContractsFileLocation;
MSEssGatewayClientContractsFileLocation.discriminator = undefined;
MSEssGatewayClientContractsFileLocation.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "type",
        "type": "MSEssGatewayClientContractsFileLocation.TypeEnum"
    },
    {
        "name": "blobUrl",
        "baseName": "blobUrl",
        "type": "string"
    },
    {
        "name": "bloburl",
        "baseName": "bloburl",
        "type": "string"
    },
    {
        "name": "uncPath",
        "baseName": "uncPath",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsFileLocation) {
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["AzureBlob"] = 'azureBlob'] = "AzureBlob";
        TypeEnum[TypeEnum["Unc"] = 'unc'] = "Unc";
    })(TypeEnum = MSEssGatewayClientContractsFileLocation.TypeEnum || (MSEssGatewayClientContractsFileLocation.TypeEnum = {}));
})(MSEssGatewayClientContractsFileLocation = exports.MSEssGatewayClientContractsFileLocation || (exports.MSEssGatewayClientContractsFileLocation = {}));
class MSEssGatewayClientContractsFileTransferFileTransferResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsFileTransferFileTransferResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsFileTransferFileTransferResultMessage = MSEssGatewayClientContractsFileTransferFileTransferResultMessage;
MSEssGatewayClientContractsFileTransferFileTransferResultMessage.discriminator = undefined;
MSEssGatewayClientContractsFileTransferFileTransferResultMessage.attributeTypeMap = [
    {
        "name": "fileName",
        "baseName": "fileName",
        "type": "string"
    },
    {
        "name": "sizeInBytes",
        "baseName": "sizeInBytes",
        "type": "number"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsFileTransferFileTransferResultMessage.HashTypeEnum"
    },
    {
        "name": "sourceFileHash",
        "baseName": "sourceFileHash",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsFileTransferFileTransferResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsFileTransferFileTransferResultMessage) {
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsFileTransferFileTransferResultMessage.HashTypeEnum || (MSEssGatewayClientContractsFileTransferFileTransferResultMessage.HashTypeEnum = {}));
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsFileTransferFileTransferResultMessage.StatusEnum || (MSEssGatewayClientContractsFileTransferFileTransferResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsFileTransferFileTransferResultMessage = exports.MSEssGatewayClientContractsFileTransferFileTransferResultMessage || (exports.MSEssGatewayClientContractsFileTransferFileTransferResultMessage = {}));
class MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult = MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult;
MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.discriminator = undefined;
MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.attributeTypeMap = [
    {
        "name": "fileId",
        "baseName": "fileId",
        "type": "string"
    },
    {
        "name": "fileSizeInBytes",
        "baseName": "fileSizeInBytes",
        "type": "number"
    },
    {
        "name": "fileHash",
        "baseName": "fileHash",
        "type": "string"
    },
    {
        "name": "fileStatus",
        "baseName": "fileStatus",
        "type": "MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.FileStatusEnum"
    },
    {
        "name": "hashOfHashes",
        "baseName": "hashOfHashes",
        "type": "string"
    },
    {
        "name": "fileErrorInfo",
        "baseName": "fileErrorInfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    }
];
(function (MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult) {
    let FileStatusEnum;
    (function (FileStatusEnum) {
        FileStatusEnum[FileStatusEnum["Pass"] = 'pass'] = "Pass";
        FileStatusEnum[FileStatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        FileStatusEnum[FileStatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        FileStatusEnum[FileStatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        FileStatusEnum[FileStatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        FileStatusEnum[FileStatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(FileStatusEnum = MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.FileStatusEnum || (MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.FileStatusEnum = {}));
})(MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult = exports.MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult || (exports.MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult = {}));
class MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage = MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage;
MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.discriminator = undefined;
MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.attributeTypeMap = [
    {
        "name": "sourceFileName",
        "baseName": "sourceFileName",
        "type": "string"
    },
    {
        "name": "destinationHashType",
        "baseName": "destinationHashType",
        "type": "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.DestinationHashTypeEnum"
    },
    {
        "name": "pieceHashFileResults",
        "baseName": "pieceHashFileResults",
        "type": "Array<MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult>"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage) {
    let DestinationHashTypeEnum;
    (function (DestinationHashTypeEnum) {
        DestinationHashTypeEnum[DestinationHashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        DestinationHashTypeEnum[DestinationHashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(DestinationHashTypeEnum = MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.DestinationHashTypeEnum || (MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.DestinationHashTypeEnum = {}));
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.StatusEnum || (MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage = exports.MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage || (exports.MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage = {}));
class MSEssGatewayClientContractsGatewayError {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsGatewayError.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsGatewayError = MSEssGatewayClientContractsGatewayError;
MSEssGatewayClientContractsGatewayError.discriminator = undefined;
MSEssGatewayClientContractsGatewayError.attributeTypeMap = [
    {
        "name": "code",
        "baseName": "code",
        "type": "string"
    },
    {
        "name": "message",
        "baseName": "message",
        "type": "string"
    },
    {
        "name": "target",
        "baseName": "target",
        "type": "string"
    },
    {
        "name": "innerError",
        "baseName": "innerError",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    }
];
class MSEssGatewayClientContractsIFeature {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsIFeature.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsIFeature = MSEssGatewayClientContractsIFeature;
MSEssGatewayClientContractsIFeature.discriminator = undefined;
MSEssGatewayClientContractsIFeature.attributeTypeMap = [
    {
        "name": "featureType",
        "baseName": "featureType",
        "type": "MSEssGatewayClientContractsIFeature.FeatureTypeEnum"
    }
];
(function (MSEssGatewayClientContractsIFeature) {
    let FeatureTypeEnum;
    (function (FeatureTypeEnum) {
        FeatureTypeEnum[FeatureTypeEnum["None"] = 'None'] = "None";
        FeatureTypeEnum[FeatureTypeEnum["Callback"] = 'Callback'] = "Callback";
    })(FeatureTypeEnum = MSEssGatewayClientContractsIFeature.FeatureTypeEnum || (MSEssGatewayClientContractsIFeature.FeatureTypeEnum = {}));
})(MSEssGatewayClientContractsIFeature = exports.MSEssGatewayClientContractsIFeature || (exports.MSEssGatewayClientContractsIFeature = {}));
class MSEssGatewayClientContractsInnerServiceError {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsInnerServiceError.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsInnerServiceError = MSEssGatewayClientContractsInnerServiceError;
MSEssGatewayClientContractsInnerServiceError.discriminator = undefined;
MSEssGatewayClientContractsInnerServiceError.attributeTypeMap = [
    {
        "name": "code",
        "baseName": "code",
        "type": "string"
    },
    {
        "name": "details",
        "baseName": "details",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "innerError",
        "baseName": "innerError",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    }
];
class MSEssGatewayClientContractsLegacyCopsMappingData {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsLegacyCopsMappingData.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsLegacyCopsMappingData = MSEssGatewayClientContractsLegacyCopsMappingData;
MSEssGatewayClientContractsLegacyCopsMappingData.discriminator = undefined;
MSEssGatewayClientContractsLegacyCopsMappingData.attributeTypeMap = [
    {
        "name": "copsId",
        "baseName": "copsId",
        "type": "string"
    },
    {
        "name": "staticOperations",
        "baseName": "staticOperations",
        "type": "Array<MSEssGatewayClientContractsStaticSigningOperation>"
    },
    {
        "name": "dynamicOperations",
        "baseName": "dynamicOperations",
        "type": "Array<MSEssGatewayClientContractsDynamicSigningOperation>"
    }
];
class MSEssGatewayClientContractsOperationResponse {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsOperationResponse.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsOperationResponse = MSEssGatewayClientContractsOperationResponse;
MSEssGatewayClientContractsOperationResponse.discriminator = undefined;
MSEssGatewayClientContractsOperationResponse.attributeTypeMap = [
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "error",
        "baseName": "error",
        "type": "MSEssGatewayClientContractsGatewayError"
    },
    {
        "name": "statusLocation",
        "baseName": "statusLocation",
        "type": "string"
    }
];
class MSEssGatewayClientContractsOperationTemplate {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsOperationTemplate.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsOperationTemplate = MSEssGatewayClientContractsOperationTemplate;
MSEssGatewayClientContractsOperationTemplate.discriminator = undefined;
MSEssGatewayClientContractsOperationTemplate.attributeTypeMap = [
    {
        "name": "operationCode",
        "baseName": "operationCode",
        "type": "string"
    },
    {
        "name": "toolFilename",
        "baseName": "toolFilename",
        "type": "string"
    },
    {
        "name": "toolArgumentTemplate",
        "baseName": "toolArgumentTemplate",
        "type": "string"
    },
    {
        "name": "isCertificateRequired",
        "baseName": "isCertificateRequired",
        "type": "boolean"
    },
    {
        "name": "requiredVerifyOperationCode",
        "baseName": "requiredVerifyOperationCode",
        "type": "string"
    }
];
class MSEssGatewayClientContractsPKITACertificateClmApprovalInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPKITACertificateClmApprovalInfo = MSEssGatewayClientContractsPKITACertificateClmApprovalInfo;
MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.discriminator = undefined;
MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.attributeTypeMap = [
    {
        "name": "user",
        "baseName": "user",
        "type": "string"
    },
    {
        "name": "approverType",
        "baseName": "approverType",
        "type": "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApproverTypeEnum"
    },
    {
        "name": "approvalStatus",
        "baseName": "approvalStatus",
        "type": "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApprovalStatusEnum"
    },
    {
        "name": "approvalDateTime",
        "baseName": "approvalDateTime",
        "type": "Date"
    },
    {
        "name": "comment",
        "baseName": "comment",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsPKITACertificateClmApprovalInfo) {
    let ApproverTypeEnum;
    (function (ApproverTypeEnum) {
        ApproverTypeEnum[ApproverTypeEnum["PreApprover"] = 'preApprover'] = "PreApprover";
        ApproverTypeEnum[ApproverTypeEnum["ProductGroupApprover"] = 'productGroupApprover'] = "ProductGroupApprover";
        ApproverTypeEnum[ApproverTypeEnum["PkiAdminApprover"] = 'pkiAdminApprover'] = "PkiAdminApprover";
        ApproverTypeEnum[ApproverTypeEnum["System"] = 'system'] = "System";
    })(ApproverTypeEnum = MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApproverTypeEnum || (MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApproverTypeEnum = {}));
    let ApprovalStatusEnum;
    (function (ApprovalStatusEnum) {
        ApprovalStatusEnum[ApprovalStatusEnum["Approved"] = 'approved'] = "Approved";
        ApprovalStatusEnum[ApprovalStatusEnum["Rejected"] = 'rejected'] = "Rejected";
    })(ApprovalStatusEnum = MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApprovalStatusEnum || (MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApprovalStatusEnum = {}));
})(MSEssGatewayClientContractsPKITACertificateClmApprovalInfo = exports.MSEssGatewayClientContractsPKITACertificateClmApprovalInfo || (exports.MSEssGatewayClientContractsPKITACertificateClmApprovalInfo = {}));
class MSEssGatewayClientContractsPKITACertificateCsrFile {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPKITACertificateCsrFile.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPKITACertificateCsrFile = MSEssGatewayClientContractsPKITACertificateCsrFile;
MSEssGatewayClientContractsPKITACertificateCsrFile.discriminator = undefined;
MSEssGatewayClientContractsPKITACertificateCsrFile.attributeTypeMap = [
    {
        "name": "csrId",
        "baseName": "csrId",
        "type": "string"
    },
    {
        "name": "content",
        "baseName": "content",
        "type": "string"
    }
];
class MSEssGatewayClientContractsPKITACertificateFailedCsrFile {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPKITACertificateFailedCsrFile.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPKITACertificateFailedCsrFile = MSEssGatewayClientContractsPKITACertificateFailedCsrFile;
MSEssGatewayClientContractsPKITACertificateFailedCsrFile.discriminator = undefined;
MSEssGatewayClientContractsPKITACertificateFailedCsrFile.attributeTypeMap = [
    {
        "name": "csrId",
        "baseName": "csrId",
        "type": "string"
    },
    {
        "name": "errorMessage",
        "baseName": "errorMessage",
        "type": "string"
    }
];
class MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage = MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage;
MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage.attributeTypeMap = [
    {
        "name": "certificateAuthorityGroupId",
        "baseName": "certificateAuthorityGroupId",
        "type": "string"
    },
    {
        "name": "certificateTemplateId",
        "baseName": "certificateTemplateId",
        "type": "string"
    },
    {
        "name": "csrFiles",
        "baseName": "csrFiles",
        "type": "Array<MSEssGatewayClientContractsPKITACertificateCsrFile>"
    },
    {
        "name": "certificateFileType",
        "baseName": "certificateFileType",
        "type": "string"
    },
    {
        "name": "certificateOwnerIds",
        "baseName": "certificateOwnerIds",
        "type": "Array<string>"
    },
    {
        "name": "usageStatement",
        "baseName": "usageStatement",
        "type": "string"
    },
    {
        "name": "validityToPeriod",
        "baseName": "validityToPeriod",
        "type": "Date"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
class MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage = MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage;
MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.discriminator = undefined;
MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.attributeTypeMap = [
    {
        "name": "certificates",
        "baseName": "certificates",
        "type": "Array<MSEssGatewayClientContractsPkitaCertificateCertificateInfo>"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "failedCsrFiles",
        "baseName": "failedCsrFiles",
        "type": "Array<MSEssGatewayClientContractsPKITACertificateFailedCsrFile>"
    },
    {
        "name": "istrusted",
        "baseName": "istrusted",
        "type": "boolean"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.StatusEnum || (MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage = exports.MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage || (exports.MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage = {}));
class MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage = MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage;
MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.discriminator = undefined;
MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.attributeTypeMap = [
    {
        "name": "pkitaCertificateRequestMessageJwtToken",
        "baseName": "pkitaCertificateRequestMessageJwtToken",
        "type": "string"
    },
    {
        "name": "submissionOperationId",
        "baseName": "submissionOperationId",
        "type": "string"
    },
    {
        "name": "approvalStatus",
        "baseName": "approvalStatus",
        "type": "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.ApprovalStatusEnum"
    },
    {
        "name": "approvalInfo",
        "baseName": "approvalInfo",
        "type": "Array<MSEssGatewayClientContractsPKITACertificateClmApprovalInfo>"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
(function (MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage) {
    let ApprovalStatusEnum;
    (function (ApprovalStatusEnum) {
        ApprovalStatusEnum[ApprovalStatusEnum["Approved"] = 'approved'] = "Approved";
        ApprovalStatusEnum[ApprovalStatusEnum["Rejected"] = 'rejected'] = "Rejected";
    })(ApprovalStatusEnum = MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.ApprovalStatusEnum || (MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.ApprovalStatusEnum = {}));
})(MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage = exports.MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage || (exports.MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage = {}));
class MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage = MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage;
MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage.attributeTypeMap = [
    {
        "name": "approvalInfo",
        "baseName": "approvalInfo",
        "type": "Array<MSEssGatewayClientContractsPKITACertificateClmApprovalInfo>"
    },
    {
        "name": "clmClientId",
        "baseName": "clmClientId",
        "type": "string"
    },
    {
        "name": "policyResponseJwt",
        "baseName": "policyResponseJwt",
        "type": "string"
    },
    {
        "name": "validityDuration",
        "baseName": "validityDuration",
        "type": "MSEssGatewayClientContractsPKITACertificateValidityDuration"
    },
    {
        "name": "policyExtensions",
        "baseName": "policyExtensions",
        "type": "Array<MSEssGatewayClientContractsPKITACertificatePolicyExtension>"
    },
    {
        "name": "previousOperationIds",
        "baseName": "previousOperationIds",
        "type": "Array<string>"
    },
    {
        "name": "certificateAuthorityGroupId",
        "baseName": "certificateAuthorityGroupId",
        "type": "string"
    },
    {
        "name": "certificateTemplateId",
        "baseName": "certificateTemplateId",
        "type": "string"
    },
    {
        "name": "csrFiles",
        "baseName": "csrFiles",
        "type": "Array<MSEssGatewayClientContractsPKITACertificateCsrFile>"
    },
    {
        "name": "certificateFileType",
        "baseName": "certificateFileType",
        "type": "string"
    },
    {
        "name": "certificateOwnerIds",
        "baseName": "certificateOwnerIds",
        "type": "Array<string>"
    },
    {
        "name": "usageStatement",
        "baseName": "usageStatement",
        "type": "string"
    },
    {
        "name": "validityToPeriod",
        "baseName": "validityToPeriod",
        "type": "Date"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
class MSEssGatewayClientContractsPKITACertificatePolicyExtension {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPKITACertificatePolicyExtension.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPKITACertificatePolicyExtension = MSEssGatewayClientContractsPKITACertificatePolicyExtension;
MSEssGatewayClientContractsPKITACertificatePolicyExtension.discriminator = undefined;
MSEssGatewayClientContractsPKITACertificatePolicyExtension.attributeTypeMap = [
    {
        "name": "extensionType",
        "baseName": "extensionType",
        "type": "string"
    },
    {
        "name": "extensionValue",
        "baseName": "extensionValue",
        "type": "string"
    },
    {
        "name": "isCritical",
        "baseName": "isCritical",
        "type": "boolean"
    },
    {
        "name": "oid",
        "baseName": "oid",
        "type": "string"
    },
    {
        "name": "asnBlob",
        "baseName": "asnBlob",
        "type": "string"
    }
];
class MSEssGatewayClientContractsPKITACertificateValidityDuration {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPKITACertificateValidityDuration.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPKITACertificateValidityDuration = MSEssGatewayClientContractsPKITACertificateValidityDuration;
MSEssGatewayClientContractsPKITACertificateValidityDuration.discriminator = undefined;
MSEssGatewayClientContractsPKITACertificateValidityDuration.attributeTypeMap = [
    {
        "name": "years",
        "baseName": "years",
        "type": "number"
    },
    {
        "name": "months",
        "baseName": "months",
        "type": "number"
    },
    {
        "name": "days",
        "baseName": "days",
        "type": "number"
    }
];
class MSEssGatewayClientContractsPkitaCertificateCertificateInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPkitaCertificateCertificateInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPkitaCertificateCertificateInfo = MSEssGatewayClientContractsPkitaCertificateCertificateInfo;
MSEssGatewayClientContractsPkitaCertificateCertificateInfo.discriminator = undefined;
MSEssGatewayClientContractsPkitaCertificateCertificateInfo.attributeTypeMap = [
    {
        "name": "csrId",
        "baseName": "csrId",
        "type": "string"
    },
    {
        "name": "certificateBlob",
        "baseName": "certificateBlob",
        "type": "string"
    },
    {
        "name": "certificateP7BBlob",
        "baseName": "certificateP7BBlob",
        "type": "string"
    },
    {
        "name": "isMisIssue",
        "baseName": "isMisIssue",
        "type": "boolean"
    },
    {
        "name": "notes",
        "baseName": "notes",
        "type": "string"
    }
];
class MSEssGatewayClientContractsPolicy {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPolicy.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPolicy = MSEssGatewayClientContractsPolicy;
MSEssGatewayClientContractsPolicy.discriminator = undefined;
MSEssGatewayClientContractsPolicy.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "workflowExecutionType",
        "baseName": "workflowExecutionType",
        "type": "MSEssGatewayClientContractsPolicy.WorkflowExecutionTypeEnum"
    }
];
(function (MSEssGatewayClientContractsPolicy) {
    let WorkflowExecutionTypeEnum;
    (function (WorkflowExecutionTypeEnum) {
        WorkflowExecutionTypeEnum[WorkflowExecutionTypeEnum["EmbedSign"] = 'embedSign'] = "EmbedSign";
        WorkflowExecutionTypeEnum[WorkflowExecutionTypeEnum["DigestSignAndLazyScan"] = 'digestSignAndLazyScan'] = "DigestSignAndLazyScan";
        WorkflowExecutionTypeEnum[WorkflowExecutionTypeEnum["EmbedSignAndLazyScan"] = 'embedSignAndLazyScan'] = "EmbedSignAndLazyScan";
        WorkflowExecutionTypeEnum[WorkflowExecutionTypeEnum["DigestSign"] = 'digestSign'] = "DigestSign";
        WorkflowExecutionTypeEnum[WorkflowExecutionTypeEnum["AdtDigestSign"] = 'adtDigestSign'] = "AdtDigestSign";
    })(WorkflowExecutionTypeEnum = MSEssGatewayClientContractsPolicy.WorkflowExecutionTypeEnum || (MSEssGatewayClientContractsPolicy.WorkflowExecutionTypeEnum = {}));
})(MSEssGatewayClientContractsPolicy = exports.MSEssGatewayClientContractsPolicy || (exports.MSEssGatewayClientContractsPolicy = {}));
class MSEssGatewayClientContractsPolicyResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsPolicyResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsPolicyResultMessage = MSEssGatewayClientContractsPolicyResultMessage;
MSEssGatewayClientContractsPolicyResultMessage.discriminator = undefined;
MSEssGatewayClientContractsPolicyResultMessage.attributeTypeMap = [
    {
        "name": "policy",
        "baseName": "policy",
        "type": "MSEssGatewayClientContractsPolicy"
    }
];
class MSEssGatewayClientContractsProvisionStorageRequest {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsProvisionStorageRequest.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsProvisionStorageRequest = MSEssGatewayClientContractsProvisionStorageRequest;
MSEssGatewayClientContractsProvisionStorageRequest.discriminator = undefined;
MSEssGatewayClientContractsProvisionStorageRequest.attributeTypeMap = [
    {
        "name": "expiresAfter",
        "baseName": "expiresAfter",
        "type": "string"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "partitionCount",
        "baseName": "partitionCount",
        "type": "number"
    }
];
class MSEssGatewayClientContractsProvisionStorageResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsProvisionStorageResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsProvisionStorageResultMessage = MSEssGatewayClientContractsProvisionStorageResultMessage;
MSEssGatewayClientContractsProvisionStorageResultMessage.discriminator = undefined;
MSEssGatewayClientContractsProvisionStorageResultMessage.attributeTypeMap = [
    {
        "name": "storageShards",
        "baseName": "storageShards",
        "type": "Array<MSEssGatewayClientContractsStorageShard>"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsProvisionStorageResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsProvisionStorageResultMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsProvisionStorageResultMessage.StatusEnum || (MSEssGatewayClientContractsProvisionStorageResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsProvisionStorageResultMessage = exports.MSEssGatewayClientContractsProvisionStorageResultMessage || (exports.MSEssGatewayClientContractsProvisionStorageResultMessage = {}));
class MSEssGatewayClientContractsReleaseAccessPermissionsInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseAccessPermissionsInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseAccessPermissionsInfo = MSEssGatewayClientContractsReleaseAccessPermissionsInfo;
MSEssGatewayClientContractsReleaseAccessPermissionsInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseAccessPermissionsInfo.attributeTypeMap = [
    {
        "name": "mainPublisher",
        "baseName": "mainPublisher",
        "type": "string"
    },
    {
        "name": "releasePublishers",
        "baseName": "releasePublishers",
        "type": "Array<string>"
    },
    {
        "name": "channelDownloadEntityDetails",
        "baseName": "channelDownloadEntityDetails",
        "type": "{ [key: string]: Array<string>; }"
    }
];
class MSEssGatewayClientContractsReleaseApproverInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseApproverInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseApproverInfo = MSEssGatewayClientContractsReleaseApproverInfo;
MSEssGatewayClientContractsReleaseApproverInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseApproverInfo.attributeTypeMap = [
    {
        "name": "approver",
        "baseName": "approver",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    },
    {
        "name": "isAutoApproved",
        "baseName": "isAutoApproved",
        "type": "boolean"
    },
    {
        "name": "isMandatory",
        "baseName": "isMandatory",
        "type": "boolean"
    }
];
class MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo = MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo;
MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo.attributeTypeMap = [
    {
        "name": "authorizedDownloadUser",
        "baseName": "authorizedDownloadUser",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    }
];
class MSEssGatewayClientContractsReleaseEditApproverInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseEditApproverInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseEditApproverInfo = MSEssGatewayClientContractsReleaseEditApproverInfo;
MSEssGatewayClientContractsReleaseEditApproverInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseEditApproverInfo.attributeTypeMap = [
    {
        "name": "action",
        "baseName": "action",
        "type": "MSEssGatewayClientContractsReleaseEditApproverInfo.ActionEnum"
    },
    {
        "name": "approver",
        "baseName": "approver",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    },
    {
        "name": "isAutoApproved",
        "baseName": "isAutoApproved",
        "type": "boolean"
    },
    {
        "name": "isMandatory",
        "baseName": "isMandatory",
        "type": "boolean"
    }
];
(function (MSEssGatewayClientContractsReleaseEditApproverInfo) {
    let ActionEnum;
    (function (ActionEnum) {
        ActionEnum[ActionEnum["Add"] = 'add'] = "Add";
        ActionEnum[ActionEnum["Remove"] = 'remove'] = "Remove";
    })(ActionEnum = MSEssGatewayClientContractsReleaseEditApproverInfo.ActionEnum || (MSEssGatewayClientContractsReleaseEditApproverInfo.ActionEnum = {}));
})(MSEssGatewayClientContractsReleaseEditApproverInfo = exports.MSEssGatewayClientContractsReleaseEditApproverInfo || (exports.MSEssGatewayClientContractsReleaseEditApproverInfo = {}));
class MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo = MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo;
MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.attributeTypeMap = [
    {
        "name": "action",
        "baseName": "action",
        "type": "MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.ActionEnum"
    },
    {
        "name": "authorizedDownloadUser",
        "baseName": "authorizedDownloadUser",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    }
];
(function (MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo) {
    let ActionEnum;
    (function (ActionEnum) {
        ActionEnum[ActionEnum["Add"] = 'add'] = "Add";
        ActionEnum[ActionEnum["Remove"] = 'remove'] = "Remove";
    })(ActionEnum = MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.ActionEnum || (MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.ActionEnum = {}));
})(MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo = exports.MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo || (exports.MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo = {}));
class MSEssGatewayClientContractsReleaseEditChannelDownloadEntity {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseEditChannelDownloadEntity = MSEssGatewayClientContractsReleaseEditChannelDownloadEntity;
MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.discriminator = undefined;
MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.attributeTypeMap = [
    {
        "name": "channelDownloadEntityDetails",
        "baseName": "channelDownloadEntityDetails",
        "type": "{ [key: string]: Array<string>; }"
    },
    {
        "name": "action",
        "baseName": "action",
        "type": "MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.ActionEnum"
    }
];
(function (MSEssGatewayClientContractsReleaseEditChannelDownloadEntity) {
    let ActionEnum;
    (function (ActionEnum) {
        ActionEnum[ActionEnum["Add"] = 'add'] = "Add";
        ActionEnum[ActionEnum["Remove"] = 'remove'] = "Remove";
    })(ActionEnum = MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.ActionEnum || (MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.ActionEnum = {}));
})(MSEssGatewayClientContractsReleaseEditChannelDownloadEntity = exports.MSEssGatewayClientContractsReleaseEditChannelDownloadEntity || (exports.MSEssGatewayClientContractsReleaseEditChannelDownloadEntity = {}));
class MSEssGatewayClientContractsReleaseEditOwnerInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseEditOwnerInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseEditOwnerInfo = MSEssGatewayClientContractsReleaseEditOwnerInfo;
MSEssGatewayClientContractsReleaseEditOwnerInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseEditOwnerInfo.attributeTypeMap = [
    {
        "name": "action",
        "baseName": "action",
        "type": "MSEssGatewayClientContractsReleaseEditOwnerInfo.ActionEnum"
    },
    {
        "name": "owner",
        "baseName": "owner",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    }
];
(function (MSEssGatewayClientContractsReleaseEditOwnerInfo) {
    let ActionEnum;
    (function (ActionEnum) {
        ActionEnum[ActionEnum["Add"] = 'add'] = "Add";
        ActionEnum[ActionEnum["Remove"] = 'remove'] = "Remove";
    })(ActionEnum = MSEssGatewayClientContractsReleaseEditOwnerInfo.ActionEnum || (MSEssGatewayClientContractsReleaseEditOwnerInfo.ActionEnum = {}));
})(MSEssGatewayClientContractsReleaseEditOwnerInfo = exports.MSEssGatewayClientContractsReleaseEditOwnerInfo || (exports.MSEssGatewayClientContractsReleaseEditOwnerInfo = {}));
class MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus = MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus;
MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.discriminator = undefined;
MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.attributeTypeMap = [
    {
        "name": "statusCode",
        "baseName": "statusCode",
        "type": "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.StatusCodeEnum"
    },
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "number"
    },
    {
        "name": "errorInfo",
        "baseName": "errorInfo",
        "type": "string"
    },
    {
        "name": "cipherType",
        "baseName": "cipherType",
        "type": "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.CipherTypeEnum"
    },
    {
        "name": "algorithmName",
        "baseName": "algorithmName",
        "type": "string"
    },
    {
        "name": "sizeInBytes",
        "baseName": "sizeInBytes",
        "type": "number"
    },
    {
        "name": "destinationLocation",
        "baseName": "destinationLocation",
        "type": "string"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.HashTypeEnum"
    },
    {
        "name": "destinationHash",
        "baseName": "destinationHash",
        "type": "string"
    },
    {
        "name": "parameters",
        "baseName": "parameters",
        "type": "{ [key: string]: string; }"
    }
];
(function (MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus) {
    let StatusCodeEnum;
    (function (StatusCodeEnum) {
        StatusCodeEnum[StatusCodeEnum["Pass"] = 'pass'] = "Pass";
        StatusCodeEnum[StatusCodeEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusCodeEnum[StatusCodeEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusCodeEnum[StatusCodeEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusCodeEnum[StatusCodeEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusCodeEnum[StatusCodeEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusCodeEnum = MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.StatusCodeEnum || (MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.StatusCodeEnum = {}));
    let CipherTypeEnum;
    (function (CipherTypeEnum) {
        CipherTypeEnum[CipherTypeEnum["Encryption"] = 'encryption'] = "Encryption";
        CipherTypeEnum[CipherTypeEnum["Decryption"] = 'decryption'] = "Decryption";
    })(CipherTypeEnum = MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.CipherTypeEnum || (MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.CipherTypeEnum = {}));
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.HashTypeEnum || (MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.HashTypeEnum = {}));
})(MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus = exports.MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus || (exports.MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus = {}));
class MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus = MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus;
MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.discriminator = undefined;
MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.attributeTypeMap = [
    {
        "name": "statusCode",
        "baseName": "statusCode",
        "type": "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.StatusCodeEnum"
    },
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "number"
    },
    {
        "name": "errorInfo",
        "baseName": "errorInfo",
        "type": "string"
    },
    {
        "name": "destinationLocation",
        "baseName": "destinationLocation",
        "type": "string"
    },
    {
        "name": "destinationHash",
        "baseName": "destinationHash",
        "type": "string"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.HashTypeEnum"
    },
    {
        "name": "secondaryDistributionHashType",
        "baseName": "secondaryDistributionHashType",
        "type": "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.SecondaryDistributionHashTypeEnum"
    },
    {
        "name": "secondaryDistributionHash",
        "baseName": "secondaryDistributionHash",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus) {
    let StatusCodeEnum;
    (function (StatusCodeEnum) {
        StatusCodeEnum[StatusCodeEnum["Pass"] = 'pass'] = "Pass";
        StatusCodeEnum[StatusCodeEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusCodeEnum[StatusCodeEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusCodeEnum[StatusCodeEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusCodeEnum[StatusCodeEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusCodeEnum[StatusCodeEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusCodeEnum = MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.StatusCodeEnum || (MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.StatusCodeEnum = {}));
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.HashTypeEnum || (MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.HashTypeEnum = {}));
    let SecondaryDistributionHashTypeEnum;
    (function (SecondaryDistributionHashTypeEnum) {
        SecondaryDistributionHashTypeEnum[SecondaryDistributionHashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        SecondaryDistributionHashTypeEnum[SecondaryDistributionHashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(SecondaryDistributionHashTypeEnum = MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.SecondaryDistributionHashTypeEnum || (MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.SecondaryDistributionHashTypeEnum = {}));
})(MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus = exports.MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus || (exports.MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus = {}));
class MSEssGatewayClientContractsReleaseFileScanStatus {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseFileScanStatus.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseFileScanStatus = MSEssGatewayClientContractsReleaseFileScanStatus;
MSEssGatewayClientContractsReleaseFileScanStatus.discriminator = undefined;
MSEssGatewayClientContractsReleaseFileScanStatus.attributeTypeMap = [
    {
        "name": "statusCode",
        "baseName": "statusCode",
        "type": "MSEssGatewayClientContractsReleaseFileScanStatus.StatusCodeEnum"
    },
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "number"
    },
    {
        "name": "errorInfo",
        "baseName": "errorInfo",
        "type": "string"
    },
    {
        "name": "fileCopyState",
        "baseName": "fileCopyState",
        "type": "string"
    },
    {
        "name": "fileCopyResult",
        "baseName": "fileCopyResult",
        "type": "string"
    },
    {
        "name": "decompressionState",
        "baseName": "decompressionState",
        "type": "string"
    },
    {
        "name": "decompressionResult",
        "baseName": "decompressionResult",
        "type": "string"
    },
    {
        "name": "decompressedFileCount",
        "baseName": "decompressedFileCount",
        "type": "number"
    },
    {
        "name": "scanningState",
        "baseName": "scanningState",
        "type": "string"
    },
    {
        "name": "scanningResult",
        "baseName": "scanningResult",
        "type": "string"
    },
    {
        "name": "scanOperationId",
        "baseName": "scanOperationId",
        "type": "string"
    },
    {
        "name": "links",
        "baseName": "links",
        "type": "{ [key: string]: string; }"
    }
];
(function (MSEssGatewayClientContractsReleaseFileScanStatus) {
    let StatusCodeEnum;
    (function (StatusCodeEnum) {
        StatusCodeEnum[StatusCodeEnum["Pass"] = 'pass'] = "Pass";
        StatusCodeEnum[StatusCodeEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusCodeEnum[StatusCodeEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusCodeEnum[StatusCodeEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusCodeEnum[StatusCodeEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusCodeEnum[StatusCodeEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusCodeEnum = MSEssGatewayClientContractsReleaseFileScanStatus.StatusCodeEnum || (MSEssGatewayClientContractsReleaseFileScanStatus.StatusCodeEnum = {}));
})(MSEssGatewayClientContractsReleaseFileScanStatus = exports.MSEssGatewayClientContractsReleaseFileScanStatus || (exports.MSEssGatewayClientContractsReleaseFileScanStatus = {}));
class MSEssGatewayClientContractsReleaseFileSignStatus {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseFileSignStatus.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseFileSignStatus = MSEssGatewayClientContractsReleaseFileSignStatus;
MSEssGatewayClientContractsReleaseFileSignStatus.discriminator = undefined;
MSEssGatewayClientContractsReleaseFileSignStatus.attributeTypeMap = [
    {
        "name": "statusCode",
        "baseName": "statusCode",
        "type": "MSEssGatewayClientContractsReleaseFileSignStatus.StatusCodeEnum"
    },
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "number"
    },
    {
        "name": "errorInfo",
        "baseName": "errorInfo",
        "type": "string"
    },
    {
        "name": "destinationLocation",
        "baseName": "destinationLocation",
        "type": "string"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsReleaseFileSignStatus.HashTypeEnum"
    },
    {
        "name": "destinationHash",
        "baseName": "destinationHash",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsReleaseFileSignStatus) {
    let StatusCodeEnum;
    (function (StatusCodeEnum) {
        StatusCodeEnum[StatusCodeEnum["Pass"] = 'pass'] = "Pass";
        StatusCodeEnum[StatusCodeEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusCodeEnum[StatusCodeEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusCodeEnum[StatusCodeEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusCodeEnum[StatusCodeEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusCodeEnum[StatusCodeEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusCodeEnum = MSEssGatewayClientContractsReleaseFileSignStatus.StatusCodeEnum || (MSEssGatewayClientContractsReleaseFileSignStatus.StatusCodeEnum = {}));
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsReleaseFileSignStatus.HashTypeEnum || (MSEssGatewayClientContractsReleaseFileSignStatus.HashTypeEnum = {}));
})(MSEssGatewayClientContractsReleaseFileSignStatus = exports.MSEssGatewayClientContractsReleaseFileSignStatus || (exports.MSEssGatewayClientContractsReleaseFileSignStatus = {}));
class MSEssGatewayClientContractsReleaseFileVaultStatusInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseFileVaultStatusInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseFileVaultStatusInfo = MSEssGatewayClientContractsReleaseFileVaultStatusInfo;
MSEssGatewayClientContractsReleaseFileVaultStatusInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseFileVaultStatusInfo.attributeTypeMap = [
    {
        "name": "publisherCode",
        "baseName": "publisherCode",
        "type": "string"
    },
    {
        "name": "publisherKey",
        "baseName": "publisherKey",
        "type": "string"
    },
    {
        "name": "vaultRegion",
        "baseName": "vaultRegion",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsReleaseFileVaultStatusInfo.StatusEnum"
    },
    {
        "name": "comments",
        "baseName": "comments",
        "type": "string"
    },
    {
        "name": "timestamp",
        "baseName": "timestamp",
        "type": "Date"
    }
];
(function (MSEssGatewayClientContractsReleaseFileVaultStatusInfo) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["NotStarted"] = 'notStarted'] = "NotStarted";
        StatusEnum[StatusEnum["InProgress"] = 'inProgress'] = "InProgress";
        StatusEnum[StatusEnum["Completed"] = 'completed'] = "Completed";
        StatusEnum[StatusEnum["Failed"] = 'failed'] = "Failed";
    })(StatusEnum = MSEssGatewayClientContractsReleaseFileVaultStatusInfo.StatusEnum || (MSEssGatewayClientContractsReleaseFileVaultStatusInfo.StatusEnum = {}));
})(MSEssGatewayClientContractsReleaseFileVaultStatusInfo = exports.MSEssGatewayClientContractsReleaseFileVaultStatusInfo || (exports.MSEssGatewayClientContractsReleaseFileVaultStatusInfo = {}));
class MSEssGatewayClientContractsReleaseOwnerInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseOwnerInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseOwnerInfo = MSEssGatewayClientContractsReleaseOwnerInfo;
MSEssGatewayClientContractsReleaseOwnerInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseOwnerInfo.attributeTypeMap = [
    {
        "name": "owner",
        "baseName": "owner",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    }
];
class MSEssGatewayClientContractsReleaseProductInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseProductInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseProductInfo = MSEssGatewayClientContractsReleaseProductInfo;
MSEssGatewayClientContractsReleaseProductInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseProductInfo.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "description",
        "baseName": "description",
        "type": "string"
    }
];
class MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo = MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo;
MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.attributeTypeMap = [
    {
        "name": "signStatus",
        "baseName": "signStatus",
        "type": "MSEssGatewayClientContractsReleaseFileSignStatus"
    },
    {
        "name": "encryptedDistributionBlobStatus",
        "baseName": "encryptedDistributionBlobStatus",
        "type": "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus"
    },
    {
        "name": "scanStatus",
        "baseName": "scanStatus",
        "type": "MSEssGatewayClientContractsReleaseFileScanStatus"
    },
    {
        "name": "preEncryptedDistributionBlobStatus",
        "baseName": "preEncryptedDistributionBlobStatus",
        "type": "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus"
    },
    {
        "name": "vaultStatus",
        "baseName": "vaultStatus",
        "type": "MSEssGatewayClientContractsReleaseFileVaultStatusInfo"
    },
    {
        "name": "fileId",
        "baseName": "fileId",
        "type": "string"
    },
    {
        "name": "distributionRelativePath",
        "baseName": "distributionRelativePath",
        "type": "string"
    },
    {
        "name": "partNumber",
        "baseName": "partNumber",
        "type": "string"
    },
    {
        "name": "friendlyFileName",
        "baseName": "friendlyFileName",
        "type": "string"
    },
    {
        "name": "tenantFileLocationType",
        "baseName": "tenantFileLocationType",
        "type": "string"
    },
    {
        "name": "tenantFileLocation",
        "baseName": "tenantFileLocation",
        "type": "string"
    },
    {
        "name": "signedEngineeringCopyLocation",
        "baseName": "signedEngineeringCopyLocation",
        "type": "string"
    },
    {
        "name": "encryptedDistributionBlobLocation",
        "baseName": "encryptedDistributionBlobLocation",
        "type": "string"
    },
    {
        "name": "preEncryptedDistributionBlobLocation",
        "baseName": "preEncryptedDistributionBlobLocation",
        "type": "string"
    },
    {
        "name": "secondaryDistributionHashRequired",
        "baseName": "secondaryDistributionHashRequired",
        "type": "boolean"
    },
    {
        "name": "secondaryDistributionHashType",
        "baseName": "secondaryDistributionHashType",
        "type": "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.SecondaryDistributionHashTypeEnum"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "hash",
        "baseName": "hash",
        "type": "string"
    },
    {
        "name": "sourceLocation",
        "baseName": "sourceLocation",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "sizeInBytes",
        "baseName": "sizeInBytes",
        "type": "number"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.HashTypeEnum"
    }
];
(function (MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo) {
    let SecondaryDistributionHashTypeEnum;
    (function (SecondaryDistributionHashTypeEnum) {
        SecondaryDistributionHashTypeEnum[SecondaryDistributionHashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        SecondaryDistributionHashTypeEnum[SecondaryDistributionHashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(SecondaryDistributionHashTypeEnum = MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.SecondaryDistributionHashTypeEnum || (MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.SecondaryDistributionHashTypeEnum = {}));
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.HashTypeEnum || (MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.HashTypeEnum = {}));
})(MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo = exports.MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo || (exports.MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo = {}));
class MSEssGatewayClientContractsReleaseReleaseFileInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseReleaseFileInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseReleaseFileInfo = MSEssGatewayClientContractsReleaseReleaseFileInfo;
MSEssGatewayClientContractsReleaseReleaseFileInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseReleaseFileInfo.attributeTypeMap = [
    {
        "name": "fileId",
        "baseName": "fileId",
        "type": "string"
    },
    {
        "name": "distributionRelativePath",
        "baseName": "distributionRelativePath",
        "type": "string"
    },
    {
        "name": "partNumber",
        "baseName": "partNumber",
        "type": "string"
    },
    {
        "name": "friendlyFileName",
        "baseName": "friendlyFileName",
        "type": "string"
    },
    {
        "name": "tenantFileLocationType",
        "baseName": "tenantFileLocationType",
        "type": "string"
    },
    {
        "name": "tenantFileLocation",
        "baseName": "tenantFileLocation",
        "type": "string"
    },
    {
        "name": "signedEngineeringCopyLocation",
        "baseName": "signedEngineeringCopyLocation",
        "type": "string"
    },
    {
        "name": "encryptedDistributionBlobLocation",
        "baseName": "encryptedDistributionBlobLocation",
        "type": "string"
    },
    {
        "name": "preEncryptedDistributionBlobLocation",
        "baseName": "preEncryptedDistributionBlobLocation",
        "type": "string"
    },
    {
        "name": "secondaryDistributionHashRequired",
        "baseName": "secondaryDistributionHashRequired",
        "type": "boolean"
    },
    {
        "name": "secondaryDistributionHashType",
        "baseName": "secondaryDistributionHashType",
        "type": "MSEssGatewayClientContractsReleaseReleaseFileInfo.SecondaryDistributionHashTypeEnum"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "hash",
        "baseName": "hash",
        "type": "string"
    },
    {
        "name": "sourceLocation",
        "baseName": "sourceLocation",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "sizeInBytes",
        "baseName": "sizeInBytes",
        "type": "number"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsReleaseReleaseFileInfo.HashTypeEnum"
    }
];
(function (MSEssGatewayClientContractsReleaseReleaseFileInfo) {
    let SecondaryDistributionHashTypeEnum;
    (function (SecondaryDistributionHashTypeEnum) {
        SecondaryDistributionHashTypeEnum[SecondaryDistributionHashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        SecondaryDistributionHashTypeEnum[SecondaryDistributionHashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(SecondaryDistributionHashTypeEnum = MSEssGatewayClientContractsReleaseReleaseFileInfo.SecondaryDistributionHashTypeEnum || (MSEssGatewayClientContractsReleaseReleaseFileInfo.SecondaryDistributionHashTypeEnum = {}));
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsReleaseReleaseFileInfo.HashTypeEnum || (MSEssGatewayClientContractsReleaseReleaseFileInfo.HashTypeEnum = {}));
})(MSEssGatewayClientContractsReleaseReleaseFileInfo = exports.MSEssGatewayClientContractsReleaseReleaseFileInfo || (exports.MSEssGatewayClientContractsReleaseReleaseFileInfo = {}));
class MSEssGatewayClientContractsReleaseReleaseInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseReleaseInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseReleaseInfo = MSEssGatewayClientContractsReleaseReleaseInfo;
MSEssGatewayClientContractsReleaseReleaseInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseReleaseInfo.attributeTypeMap = [
    {
        "name": "title",
        "baseName": "title",
        "type": "string"
    },
    {
        "name": "minimumNumberOfApprovers",
        "baseName": "minimumNumberOfApprovers",
        "type": "number"
    },
    {
        "name": "properties",
        "baseName": "properties",
        "type": "MSEssGatewayClientContractsReleaseReleaseInfoProperties"
    },
    {
        "name": "isRevision",
        "baseName": "isRevision",
        "type": "boolean"
    },
    {
        "name": "revisionNumber",
        "baseName": "revisionNumber",
        "type": "string"
    }
];
class MSEssGatewayClientContractsReleaseReleaseInfoProperties {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseReleaseInfoProperties.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseReleaseInfoProperties = MSEssGatewayClientContractsReleaseReleaseInfoProperties;
MSEssGatewayClientContractsReleaseReleaseInfoProperties.discriminator = undefined;
MSEssGatewayClientContractsReleaseReleaseInfoProperties.attributeTypeMap = [
    {
        "name": "releaseContentType",
        "baseName": "releaseContentType",
        "type": "string"
    },
    {
        "name": "isRsm",
        "baseName": "isRsm",
        "type": "string"
    }
];
class MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo = MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo;
MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.attributeTypeMap = [
    {
        "name": "publisherCode",
        "baseName": "publisherCode",
        "type": "string"
    },
    {
        "name": "publisherKey",
        "baseName": "publisherKey",
        "type": "string"
    },
    {
        "name": "vaultRegion",
        "baseName": "vaultRegion",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.StatusEnum"
    },
    {
        "name": "comments",
        "baseName": "comments",
        "type": "string"
    },
    {
        "name": "timestamp",
        "baseName": "timestamp",
        "type": "Date"
    }
];
(function (MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["NotStarted"] = 'notStarted'] = "NotStarted";
        StatusEnum[StatusEnum["InProgress"] = 'inProgress'] = "InProgress";
        StatusEnum[StatusEnum["Completed"] = 'completed'] = "Completed";
        StatusEnum[StatusEnum["Failed"] = 'failed'] = "Failed";
    })(StatusEnum = MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.StatusEnum || (MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.StatusEnum = {}));
})(MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo = exports.MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo || (exports.MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo = {}));
class MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage = MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage;
MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage.attributeTypeMap = [
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "actionTakenBy",
        "baseName": "actionTakenBy",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    },
    {
        "name": "comments",
        "baseName": "comments",
        "type": "string"
    },
    {
        "name": "publisherId",
        "baseName": "publisherId",
        "type": "string"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
class MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage = MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage;
MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage.attributeTypeMap = [
    {
        "name": "publisherId",
        "baseName": "publisherId",
        "type": "string"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "actionTakenBy",
        "baseName": "actionTakenBy",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    },
    {
        "name": "owners",
        "baseName": "owners",
        "type": "Array<MSEssGatewayClientContractsReleaseEditOwnerInfo>"
    },
    {
        "name": "approvers",
        "baseName": "approvers",
        "type": "Array<MSEssGatewayClientContractsReleaseEditApproverInfo>"
    },
    {
        "name": "authorizedDownloadUsers",
        "baseName": "authorizedDownloadUsers",
        "type": "Array<MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo>"
    },
    {
        "name": "channelDownloadEntities",
        "baseName": "channelDownloadEntities",
        "type": "Array<MSEssGatewayClientContractsReleaseEditChannelDownloadEntity>"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
class MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage = MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage;
MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage.attributeTypeMap = [
    {
        "name": "releaseInfo",
        "baseName": "releaseInfo",
        "type": "MSEssGatewayClientContractsReleaseReleaseInfo"
    },
    {
        "name": "productInfo",
        "baseName": "productInfo",
        "type": "MSEssGatewayClientContractsReleaseProductInfo"
    },
    {
        "name": "files",
        "baseName": "files",
        "type": "Array<MSEssGatewayClientContractsReleaseReleaseFileInfo>"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "createdBy",
        "baseName": "createdBy",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    },
    {
        "name": "owners",
        "baseName": "owners",
        "type": "Array<MSEssGatewayClientContractsReleaseOwnerInfo>"
    },
    {
        "name": "approvers",
        "baseName": "approvers",
        "type": "Array<MSEssGatewayClientContractsReleaseApproverInfo>"
    },
    {
        "name": "authorizedDownloadUsers",
        "baseName": "authorizedDownloadUsers",
        "type": "Array<MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo>"
    },
    {
        "name": "accessPermissionsInfo",
        "baseName": "accessPermissionsInfo",
        "type": "MSEssGatewayClientContractsReleaseAccessPermissionsInfo"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "publisherId",
        "baseName": "publisherId",
        "type": "string"
    },
    {
        "name": "signingInfo",
        "baseName": "signingInfo",
        "type": "MSEssGatewayClientContractsSignFileInfo"
    },
    {
        "name": "cipherInfo",
        "baseName": "cipherInfo",
        "type": "MSEssGatewayClientContractsCipherInfo"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
class MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage = MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage;
MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.attributeTypeMap = [
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "actionTakenBy",
        "baseName": "actionTakenBy",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    },
    {
        "name": "approvalStatus",
        "baseName": "approvalStatus",
        "type": "MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.ApprovalStatusEnum"
    },
    {
        "name": "comments",
        "baseName": "comments",
        "type": "string"
    },
    {
        "name": "publisherId",
        "baseName": "publisherId",
        "type": "string"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
(function (MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage) {
    let ApprovalStatusEnum;
    (function (ApprovalStatusEnum) {
        ApprovalStatusEnum[ApprovalStatusEnum["Pending"] = 'pending'] = "Pending";
        ApprovalStatusEnum[ApprovalStatusEnum["Approved"] = 'approved'] = "Approved";
        ApprovalStatusEnum[ApprovalStatusEnum["Rejected"] = 'rejected'] = "Rejected";
    })(ApprovalStatusEnum = MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.ApprovalStatusEnum || (MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.ApprovalStatusEnum = {}));
})(MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage = exports.MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage || (exports.MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage = {}));
class MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage = MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage;
MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage.attributeTypeMap = [
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "clusterRegion",
        "baseName": "clusterRegion",
        "type": "string"
    },
    {
        "name": "notificationMessages",
        "baseName": "notificationMessages",
        "type": "Array<MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo>"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
class MSEssGatewayClientContractsReleaseResponseApproverInfoDetails {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseResponseApproverInfoDetails = MSEssGatewayClientContractsReleaseResponseApproverInfoDetails;
MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.discriminator = undefined;
MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.attributeTypeMap = [
    {
        "name": "approvalStatus",
        "baseName": "approvalStatus",
        "type": "MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.ApprovalStatusEnum"
    },
    {
        "name": "comments",
        "baseName": "comments",
        "type": "string"
    },
    {
        "name": "actionTakenAt",
        "baseName": "actionTakenAt",
        "type": "Date"
    },
    {
        "name": "approver",
        "baseName": "approver",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    },
    {
        "name": "isAutoApproved",
        "baseName": "isAutoApproved",
        "type": "boolean"
    },
    {
        "name": "isMandatory",
        "baseName": "isMandatory",
        "type": "boolean"
    }
];
(function (MSEssGatewayClientContractsReleaseResponseApproverInfoDetails) {
    let ApprovalStatusEnum;
    (function (ApprovalStatusEnum) {
        ApprovalStatusEnum[ApprovalStatusEnum["Pending"] = 'pending'] = "Pending";
        ApprovalStatusEnum[ApprovalStatusEnum["Approved"] = 'approved'] = "Approved";
        ApprovalStatusEnum[ApprovalStatusEnum["Rejected"] = 'rejected'] = "Rejected";
    })(ApprovalStatusEnum = MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.ApprovalStatusEnum || (MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.ApprovalStatusEnum = {}));
})(MSEssGatewayClientContractsReleaseResponseApproverInfoDetails = exports.MSEssGatewayClientContractsReleaseResponseApproverInfoDetails || (exports.MSEssGatewayClientContractsReleaseResponseApproverInfoDetails = {}));
class MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo = MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo;
MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo.attributeTypeMap = [
    {
        "name": "activityId",
        "baseName": "activityId",
        "type": "string"
    },
    {
        "name": "activityType",
        "baseName": "activityType",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "string"
    },
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "number"
    },
    {
        "name": "errorMessages",
        "baseName": "errorMessages",
        "type": "Array<string>"
    },
    {
        "name": "beginTime",
        "baseName": "beginTime",
        "type": "Date"
    },
    {
        "name": "endTime",
        "baseName": "endTime",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    }
];
class MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage = MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage;
MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.discriminator = undefined;
MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.attributeTypeMap = [
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "clusterRegion",
        "baseName": "clusterRegion",
        "type": "string"
    },
    {
        "name": "correlationVector",
        "baseName": "correlationVector",
        "type": "string"
    },
    {
        "name": "releaseCompletedAt",
        "baseName": "releaseCompletedAt",
        "type": "Date"
    },
    {
        "name": "releaseInfo",
        "baseName": "releaseInfo",
        "type": "MSEssGatewayClientContractsReleaseReleaseInfo"
    },
    {
        "name": "productInfo",
        "baseName": "productInfo",
        "type": "MSEssGatewayClientContractsReleaseProductInfo"
    },
    {
        "name": "createdBy",
        "baseName": "createdBy",
        "type": "MSEssGatewayClientContractsReleaseUserInfo"
    },
    {
        "name": "owners",
        "baseName": "owners",
        "type": "Array<MSEssGatewayClientContractsReleaseOwnerInfo>"
    },
    {
        "name": "approvers",
        "baseName": "approvers",
        "type": "Array<MSEssGatewayClientContractsReleaseResponseApproverInfoDetails>"
    },
    {
        "name": "authorizedDownloadUsers",
        "baseName": "authorizedDownloadUsers",
        "type": "Array<MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo>"
    },
    {
        "name": "accessPermissionsInfo",
        "baseName": "accessPermissionsInfo",
        "type": "MSEssGatewayClientContractsReleaseAccessPermissionsInfo"
    },
    {
        "name": "files",
        "baseName": "files",
        "type": "Array<MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo>"
    },
    {
        "name": "comments",
        "baseName": "comments",
        "type": "Array<string>"
    },
    {
        "name": "cancellationReason",
        "baseName": "cancellationReason",
        "type": "string"
    },
    {
        "name": "totalReleaseSize",
        "baseName": "totalReleaseSize",
        "type": "number"
    },
    {
        "name": "totalFileCount",
        "baseName": "totalFileCount",
        "type": "number"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "activities",
        "baseName": "activities",
        "type": "Array<MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo>"
    },
    {
        "name": "releaseError",
        "baseName": "releaseError",
        "type": "MSEssGatewayClientContractsReleaseResponseReleaseError"
    },
    {
        "name": "childworkflowType",
        "baseName": "childworkflowType",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.StatusEnum || (MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage = exports.MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage || (exports.MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage = {}));
class MSEssGatewayClientContractsReleaseResponseReleaseEditResponse {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseResponseReleaseEditResponse.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseResponseReleaseEditResponse = MSEssGatewayClientContractsReleaseResponseReleaseEditResponse;
MSEssGatewayClientContractsReleaseResponseReleaseEditResponse.discriminator = undefined;
MSEssGatewayClientContractsReleaseResponseReleaseEditResponse.attributeTypeMap = [
    {
        "name": "requestId",
        "baseName": "requestId",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "error",
        "baseName": "error",
        "type": "MSEssGatewayClientContractsGatewayError"
    },
    {
        "name": "statusLocation",
        "baseName": "statusLocation",
        "type": "string"
    }
];
class MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage = MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage;
MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.discriminator = undefined;
MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.attributeTypeMap = [
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "requestId",
        "baseName": "requestId",
        "type": "string"
    },
    {
        "name": "releaseEditSections",
        "baseName": "releaseEditSections",
        "type": "Array<MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo>"
    },
    {
        "name": "releaseError",
        "baseName": "releaseError",
        "type": "MSEssGatewayClientContractsReleaseResponseReleaseError"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.StatusEnum || (MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage = exports.MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage || (exports.MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage = {}));
class MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo = MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo;
MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "statusCode",
        "baseName": "statusCode",
        "type": "string"
    },
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "number"
    },
    {
        "name": "errorInfo",
        "baseName": "errorInfo",
        "type": "string"
    }
];
class MSEssGatewayClientContractsReleaseResponseReleaseError {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseResponseReleaseError.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseResponseReleaseError = MSEssGatewayClientContractsReleaseResponseReleaseError;
MSEssGatewayClientContractsReleaseResponseReleaseError.discriminator = undefined;
MSEssGatewayClientContractsReleaseResponseReleaseError.attributeTypeMap = [
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "number"
    },
    {
        "name": "errorMessages",
        "baseName": "errorMessages",
        "type": "Array<string>"
    }
];
class MSEssGatewayClientContractsReleaseResponseReleaseResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseResponseReleaseResultMessage = MSEssGatewayClientContractsReleaseResponseReleaseResultMessage;
MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.discriminator = undefined;
MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.attributeTypeMap = [
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "activities",
        "baseName": "activities",
        "type": "Array<MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo>"
    },
    {
        "name": "releaseError",
        "baseName": "releaseError",
        "type": "MSEssGatewayClientContractsReleaseResponseReleaseError"
    },
    {
        "name": "totalReleaseSize",
        "baseName": "totalReleaseSize",
        "type": "number"
    },
    {
        "name": "totalFileCount",
        "baseName": "totalFileCount",
        "type": "number"
    },
    {
        "name": "childworkflowType",
        "baseName": "childworkflowType",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsReleaseResponseReleaseResultMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.StatusEnum || (MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsReleaseResponseReleaseResultMessage = exports.MSEssGatewayClientContractsReleaseResponseReleaseResultMessage || (exports.MSEssGatewayClientContractsReleaseResponseReleaseResultMessage = {}));
class MSEssGatewayClientContractsReleaseUserInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsReleaseUserInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsReleaseUserInfo = MSEssGatewayClientContractsReleaseUserInfo;
MSEssGatewayClientContractsReleaseUserInfo.discriminator = undefined;
MSEssGatewayClientContractsReleaseUserInfo.attributeTypeMap = [
    {
        "name": "userPrincipalName",
        "baseName": "userPrincipalName",
        "type": "string"
    }
];
class MSEssGatewayClientContractsRequestDetails {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsRequestDetails.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsRequestDetails = MSEssGatewayClientContractsRequestDetails;
MSEssGatewayClientContractsRequestDetails.discriminator = undefined;
MSEssGatewayClientContractsRequestDetails.attributeTypeMap = [
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsRequestDetails.StatusEnum"
    },
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsRequestDetails) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsRequestDetails.StatusEnum || (MSEssGatewayClientContractsRequestDetails.StatusEnum = {}));
})(MSEssGatewayClientContractsRequestDetails = exports.MSEssGatewayClientContractsRequestDetails || (exports.MSEssGatewayClientContractsRequestDetails = {}));
class MSEssGatewayClientContractsRoutingInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsRoutingInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsRoutingInfo = MSEssGatewayClientContractsRoutingInfo;
MSEssGatewayClientContractsRoutingInfo.discriminator = undefined;
MSEssGatewayClientContractsRoutingInfo.attributeTypeMap = [
    {
        "name": "intent",
        "baseName": "intent",
        "type": "string"
    },
    {
        "name": "contentType",
        "baseName": "contentType",
        "type": "string"
    },
    {
        "name": "contentOrigin",
        "baseName": "contentOrigin",
        "type": "string"
    },
    {
        "name": "productState",
        "baseName": "productState",
        "type": "string"
    },
    {
        "name": "audience",
        "baseName": "audience",
        "type": "string"
    }
];
class MSEssGatewayClientContractsScanFileInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsScanFileInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsScanFileInfo = MSEssGatewayClientContractsScanFileInfo;
MSEssGatewayClientContractsScanFileInfo.discriminator = undefined;
MSEssGatewayClientContractsScanFileInfo.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "hash",
        "baseName": "hash",
        "type": "string"
    },
    {
        "name": "sourceLocation",
        "baseName": "sourceLocation",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "sizeInBytes",
        "baseName": "sizeInBytes",
        "type": "number"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsScanFileInfo.HashTypeEnum"
    }
];
(function (MSEssGatewayClientContractsScanFileInfo) {
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsScanFileInfo.HashTypeEnum || (MSEssGatewayClientContractsScanFileInfo.HashTypeEnum = {}));
})(MSEssGatewayClientContractsScanFileInfo = exports.MSEssGatewayClientContractsScanFileInfo || (exports.MSEssGatewayClientContractsScanFileInfo = {}));
class MSEssGatewayClientContractsScanGroupResult {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsScanGroupResult.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsScanGroupResult = MSEssGatewayClientContractsScanGroupResult;
MSEssGatewayClientContractsScanGroupResult.discriminator = undefined;
MSEssGatewayClientContractsScanGroupResult.attributeTypeMap = [
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "result",
        "baseName": "result",
        "type": "MSEssGatewayClientContractsScanGroupResult.ResultEnum"
    },
    {
        "name": "lastUpdatedAt",
        "baseName": "lastUpdatedAt",
        "type": "Date"
    },
    {
        "name": "requests",
        "baseName": "requests",
        "type": "Array<MSEssGatewayClientContractsRequestDetails>"
    }
];
(function (MSEssGatewayClientContractsScanGroupResult) {
    let ResultEnum;
    (function (ResultEnum) {
        ResultEnum[ResultEnum["NotDetermined"] = 'notDetermined'] = "NotDetermined";
        ResultEnum[ResultEnum["Clean"] = 'clean'] = "Clean";
        ResultEnum[ResultEnum["MalwareFound"] = 'malwareFound'] = "MalwareFound";
        ResultEnum[ResultEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        ResultEnum[ResultEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        ResultEnum[ResultEnum["Failed"] = 'failed'] = "Failed";
    })(ResultEnum = MSEssGatewayClientContractsScanGroupResult.ResultEnum || (MSEssGatewayClientContractsScanGroupResult.ResultEnum = {}));
})(MSEssGatewayClientContractsScanGroupResult = exports.MSEssGatewayClientContractsScanGroupResult || (exports.MSEssGatewayClientContractsScanGroupResult = {}));
class MSEssGatewayClientContractsScanRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsScanRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsScanRequestMessage = MSEssGatewayClientContractsScanRequestMessage;
MSEssGatewayClientContractsScanRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsScanRequestMessage.attributeTypeMap = [
    {
        "name": "file",
        "baseName": "file",
        "type": "MSEssGatewayClientContractsScanFileInfo"
    },
    {
        "name": "region",
        "baseName": "region",
        "type": "MSEssGatewayClientContractsScanRequestMessage.RegionEnum"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "isAutoResubmitWhenFailCanRetry",
        "baseName": "isAutoResubmitWhenFailCanRetry",
        "type": "boolean"
    },
    {
        "name": "autoResubmisionFailCanRetryCount",
        "baseName": "autoResubmisionFailCanRetryCount",
        "type": "number"
    },
    {
        "name": "requestExpiresAt",
        "baseName": "requestExpiresAt",
        "type": "Date"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
(function (MSEssGatewayClientContractsScanRequestMessage) {
    let RegionEnum;
    (function (RegionEnum) {
        RegionEnum[RegionEnum["None"] = 'none'] = "None";
        RegionEnum[RegionEnum["PuertoRico"] = 'puertoRico'] = "PuertoRico";
        RegionEnum[RegionEnum["Us"] = 'us'] = "Us";
        RegionEnum[RegionEnum["Dublin"] = 'dublin'] = "Dublin";
        RegionEnum[RegionEnum["Singapore"] = 'singapore'] = "Singapore";
    })(RegionEnum = MSEssGatewayClientContractsScanRequestMessage.RegionEnum || (MSEssGatewayClientContractsScanRequestMessage.RegionEnum = {}));
})(MSEssGatewayClientContractsScanRequestMessage = exports.MSEssGatewayClientContractsScanRequestMessage || (exports.MSEssGatewayClientContractsScanRequestMessage = {}));
class MSEssGatewayClientContractsScanResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsScanResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsScanResultMessage = MSEssGatewayClientContractsScanResultMessage;
MSEssGatewayClientContractsScanResultMessage.discriminator = undefined;
MSEssGatewayClientContractsScanResultMessage.attributeTypeMap = [
    {
        "name": "sourceFileHash",
        "baseName": "sourceFileHash",
        "type": "string"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsScanResultMessage.HashTypeEnum"
    },
    {
        "name": "decompressedHashCount",
        "baseName": "decompressedHashCount",
        "type": "number"
    },
    {
        "name": "workflowType",
        "baseName": "workflowType",
        "type": "MSEssGatewayClientContractsScanResultMessage.WorkflowTypeEnum"
    },
    {
        "name": "fileSizeInBytes",
        "baseName": "fileSizeInBytes",
        "type": "number"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsScanResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsScanResultMessage) {
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsScanResultMessage.HashTypeEnum || (MSEssGatewayClientContractsScanResultMessage.HashTypeEnum = {}));
    let WorkflowTypeEnum;
    (function (WorkflowTypeEnum) {
        WorkflowTypeEnum[WorkflowTypeEnum["None"] = 'none'] = "None";
        WorkflowTypeEnum[WorkflowTypeEnum["Scan"] = 'scan'] = "Scan";
        WorkflowTypeEnum[WorkflowTypeEnum["SignAndScan"] = 'signAndScan'] = "SignAndScan";
        WorkflowTypeEnum[WorkflowTypeEnum["Release"] = 'release'] = "Release";
        WorkflowTypeEnum[WorkflowTypeEnum["DigestSign"] = 'digestSign'] = "DigestSign";
        WorkflowTypeEnum[WorkflowTypeEnum["Pkita"] = 'pkita'] = "Pkita";
        WorkflowTypeEnum[WorkflowTypeEnum["Simulation"] = 'simulation'] = "Simulation";
        WorkflowTypeEnum[WorkflowTypeEnum["Crypto"] = 'crypto'] = "Crypto";
        WorkflowTypeEnum[WorkflowTypeEnum["SignAndLazyScan"] = 'signAndLazyScan'] = "SignAndLazyScan";
        WorkflowTypeEnum[WorkflowTypeEnum["SignWithAsyncScan"] = 'signWithAsyncScan'] = "SignWithAsyncScan";
        WorkflowTypeEnum[WorkflowTypeEnum["ReleaseWithAsyncScan"] = 'releaseWithAsyncScan'] = "ReleaseWithAsyncScan";
        WorkflowTypeEnum[WorkflowTypeEnum["SignOnly"] = 'signOnly'] = "SignOnly";
        WorkflowTypeEnum[WorkflowTypeEnum["ReleaseWithAsyncCrypto"] = 'releaseWithAsyncCrypto'] = "ReleaseWithAsyncCrypto";
        WorkflowTypeEnum[WorkflowTypeEnum["SignWithNonBlockingScan"] = 'signWithNonBlockingScan'] = "SignWithNonBlockingScan";
        WorkflowTypeEnum[WorkflowTypeEnum["FileTransfer"] = 'fileTransfer'] = "FileTransfer";
        WorkflowTypeEnum[WorkflowTypeEnum["Vault"] = 'vault'] = "Vault";
        WorkflowTypeEnum[WorkflowTypeEnum["VaultWithAsyncFileTransfer"] = 'vaultWithAsyncFileTransfer'] = "VaultWithAsyncFileTransfer";
    })(WorkflowTypeEnum = MSEssGatewayClientContractsScanResultMessage.WorkflowTypeEnum || (MSEssGatewayClientContractsScanResultMessage.WorkflowTypeEnum = {}));
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsScanResultMessage.StatusEnum || (MSEssGatewayClientContractsScanResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsScanResultMessage = exports.MSEssGatewayClientContractsScanResultMessage || (exports.MSEssGatewayClientContractsScanResultMessage = {}));
class MSEssGatewayClientContractsSessionRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsSessionRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsSessionRequestMessage = MSEssGatewayClientContractsSessionRequestMessage;
MSEssGatewayClientContractsSessionRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsSessionRequestMessage.attributeTypeMap = [
    {
        "name": "expiresAfter",
        "baseName": "expiresAfter",
        "type": "string"
    },
    {
        "name": "partitionCount",
        "baseName": "partitionCount",
        "type": "number"
    },
    {
        "name": "isProvisionStorage",
        "baseName": "isProvisionStorage",
        "type": "boolean"
    },
    {
        "name": "isLegacyCopsModel",
        "baseName": "isLegacyCopsModel",
        "type": "boolean"
    },
    {
        "name": "commandName",
        "baseName": "commandName",
        "type": "string"
    },
    {
        "name": "intent",
        "baseName": "intent",
        "type": "string"
    },
    {
        "name": "contentType",
        "baseName": "contentType",
        "type": "string"
    },
    {
        "name": "contentOrigin",
        "baseName": "contentOrigin",
        "type": "string"
    },
    {
        "name": "productState",
        "baseName": "productState",
        "type": "string"
    },
    {
        "name": "audience",
        "baseName": "audience",
        "type": "string"
    }
];
class MSEssGatewayClientContractsSessionResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsSessionResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsSessionResultMessage = MSEssGatewayClientContractsSessionResultMessage;
MSEssGatewayClientContractsSessionResultMessage.discriminator = undefined;
MSEssGatewayClientContractsSessionResultMessage.attributeTypeMap = [
    {
        "name": "clientConfig",
        "baseName": "clientConfig",
        "type": "MSEssGatewayClientContractsEsrpClientConfigInfo3"
    },
    {
        "name": "policyResult",
        "baseName": "policyResult",
        "type": "MSEssGatewayClientContractsPolicyResultMessage"
    },
    {
        "name": "storageResult",
        "baseName": "storageResult",
        "type": "MSEssGatewayClientContractsProvisionStorageResultMessage"
    },
    {
        "name": "digestSignMapping",
        "baseName": "digestSignMapping",
        "type": "MSEssGatewayClientContractsDigestSignMapping"
    },
    {
        "name": "legacyCopsMapping",
        "baseName": "legacyCopsMapping",
        "type": "Array<MSEssGatewayClientContractsLegacyCopsMappingData>"
    },
    {
        "name": "digestSignOperationErrorPatterns",
        "baseName": "digestSignOperationErrorPatterns",
        "type": "Array<MSEssGatewayClientContractsDigestSignOperationErrorPatterns>"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsSessionResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsSessionResultMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsSessionResultMessage.StatusEnum || (MSEssGatewayClientContractsSessionResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsSessionResultMessage = exports.MSEssGatewayClientContractsSessionResultMessage || (exports.MSEssGatewayClientContractsSessionResultMessage = {}));
class MSEssGatewayClientContractsSignFileInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsSignFileInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsSignFileInfo = MSEssGatewayClientContractsSignFileInfo;
MSEssGatewayClientContractsSignFileInfo.discriminator = undefined;
MSEssGatewayClientContractsSignFileInfo.attributeTypeMap = [
    {
        "name": "destinationLocation",
        "baseName": "destinationLocation",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "signingOperations",
        "baseName": "signingOperations",
        "type": "Array<MSEssGatewayClientContractsStaticSigningOperation>"
    },
    {
        "name": "dynamicSigningOperations",
        "baseName": "dynamicSigningOperations",
        "type": "Array<MSEssGatewayClientContractsDynamicSigningOperation>"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "hash",
        "baseName": "hash",
        "type": "string"
    },
    {
        "name": "sourceLocation",
        "baseName": "sourceLocation",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "sizeInBytes",
        "baseName": "sizeInBytes",
        "type": "number"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsSignFileInfo.HashTypeEnum"
    }
];
(function (MSEssGatewayClientContractsSignFileInfo) {
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsSignFileInfo.HashTypeEnum || (MSEssGatewayClientContractsSignFileInfo.HashTypeEnum = {}));
})(MSEssGatewayClientContractsSignFileInfo = exports.MSEssGatewayClientContractsSignFileInfo || (exports.MSEssGatewayClientContractsSignFileInfo = {}));
class MSEssGatewayClientContractsSignRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsSignRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsSignRequestMessage = MSEssGatewayClientContractsSignRequestMessage;
MSEssGatewayClientContractsSignRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsSignRequestMessage.attributeTypeMap = [
    {
        "name": "file",
        "baseName": "file",
        "type": "MSEssGatewayClientContractsSignFileInfo"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "region",
        "baseName": "region",
        "type": "MSEssGatewayClientContractsSignRequestMessage.RegionEnum"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "requestExpiresAt",
        "baseName": "requestExpiresAt",
        "type": "Date"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
(function (MSEssGatewayClientContractsSignRequestMessage) {
    let RegionEnum;
    (function (RegionEnum) {
        RegionEnum[RegionEnum["None"] = 'none'] = "None";
        RegionEnum[RegionEnum["PuertoRico"] = 'puertoRico'] = "PuertoRico";
        RegionEnum[RegionEnum["Us"] = 'us'] = "Us";
        RegionEnum[RegionEnum["Dublin"] = 'dublin'] = "Dublin";
        RegionEnum[RegionEnum["Singapore"] = 'singapore'] = "Singapore";
    })(RegionEnum = MSEssGatewayClientContractsSignRequestMessage.RegionEnum || (MSEssGatewayClientContractsSignRequestMessage.RegionEnum = {}));
})(MSEssGatewayClientContractsSignRequestMessage = exports.MSEssGatewayClientContractsSignRequestMessage || (exports.MSEssGatewayClientContractsSignRequestMessage = {}));
class MSEssGatewayClientContractsSignResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsSignResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsSignResultMessage = MSEssGatewayClientContractsSignResultMessage;
MSEssGatewayClientContractsSignResultMessage.discriminator = undefined;
MSEssGatewayClientContractsSignResultMessage.attributeTypeMap = [
    {
        "name": "sourceFileHash",
        "baseName": "sourceFileHash",
        "type": "string"
    },
    {
        "name": "destinationFileHash",
        "baseName": "destinationFileHash",
        "type": "string"
    },
    {
        "name": "destinationLocation",
        "baseName": "destinationLocation",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "hashType",
        "baseName": "hashType",
        "type": "MSEssGatewayClientContractsSignResultMessage.HashTypeEnum"
    },
    {
        "name": "certificateThumbprint",
        "baseName": "certificateThumbprint",
        "type": "string"
    },
    {
        "name": "fileName",
        "baseName": "fileName",
        "type": "string"
    },
    {
        "name": "fileSize",
        "baseName": "fileSize",
        "type": "number"
    },
    {
        "name": "isSignOnly_",
        "baseName": "isSignOnly ",
        "type": "boolean"
    },
    {
        "name": "destinationFileSasUrl_",
        "baseName": "destinationFileSasUrl ",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsSignResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsSignResultMessage) {
    let HashTypeEnum;
    (function (HashTypeEnum) {
        HashTypeEnum[HashTypeEnum["Sha256"] = 'sha256'] = "Sha256";
        HashTypeEnum[HashTypeEnum["Sha1"] = 'sha1'] = "Sha1";
    })(HashTypeEnum = MSEssGatewayClientContractsSignResultMessage.HashTypeEnum || (MSEssGatewayClientContractsSignResultMessage.HashTypeEnum = {}));
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsSignResultMessage.StatusEnum || (MSEssGatewayClientContractsSignResultMessage.StatusEnum = {}));
})(MSEssGatewayClientContractsSignResultMessage = exports.MSEssGatewayClientContractsSignResultMessage || (exports.MSEssGatewayClientContractsSignResultMessage = {}));
class MSEssGatewayClientContractsSigningParameter {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsSigningParameter.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsSigningParameter = MSEssGatewayClientContractsSigningParameter;
MSEssGatewayClientContractsSigningParameter.discriminator = undefined;
MSEssGatewayClientContractsSigningParameter.attributeTypeMap = [
    {
        "name": "parameterName",
        "baseName": "parameterName",
        "type": "string"
    },
    {
        "name": "parameterValue",
        "baseName": "parameterValue",
        "type": "string"
    }
];
class MSEssGatewayClientContractsSlkRequestSlkRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsSlkRequestSlkRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsSlkRequestSlkRequestMessage = MSEssGatewayClientContractsSlkRequestSlkRequestMessage;
MSEssGatewayClientContractsSlkRequestSlkRequestMessage.discriminator = undefined;
MSEssGatewayClientContractsSlkRequestSlkRequestMessage.attributeTypeMap = [
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
class MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse = MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse;
MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse.discriminator = undefined;
MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse.attributeTypeMap = [
    {
        "name": "rangeId",
        "baseName": "rangeId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "number"
    },
    {
        "name": "partNumber",
        "baseName": "partNumber",
        "type": "string"
    },
    {
        "name": "publicKey",
        "baseName": "publicKey",
        "type": "string"
    },
    {
        "name": "semiPrivateKey",
        "baseName": "semiPrivateKey",
        "type": "string"
    },
    {
        "name": "errorCode",
        "baseName": "errorCode",
        "type": "number"
    },
    {
        "name": "errorDescription",
        "baseName": "errorDescription",
        "type": "string"
    }
];
class MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_ {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_ = MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_;
MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.discriminator = undefined;
MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.attributeTypeMap = [
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "response",
        "baseName": "response",
        "type": "MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.StatusEnum || (MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.StatusEnum = {}));
})(MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_ = exports.MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_ || (exports.MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_ = {}));
class MSEssGatewayClientContractsStaticSigningOperation {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsStaticSigningOperation.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsStaticSigningOperation = MSEssGatewayClientContractsStaticSigningOperation;
MSEssGatewayClientContractsStaticSigningOperation.discriminator = undefined;
MSEssGatewayClientContractsStaticSigningOperation.attributeTypeMap = [
    {
        "name": "keyCode",
        "baseName": "keyCode",
        "type": "string"
    },
    {
        "name": "operationSetCode",
        "baseName": "operationSetCode",
        "type": "string"
    },
    {
        "name": "parameters",
        "baseName": "parameters",
        "type": "Array<MSEssGatewayClientContractsSigningParameter>"
    },
    {
        "name": "toolName",
        "baseName": "toolName",
        "type": "string"
    },
    {
        "name": "toolVersion",
        "baseName": "toolVersion",
        "type": "string"
    }
];
class MSEssGatewayClientContractsStorageShard {
    static getAttributeTypeMap() {
        return MSEssGatewayClientContractsStorageShard.attributeTypeMap;
    }
}
exports.MSEssGatewayClientContractsStorageShard = MSEssGatewayClientContractsStorageShard;
MSEssGatewayClientContractsStorageShard.discriminator = undefined;
MSEssGatewayClientContractsStorageShard.attributeTypeMap = [
    {
        "name": "shardLocation",
        "baseName": "shardLocation",
        "type": "MSEssGatewayClientContractsFileLocation"
    },
    {
        "name": "lowKey",
        "baseName": "lowKey",
        "type": "number"
    },
    {
        "name": "highKey",
        "baseName": "highKey",
        "type": "number"
    }
];
class MSEssGatewayClientOnPremContractsDigestSignRequestMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientOnPremContractsDigestSignRequestMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientOnPremContractsDigestSignRequestMessage = MSEssGatewayClientOnPremContractsDigestSignRequestMessage;
MSEssGatewayClientOnPremContractsDigestSignRequestMessage.discriminator = undefined;
MSEssGatewayClientOnPremContractsDigestSignRequestMessage.attributeTypeMap = [
    {
        "name": "algorithm",
        "baseName": "algorithm",
        "type": "string"
    },
    {
        "name": "keyCode",
        "baseName": "keyCode",
        "type": "string"
    },
    {
        "name": "hashes",
        "baseName": "hashes",
        "type": "Array<MSEssGatewayClientOnPremContractsHashInfo>"
    },
    {
        "name": "region",
        "baseName": "region",
        "type": "MSEssGatewayClientOnPremContractsDigestSignRequestMessage.RegionEnum"
    },
    {
        "name": "routingInfo",
        "baseName": "routingInfo",
        "type": "MSEssGatewayClientContractsRoutingInfo"
    },
    {
        "name": "jwsToken",
        "baseName": "jwsToken",
        "type": "string"
    },
    {
        "name": "isDynamic",
        "baseName": "isDynamic",
        "type": "boolean"
    },
    {
        "name": "requestExpiresAt",
        "baseName": "requestExpiresAt",
        "type": "Date"
    },
    {
        "name": "publicCert",
        "baseName": "publicCert",
        "type": "string"
    },
    {
        "name": "driEmail",
        "baseName": "driEmail",
        "type": "Array<string>"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "esrpCorrelationId",
        "baseName": "esrpCorrelationId",
        "type": "string"
    },
    {
        "name": "version",
        "baseName": "version",
        "type": "string"
    },
    {
        "name": "contextData",
        "baseName": "contextData",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<MSEssGatewayClientContractsIFeature>"
    }
];
(function (MSEssGatewayClientOnPremContractsDigestSignRequestMessage) {
    let RegionEnum;
    (function (RegionEnum) {
        RegionEnum[RegionEnum["None"] = 'none'] = "None";
        RegionEnum[RegionEnum["PuertoRico"] = 'puertoRico'] = "PuertoRico";
        RegionEnum[RegionEnum["Us"] = 'us'] = "Us";
        RegionEnum[RegionEnum["Dublin"] = 'dublin'] = "Dublin";
        RegionEnum[RegionEnum["Singapore"] = 'singapore'] = "Singapore";
    })(RegionEnum = MSEssGatewayClientOnPremContractsDigestSignRequestMessage.RegionEnum || (MSEssGatewayClientOnPremContractsDigestSignRequestMessage.RegionEnum = {}));
})(MSEssGatewayClientOnPremContractsDigestSignRequestMessage = exports.MSEssGatewayClientOnPremContractsDigestSignRequestMessage || (exports.MSEssGatewayClientOnPremContractsDigestSignRequestMessage = {}));
class MSEssGatewayClientOnPremContractsDigestSignResultMessage {
    static getAttributeTypeMap() {
        return MSEssGatewayClientOnPremContractsDigestSignResultMessage.attributeTypeMap;
    }
}
exports.MSEssGatewayClientOnPremContractsDigestSignResultMessage = MSEssGatewayClientOnPremContractsDigestSignResultMessage;
MSEssGatewayClientOnPremContractsDigestSignResultMessage.discriminator = undefined;
MSEssGatewayClientOnPremContractsDigestSignResultMessage.attributeTypeMap = [
    {
        "name": "algorithm",
        "baseName": "algorithm",
        "type": "string"
    },
    {
        "name": "keyCode",
        "baseName": "keyCode",
        "type": "string"
    },
    {
        "name": "signatures",
        "baseName": "signatures",
        "type": "Array<MSEssGatewayClientOnPremContractsSignedDigest>"
    },
    {
        "name": "certificate",
        "baseName": "certificate",
        "type": "string"
    },
    {
        "name": "operationJson",
        "baseName": "operationJson",
        "type": "string"
    },
    {
        "name": "operationId",
        "baseName": "operationId",
        "type": "string"
    },
    {
        "name": "customerCorrelationId",
        "baseName": "customerCorrelationId",
        "type": "string"
    },
    {
        "name": "groupId",
        "baseName": "groupId",
        "type": "string"
    },
    {
        "name": "status",
        "baseName": "status",
        "type": "MSEssGatewayClientOnPremContractsDigestSignResultMessage.StatusEnum"
    },
    {
        "name": "errorinfo",
        "baseName": "errorinfo",
        "type": "MSEssGatewayClientContractsInnerServiceError"
    },
    {
        "name": "requestSubmittedAt",
        "baseName": "requestSubmittedAt",
        "type": "Date"
    },
    {
        "name": "lastModifiedAt",
        "baseName": "lastModifiedAt",
        "type": "Date"
    },
    {
        "name": "clientId",
        "baseName": "clientId",
        "type": "string"
    },
    {
        "name": "routedRegion",
        "baseName": "routedRegion",
        "type": "string"
    }
];
(function (MSEssGatewayClientOnPremContractsDigestSignResultMessage) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Pass"] = 'pass'] = "Pass";
        StatusEnum[StatusEnum["Inprogress"] = 'inprogress'] = "Inprogress";
        StatusEnum[StatusEnum["FailCanRetry"] = 'failCanRetry'] = "FailCanRetry";
        StatusEnum[StatusEnum["FailDoNotRetry"] = 'failDoNotRetry'] = "FailDoNotRetry";
        StatusEnum[StatusEnum["PendingAnalysis"] = 'pendingAnalysis'] = "PendingAnalysis";
        StatusEnum[StatusEnum["Cancelled"] = 'cancelled'] = "Cancelled";
    })(StatusEnum = MSEssGatewayClientOnPremContractsDigestSignResultMessage.StatusEnum || (MSEssGatewayClientOnPremContractsDigestSignResultMessage.StatusEnum = {}));
})(MSEssGatewayClientOnPremContractsDigestSignResultMessage = exports.MSEssGatewayClientOnPremContractsDigestSignResultMessage || (exports.MSEssGatewayClientOnPremContractsDigestSignResultMessage = {}));
class MSEssGatewayClientOnPremContractsHashInfo {
    static getAttributeTypeMap() {
        return MSEssGatewayClientOnPremContractsHashInfo.attributeTypeMap;
    }
}
exports.MSEssGatewayClientOnPremContractsHashInfo = MSEssGatewayClientOnPremContractsHashInfo;
MSEssGatewayClientOnPremContractsHashInfo.discriminator = undefined;
MSEssGatewayClientOnPremContractsHashInfo.attributeTypeMap = [
    {
        "name": "digest",
        "baseName": "digest",
        "type": "string"
    },
    {
        "name": "hash",
        "baseName": "hash",
        "type": "string"
    }
];
class MSEssGatewayClientOnPremContractsSignedDigest {
    static getAttributeTypeMap() {
        return MSEssGatewayClientOnPremContractsSignedDigest.attributeTypeMap;
    }
}
exports.MSEssGatewayClientOnPremContractsSignedDigest = MSEssGatewayClientOnPremContractsSignedDigest;
MSEssGatewayClientOnPremContractsSignedDigest.discriminator = undefined;
MSEssGatewayClientOnPremContractsSignedDigest.attributeTypeMap = [
    {
        "name": "digest",
        "baseName": "digest",
        "type": "string"
    },
    {
        "name": "hash",
        "baseName": "hash",
        "type": "string"
    },
    {
        "name": "signature",
        "baseName": "signature",
        "type": "string"
    }
];
class MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager = MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager;
MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager.discriminator = undefined;
MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager.attributeTypeMap = [
    {
        "name": "httpContext",
        "baseName": "httpContext",
        "type": "MicrosoftAspNetCoreHttpHttpContext"
    }
];
class MicrosoftAspNetCoreHttpConnectionInfo {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpConnectionInfo.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpConnectionInfo = MicrosoftAspNetCoreHttpConnectionInfo;
MicrosoftAspNetCoreHttpConnectionInfo.discriminator = undefined;
MicrosoftAspNetCoreHttpConnectionInfo.attributeTypeMap = [
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "remoteIpAddress",
        "baseName": "remoteIpAddress",
        "type": "SystemNetIPAddress"
    },
    {
        "name": "remotePort",
        "baseName": "remotePort",
        "type": "number"
    },
    {
        "name": "localIpAddress",
        "baseName": "localIpAddress",
        "type": "SystemNetIPAddress"
    },
    {
        "name": "localPort",
        "baseName": "localPort",
        "type": "number"
    },
    {
        "name": "clientCertificate",
        "baseName": "clientCertificate",
        "type": "any"
    }
];
class MicrosoftAspNetCoreHttpHostString {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpHostString.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpHostString = MicrosoftAspNetCoreHttpHostString;
MicrosoftAspNetCoreHttpHostString.discriminator = undefined;
MicrosoftAspNetCoreHttpHostString.attributeTypeMap = [
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "hasValue",
        "baseName": "hasValue",
        "type": "boolean"
    },
    {
        "name": "host",
        "baseName": "host",
        "type": "string"
    },
    {
        "name": "port",
        "baseName": "port",
        "type": "number"
    }
];
class MicrosoftAspNetCoreHttpHttpContext {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpHttpContext.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpHttpContext = MicrosoftAspNetCoreHttpHttpContext;
MicrosoftAspNetCoreHttpHttpContext.discriminator = undefined;
MicrosoftAspNetCoreHttpHttpContext.attributeTypeMap = [
    {
        "name": "features",
        "baseName": "features",
        "type": "Array<SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_>"
    },
    {
        "name": "request",
        "baseName": "request",
        "type": "MicrosoftAspNetCoreHttpHttpRequest"
    },
    {
        "name": "response",
        "baseName": "response",
        "type": "MicrosoftAspNetCoreHttpHttpResponse"
    },
    {
        "name": "connection",
        "baseName": "connection",
        "type": "MicrosoftAspNetCoreHttpConnectionInfo"
    },
    {
        "name": "webSockets",
        "baseName": "webSockets",
        "type": "MicrosoftAspNetCoreHttpWebSocketManager"
    },
    {
        "name": "authentication",
        "baseName": "authentication",
        "type": "MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager"
    },
    {
        "name": "user",
        "baseName": "user",
        "type": "SystemSecurityClaimsClaimsPrincipal"
    },
    {
        "name": "items",
        "baseName": "items",
        "type": "{ [key: string]: any; }"
    },
    {
        "name": "requestServices",
        "baseName": "requestServices",
        "type": "SystemIServiceProvider"
    },
    {
        "name": "requestAborted",
        "baseName": "requestAborted",
        "type": "SystemThreadingCancellationToken"
    },
    {
        "name": "traceIdentifier",
        "baseName": "traceIdentifier",
        "type": "string"
    },
    {
        "name": "session",
        "baseName": "session",
        "type": "MicrosoftAspNetCoreHttpISession"
    }
];
class MicrosoftAspNetCoreHttpHttpRequest {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpHttpRequest.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpHttpRequest = MicrosoftAspNetCoreHttpHttpRequest;
MicrosoftAspNetCoreHttpHttpRequest.discriminator = undefined;
MicrosoftAspNetCoreHttpHttpRequest.attributeTypeMap = [
    {
        "name": "httpContext",
        "baseName": "httpContext",
        "type": "MicrosoftAspNetCoreHttpHttpContext"
    },
    {
        "name": "method",
        "baseName": "method",
        "type": "string"
    },
    {
        "name": "scheme",
        "baseName": "scheme",
        "type": "string"
    },
    {
        "name": "isHttps",
        "baseName": "isHttps",
        "type": "boolean"
    },
    {
        "name": "host",
        "baseName": "host",
        "type": "MicrosoftAspNetCoreHttpHostString"
    },
    {
        "name": "pathBase",
        "baseName": "pathBase",
        "type": "string"
    },
    {
        "name": "path",
        "baseName": "path",
        "type": "string"
    },
    {
        "name": "queryString",
        "baseName": "queryString",
        "type": "MicrosoftAspNetCoreHttpQueryString"
    },
    {
        "name": "query",
        "baseName": "query",
        "type": "Array<SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_>"
    },
    {
        "name": "protocol",
        "baseName": "protocol",
        "type": "string"
    },
    {
        "name": "headers",
        "baseName": "headers",
        "type": "{ [key: string]: Array<string>; }"
    },
    {
        "name": "cookies",
        "baseName": "cookies",
        "type": "Array<SystemCollectionsGenericKeyValuePair2SystemStringSystemString_>"
    },
    {
        "name": "contentLength",
        "baseName": "contentLength",
        "type": "number"
    },
    {
        "name": "contentType",
        "baseName": "contentType",
        "type": "string"
    },
    {
        "name": "body",
        "baseName": "body",
        "type": "SystemIOStream"
    },
    {
        "name": "hasFormContentType",
        "baseName": "hasFormContentType",
        "type": "boolean"
    },
    {
        "name": "form",
        "baseName": "form",
        "type": "Array<SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_>"
    }
];
class MicrosoftAspNetCoreHttpHttpResponse {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpHttpResponse.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpHttpResponse = MicrosoftAspNetCoreHttpHttpResponse;
MicrosoftAspNetCoreHttpHttpResponse.discriminator = undefined;
MicrosoftAspNetCoreHttpHttpResponse.attributeTypeMap = [
    {
        "name": "httpContext",
        "baseName": "httpContext",
        "type": "MicrosoftAspNetCoreHttpHttpContext"
    },
    {
        "name": "statusCode",
        "baseName": "statusCode",
        "type": "number"
    },
    {
        "name": "headers",
        "baseName": "headers",
        "type": "{ [key: string]: Array<string>; }"
    },
    {
        "name": "body",
        "baseName": "body",
        "type": "SystemIOStream"
    },
    {
        "name": "contentLength",
        "baseName": "contentLength",
        "type": "number"
    },
    {
        "name": "contentType",
        "baseName": "contentType",
        "type": "string"
    },
    {
        "name": "cookies",
        "baseName": "cookies",
        "type": "MicrosoftAspNetCoreHttpIResponseCookies"
    },
    {
        "name": "hasStarted",
        "baseName": "hasStarted",
        "type": "boolean"
    }
];
class MicrosoftAspNetCoreHttpIResponseCookies {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpIResponseCookies.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpIResponseCookies = MicrosoftAspNetCoreHttpIResponseCookies;
MicrosoftAspNetCoreHttpIResponseCookies.discriminator = undefined;
MicrosoftAspNetCoreHttpIResponseCookies.attributeTypeMap = [];
class MicrosoftAspNetCoreHttpISession {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpISession.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpISession = MicrosoftAspNetCoreHttpISession;
MicrosoftAspNetCoreHttpISession.discriminator = undefined;
MicrosoftAspNetCoreHttpISession.attributeTypeMap = [
    {
        "name": "isAvailable",
        "baseName": "isAvailable",
        "type": "boolean"
    },
    {
        "name": "id",
        "baseName": "id",
        "type": "string"
    },
    {
        "name": "keys",
        "baseName": "keys",
        "type": "Array<string>"
    }
];
class MicrosoftAspNetCoreHttpQueryString {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpQueryString.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpQueryString = MicrosoftAspNetCoreHttpQueryString;
MicrosoftAspNetCoreHttpQueryString.discriminator = undefined;
MicrosoftAspNetCoreHttpQueryString.attributeTypeMap = [
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "hasValue",
        "baseName": "hasValue",
        "type": "boolean"
    }
];
class MicrosoftAspNetCoreHttpWebSocketManager {
    static getAttributeTypeMap() {
        return MicrosoftAspNetCoreHttpWebSocketManager.attributeTypeMap;
    }
}
exports.MicrosoftAspNetCoreHttpWebSocketManager = MicrosoftAspNetCoreHttpWebSocketManager;
MicrosoftAspNetCoreHttpWebSocketManager.discriminator = undefined;
MicrosoftAspNetCoreHttpWebSocketManager.attributeTypeMap = [
    {
        "name": "isWebSocketRequest",
        "baseName": "isWebSocketRequest",
        "type": "boolean"
    },
    {
        "name": "webSocketRequestedProtocols",
        "baseName": "webSocketRequestedProtocols",
        "type": "Array<string>"
    }
];
class MicrosoftAspNetODataODataQueryContext {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataODataQueryContext.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataODataQueryContext = MicrosoftAspNetODataODataQueryContext;
MicrosoftAspNetODataODataQueryContext.discriminator = undefined;
MicrosoftAspNetODataODataQueryContext.attributeTypeMap = [
    {
        "name": "defaultQuerySettings",
        "baseName": "defaultQuerySettings",
        "type": "MicrosoftAspNetODataQueryDefaultQuerySettings"
    },
    {
        "name": "model",
        "baseName": "model",
        "type": "MicrosoftODataEdmIEdmModel"
    },
    {
        "name": "elementType",
        "baseName": "elementType",
        "type": "MicrosoftODataEdmIEdmType"
    },
    {
        "name": "navigationSource",
        "baseName": "navigationSource",
        "type": "MicrosoftODataEdmIEdmNavigationSource"
    },
    {
        "name": "elementClrType",
        "baseName": "elementClrType",
        "type": "string"
    },
    {
        "name": "path",
        "baseName": "path",
        "type": "MicrosoftAspNetODataRoutingODataPath"
    },
    {
        "name": "requestContainer",
        "baseName": "requestContainer",
        "type": "SystemIServiceProvider"
    }
];
class MicrosoftAspNetODataQueryApplyQueryOption {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryApplyQueryOption.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryApplyQueryOption = MicrosoftAspNetODataQueryApplyQueryOption;
MicrosoftAspNetODataQueryApplyQueryOption.discriminator = undefined;
MicrosoftAspNetODataQueryApplyQueryOption.attributeTypeMap = [
    {
        "name": "context",
        "baseName": "context",
        "type": "MicrosoftAspNetODataODataQueryContext"
    },
    {
        "name": "resultClrType",
        "baseName": "resultClrType",
        "type": "string"
    },
    {
        "name": "applyClause",
        "baseName": "applyClause",
        "type": "MicrosoftODataUriParserAggregationApplyClause"
    },
    {
        "name": "rawValue",
        "baseName": "rawValue",
        "type": "string"
    }
];
class MicrosoftAspNetODataQueryCountQueryOption {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryCountQueryOption.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryCountQueryOption = MicrosoftAspNetODataQueryCountQueryOption;
MicrosoftAspNetODataQueryCountQueryOption.discriminator = undefined;
MicrosoftAspNetODataQueryCountQueryOption.attributeTypeMap = [
    {
        "name": "context",
        "baseName": "context",
        "type": "MicrosoftAspNetODataODataQueryContext"
    },
    {
        "name": "rawValue",
        "baseName": "rawValue",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "boolean"
    },
    {
        "name": "validator",
        "baseName": "validator",
        "type": "MicrosoftAspNetODataQueryValidatorsCountQueryValidator"
    }
];
class MicrosoftAspNetODataQueryDefaultQuerySettings {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryDefaultQuerySettings.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryDefaultQuerySettings = MicrosoftAspNetODataQueryDefaultQuerySettings;
MicrosoftAspNetODataQueryDefaultQuerySettings.discriminator = undefined;
MicrosoftAspNetODataQueryDefaultQuerySettings.attributeTypeMap = [
    {
        "name": "enableExpand",
        "baseName": "enableExpand",
        "type": "boolean"
    },
    {
        "name": "enableSelect",
        "baseName": "enableSelect",
        "type": "boolean"
    },
    {
        "name": "enableCount",
        "baseName": "enableCount",
        "type": "boolean"
    },
    {
        "name": "enableOrderBy",
        "baseName": "enableOrderBy",
        "type": "boolean"
    },
    {
        "name": "enableFilter",
        "baseName": "enableFilter",
        "type": "boolean"
    },
    {
        "name": "maxTop",
        "baseName": "maxTop",
        "type": "number"
    },
    {
        "name": "enableSkipToken",
        "baseName": "enableSkipToken",
        "type": "boolean"
    }
];
class MicrosoftAspNetODataQueryFilterQueryOption {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryFilterQueryOption.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryFilterQueryOption = MicrosoftAspNetODataQueryFilterQueryOption;
MicrosoftAspNetODataQueryFilterQueryOption.discriminator = undefined;
MicrosoftAspNetODataQueryFilterQueryOption.attributeTypeMap = [
    {
        "name": "context",
        "baseName": "context",
        "type": "MicrosoftAspNetODataODataQueryContext"
    },
    {
        "name": "validator",
        "baseName": "validator",
        "type": "MicrosoftAspNetODataQueryValidatorsFilterQueryValidator"
    },
    {
        "name": "filterClause",
        "baseName": "filterClause",
        "type": "MicrosoftODataUriParserFilterClause"
    },
    {
        "name": "rawValue",
        "baseName": "rawValue",
        "type": "string"
    }
];
class MicrosoftAspNetODataQueryODataQueryOptions {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryODataQueryOptions.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryODataQueryOptions = MicrosoftAspNetODataQueryODataQueryOptions;
MicrosoftAspNetODataQueryODataQueryOptions.discriminator = undefined;
MicrosoftAspNetODataQueryODataQueryOptions.attributeTypeMap = [
    {
        "name": "request",
        "baseName": "request",
        "type": "MicrosoftAspNetCoreHttpHttpRequest"
    },
    {
        "name": "context",
        "baseName": "context",
        "type": "MicrosoftAspNetODataODataQueryContext"
    },
    {
        "name": "rawValues",
        "baseName": "rawValues",
        "type": "MicrosoftAspNetODataQueryODataRawQueryOptions"
    },
    {
        "name": "selectExpand",
        "baseName": "selectExpand",
        "type": "MicrosoftAspNetODataQuerySelectExpandQueryOption"
    },
    {
        "name": "apply",
        "baseName": "apply",
        "type": "MicrosoftAspNetODataQueryApplyQueryOption"
    },
    {
        "name": "filter",
        "baseName": "filter",
        "type": "MicrosoftAspNetODataQueryFilterQueryOption"
    },
    {
        "name": "orderBy",
        "baseName": "orderBy",
        "type": "MicrosoftAspNetODataQueryOrderByQueryOption"
    },
    {
        "name": "skip",
        "baseName": "skip",
        "type": "MicrosoftAspNetODataQuerySkipQueryOption"
    },
    {
        "name": "skipToken",
        "baseName": "skipToken",
        "type": "MicrosoftAspNetODataQuerySkipTokenQueryOption"
    },
    {
        "name": "top",
        "baseName": "top",
        "type": "MicrosoftAspNetODataQueryTopQueryOption"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "MicrosoftAspNetODataQueryCountQueryOption"
    },
    {
        "name": "validator",
        "baseName": "validator",
        "type": "MicrosoftAspNetODataQueryValidatorsODataQueryValidator"
    },
    {
        "name": "ifMatch",
        "baseName": "ifMatch",
        "type": "any"
    },
    {
        "name": "ifNoneMatch",
        "baseName": "ifNoneMatch",
        "type": "any"
    }
];
class MicrosoftAspNetODataQueryODataQuerySettings {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryODataQuerySettings.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryODataQuerySettings = MicrosoftAspNetODataQueryODataQuerySettings;
MicrosoftAspNetODataQueryODataQuerySettings.discriminator = undefined;
MicrosoftAspNetODataQueryODataQuerySettings.attributeTypeMap = [
    {
        "name": "ensureStableOrdering",
        "baseName": "ensureStableOrdering",
        "type": "boolean"
    },
    {
        "name": "handleNullPropagation",
        "baseName": "handleNullPropagation",
        "type": "MicrosoftAspNetODataQueryODataQuerySettings.HandleNullPropagationEnum"
    },
    {
        "name": "enableConstantParameterization",
        "baseName": "enableConstantParameterization",
        "type": "boolean"
    },
    {
        "name": "enableCorrelatedSubqueryBuffering",
        "baseName": "enableCorrelatedSubqueryBuffering",
        "type": "boolean"
    },
    {
        "name": "pageSize",
        "baseName": "pageSize",
        "type": "number"
    },
    {
        "name": "handleReferenceNavigationPropertyExpandFilter",
        "baseName": "handleReferenceNavigationPropertyExpandFilter",
        "type": "boolean"
    }
];
(function (MicrosoftAspNetODataQueryODataQuerySettings) {
    let HandleNullPropagationEnum;
    (function (HandleNullPropagationEnum) {
        HandleNullPropagationEnum[HandleNullPropagationEnum["Default"] = 'default'] = "Default";
        HandleNullPropagationEnum[HandleNullPropagationEnum["True"] = 'true'] = "True";
        HandleNullPropagationEnum[HandleNullPropagationEnum["False"] = 'false'] = "False";
    })(HandleNullPropagationEnum = MicrosoftAspNetODataQueryODataQuerySettings.HandleNullPropagationEnum || (MicrosoftAspNetODataQueryODataQuerySettings.HandleNullPropagationEnum = {}));
})(MicrosoftAspNetODataQueryODataQuerySettings = exports.MicrosoftAspNetODataQueryODataQuerySettings || (exports.MicrosoftAspNetODataQueryODataQuerySettings = {}));
class MicrosoftAspNetODataQueryODataRawQueryOptions {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryODataRawQueryOptions.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryODataRawQueryOptions = MicrosoftAspNetODataQueryODataRawQueryOptions;
MicrosoftAspNetODataQueryODataRawQueryOptions.discriminator = undefined;
MicrosoftAspNetODataQueryODataRawQueryOptions.attributeTypeMap = [
    {
        "name": "filter",
        "baseName": "filter",
        "type": "string"
    },
    {
        "name": "apply",
        "baseName": "apply",
        "type": "string"
    },
    {
        "name": "orderBy",
        "baseName": "orderBy",
        "type": "string"
    },
    {
        "name": "top",
        "baseName": "top",
        "type": "string"
    },
    {
        "name": "skip",
        "baseName": "skip",
        "type": "string"
    },
    {
        "name": "select",
        "baseName": "select",
        "type": "string"
    },
    {
        "name": "expand",
        "baseName": "expand",
        "type": "string"
    },
    {
        "name": "count",
        "baseName": "count",
        "type": "string"
    },
    {
        "name": "format",
        "baseName": "format",
        "type": "string"
    },
    {
        "name": "skipToken",
        "baseName": "skipToken",
        "type": "string"
    },
    {
        "name": "deltaToken",
        "baseName": "deltaToken",
        "type": "string"
    }
];
class MicrosoftAspNetODataQueryOrderByNode {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryOrderByNode.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryOrderByNode = MicrosoftAspNetODataQueryOrderByNode;
MicrosoftAspNetODataQueryOrderByNode.discriminator = undefined;
MicrosoftAspNetODataQueryOrderByNode.attributeTypeMap = [
    {
        "name": "direction",
        "baseName": "direction",
        "type": "MicrosoftAspNetODataQueryOrderByNode.DirectionEnum"
    }
];
(function (MicrosoftAspNetODataQueryOrderByNode) {
    let DirectionEnum;
    (function (DirectionEnum) {
        DirectionEnum[DirectionEnum["Ascending"] = 'ascending'] = "Ascending";
        DirectionEnum[DirectionEnum["Descending"] = 'descending'] = "Descending";
    })(DirectionEnum = MicrosoftAspNetODataQueryOrderByNode.DirectionEnum || (MicrosoftAspNetODataQueryOrderByNode.DirectionEnum = {}));
})(MicrosoftAspNetODataQueryOrderByNode = exports.MicrosoftAspNetODataQueryOrderByNode || (exports.MicrosoftAspNetODataQueryOrderByNode = {}));
class MicrosoftAspNetODataQueryOrderByQueryOption {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryOrderByQueryOption.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryOrderByQueryOption = MicrosoftAspNetODataQueryOrderByQueryOption;
MicrosoftAspNetODataQueryOrderByQueryOption.discriminator = undefined;
MicrosoftAspNetODataQueryOrderByQueryOption.attributeTypeMap = [
    {
        "name": "context",
        "baseName": "context",
        "type": "MicrosoftAspNetODataODataQueryContext"
    },
    {
        "name": "orderByNodes",
        "baseName": "orderByNodes",
        "type": "Array<MicrosoftAspNetODataQueryOrderByNode>"
    },
    {
        "name": "rawValue",
        "baseName": "rawValue",
        "type": "string"
    },
    {
        "name": "validator",
        "baseName": "validator",
        "type": "MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator"
    },
    {
        "name": "orderByClause",
        "baseName": "orderByClause",
        "type": "MicrosoftODataUriParserOrderByClause"
    }
];
class MicrosoftAspNetODataQuerySelectExpandQueryOption {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQuerySelectExpandQueryOption.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQuerySelectExpandQueryOption = MicrosoftAspNetODataQuerySelectExpandQueryOption;
MicrosoftAspNetODataQuerySelectExpandQueryOption.discriminator = undefined;
MicrosoftAspNetODataQuerySelectExpandQueryOption.attributeTypeMap = [
    {
        "name": "context",
        "baseName": "context",
        "type": "MicrosoftAspNetODataODataQueryContext"
    },
    {
        "name": "rawSelect",
        "baseName": "rawSelect",
        "type": "string"
    },
    {
        "name": "rawExpand",
        "baseName": "rawExpand",
        "type": "string"
    },
    {
        "name": "validator",
        "baseName": "validator",
        "type": "MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator"
    },
    {
        "name": "selectExpandClause",
        "baseName": "selectExpandClause",
        "type": "MicrosoftODataUriParserSelectExpandClause"
    },
    {
        "name": "levelsMaxLiteralExpansionDepth",
        "baseName": "levelsMaxLiteralExpansionDepth",
        "type": "number"
    }
];
class MicrosoftAspNetODataQuerySkipQueryOption {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQuerySkipQueryOption.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQuerySkipQueryOption = MicrosoftAspNetODataQuerySkipQueryOption;
MicrosoftAspNetODataQuerySkipQueryOption.discriminator = undefined;
MicrosoftAspNetODataQuerySkipQueryOption.attributeTypeMap = [
    {
        "name": "context",
        "baseName": "context",
        "type": "MicrosoftAspNetODataODataQueryContext"
    },
    {
        "name": "rawValue",
        "baseName": "rawValue",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "number"
    },
    {
        "name": "validator",
        "baseName": "validator",
        "type": "MicrosoftAspNetODataQueryValidatorsSkipQueryValidator"
    }
];
class MicrosoftAspNetODataQuerySkipTokenQueryOption {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQuerySkipTokenQueryOption.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQuerySkipTokenQueryOption = MicrosoftAspNetODataQuerySkipTokenQueryOption;
MicrosoftAspNetODataQuerySkipTokenQueryOption.discriminator = undefined;
MicrosoftAspNetODataQuerySkipTokenQueryOption.attributeTypeMap = [
    {
        "name": "rawValue",
        "baseName": "rawValue",
        "type": "string"
    },
    {
        "name": "context",
        "baseName": "context",
        "type": "MicrosoftAspNetODataODataQueryContext"
    },
    {
        "name": "validator",
        "baseName": "validator",
        "type": "MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator"
    },
    {
        "name": "querySettings",
        "baseName": "querySettings",
        "type": "MicrosoftAspNetODataQueryODataQuerySettings"
    },
    {
        "name": "queryOptions",
        "baseName": "queryOptions",
        "type": "MicrosoftAspNetODataQueryODataQueryOptions"
    }
];
class MicrosoftAspNetODataQueryTopQueryOption {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryTopQueryOption.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryTopQueryOption = MicrosoftAspNetODataQueryTopQueryOption;
MicrosoftAspNetODataQueryTopQueryOption.discriminator = undefined;
MicrosoftAspNetODataQueryTopQueryOption.attributeTypeMap = [
    {
        "name": "context",
        "baseName": "context",
        "type": "MicrosoftAspNetODataODataQueryContext"
    },
    {
        "name": "rawValue",
        "baseName": "rawValue",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "number"
    },
    {
        "name": "validator",
        "baseName": "validator",
        "type": "MicrosoftAspNetODataQueryValidatorsTopQueryValidator"
    }
];
class MicrosoftAspNetODataQueryValidatorsCountQueryValidator {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryValidatorsCountQueryValidator.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryValidatorsCountQueryValidator = MicrosoftAspNetODataQueryValidatorsCountQueryValidator;
MicrosoftAspNetODataQueryValidatorsCountQueryValidator.discriminator = undefined;
MicrosoftAspNetODataQueryValidatorsCountQueryValidator.attributeTypeMap = [];
class MicrosoftAspNetODataQueryValidatorsFilterQueryValidator {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryValidatorsFilterQueryValidator.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryValidatorsFilterQueryValidator = MicrosoftAspNetODataQueryValidatorsFilterQueryValidator;
MicrosoftAspNetODataQueryValidatorsFilterQueryValidator.discriminator = undefined;
MicrosoftAspNetODataQueryValidatorsFilterQueryValidator.attributeTypeMap = [];
class MicrosoftAspNetODataQueryValidatorsODataQueryValidator {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryValidatorsODataQueryValidator.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryValidatorsODataQueryValidator = MicrosoftAspNetODataQueryValidatorsODataQueryValidator;
MicrosoftAspNetODataQueryValidatorsODataQueryValidator.discriminator = undefined;
MicrosoftAspNetODataQueryValidatorsODataQueryValidator.attributeTypeMap = [];
class MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator = MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator;
MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator.discriminator = undefined;
MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator.attributeTypeMap = [];
class MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator = MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator;
MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator.discriminator = undefined;
MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator.attributeTypeMap = [];
class MicrosoftAspNetODataQueryValidatorsSkipQueryValidator {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryValidatorsSkipQueryValidator.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryValidatorsSkipQueryValidator = MicrosoftAspNetODataQueryValidatorsSkipQueryValidator;
MicrosoftAspNetODataQueryValidatorsSkipQueryValidator.discriminator = undefined;
MicrosoftAspNetODataQueryValidatorsSkipQueryValidator.attributeTypeMap = [];
class MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator = MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator;
MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator.discriminator = undefined;
MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator.attributeTypeMap = [];
class MicrosoftAspNetODataQueryValidatorsTopQueryValidator {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataQueryValidatorsTopQueryValidator.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataQueryValidatorsTopQueryValidator = MicrosoftAspNetODataQueryValidatorsTopQueryValidator;
MicrosoftAspNetODataQueryValidatorsTopQueryValidator.discriminator = undefined;
MicrosoftAspNetODataQueryValidatorsTopQueryValidator.attributeTypeMap = [];
class MicrosoftAspNetODataRoutingODataPath {
    static getAttributeTypeMap() {
        return MicrosoftAspNetODataRoutingODataPath.attributeTypeMap;
    }
}
exports.MicrosoftAspNetODataRoutingODataPath = MicrosoftAspNetODataRoutingODataPath;
MicrosoftAspNetODataRoutingODataPath.discriminator = undefined;
MicrosoftAspNetODataRoutingODataPath.attributeTypeMap = [
    {
        "name": "edmType",
        "baseName": "edmType",
        "type": "MicrosoftODataEdmIEdmType"
    },
    {
        "name": "navigationSource",
        "baseName": "navigationSource",
        "type": "MicrosoftODataEdmIEdmNavigationSource"
    },
    {
        "name": "segments",
        "baseName": "segments",
        "type": "Array<MicrosoftODataUriParserODataPathSegment>"
    },
    {
        "name": "pathTemplate",
        "baseName": "pathTemplate",
        "type": "string"
    },
    {
        "name": "path",
        "baseName": "path",
        "type": "Array<MicrosoftODataUriParserODataPathSegment>"
    }
];
class MicrosoftODataEdmEdmReferentialConstraintPropertyPair {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmEdmReferentialConstraintPropertyPair.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmEdmReferentialConstraintPropertyPair = MicrosoftODataEdmEdmReferentialConstraintPropertyPair;
MicrosoftODataEdmEdmReferentialConstraintPropertyPair.discriminator = undefined;
MicrosoftODataEdmEdmReferentialConstraintPropertyPair.attributeTypeMap = [
    {
        "name": "dependentProperty",
        "baseName": "dependentProperty",
        "type": "MicrosoftODataEdmIEdmStructuralProperty"
    },
    {
        "name": "principalProperty",
        "baseName": "principalProperty",
        "type": "MicrosoftODataEdmIEdmStructuralProperty"
    }
];
class MicrosoftODataEdmIEdmEntityContainer {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmEntityContainer.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmEntityContainer = MicrosoftODataEdmIEdmEntityContainer;
MicrosoftODataEdmIEdmEntityContainer.discriminator = undefined;
MicrosoftODataEdmIEdmEntityContainer.attributeTypeMap = [
    {
        "name": "elements",
        "baseName": "elements",
        "type": "Array<MicrosoftODataEdmIEdmEntityContainerElement>"
    },
    {
        "name": "schemaElementKind",
        "baseName": "schemaElementKind",
        "type": "MicrosoftODataEdmIEdmEntityContainer.SchemaElementKindEnum"
    },
    {
        "name": "namespace",
        "baseName": "namespace",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];
(function (MicrosoftODataEdmIEdmEntityContainer) {
    let SchemaElementKindEnum;
    (function (SchemaElementKindEnum) {
        SchemaElementKindEnum[SchemaElementKindEnum["None"] = 'none'] = "None";
        SchemaElementKindEnum[SchemaElementKindEnum["TypeDefinition"] = 'typeDefinition'] = "TypeDefinition";
        SchemaElementKindEnum[SchemaElementKindEnum["Term"] = 'term'] = "Term";
        SchemaElementKindEnum[SchemaElementKindEnum["Action"] = 'action'] = "Action";
        SchemaElementKindEnum[SchemaElementKindEnum["EntityContainer"] = 'entityContainer'] = "EntityContainer";
        SchemaElementKindEnum[SchemaElementKindEnum["Function"] = 'function'] = "Function";
    })(SchemaElementKindEnum = MicrosoftODataEdmIEdmEntityContainer.SchemaElementKindEnum || (MicrosoftODataEdmIEdmEntityContainer.SchemaElementKindEnum = {}));
})(MicrosoftODataEdmIEdmEntityContainer = exports.MicrosoftODataEdmIEdmEntityContainer || (exports.MicrosoftODataEdmIEdmEntityContainer = {}));
class MicrosoftODataEdmIEdmEntityContainerElement {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmEntityContainerElement.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmEntityContainerElement = MicrosoftODataEdmIEdmEntityContainerElement;
MicrosoftODataEdmIEdmEntityContainerElement.discriminator = undefined;
MicrosoftODataEdmIEdmEntityContainerElement.attributeTypeMap = [
    {
        "name": "containerElementKind",
        "baseName": "containerElementKind",
        "type": "MicrosoftODataEdmIEdmEntityContainerElement.ContainerElementKindEnum"
    },
    {
        "name": "container",
        "baseName": "container",
        "type": "MicrosoftODataEdmIEdmEntityContainer"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];
(function (MicrosoftODataEdmIEdmEntityContainerElement) {
    let ContainerElementKindEnum;
    (function (ContainerElementKindEnum) {
        ContainerElementKindEnum[ContainerElementKindEnum["None"] = 'none'] = "None";
        ContainerElementKindEnum[ContainerElementKindEnum["EntitySet"] = 'entitySet'] = "EntitySet";
        ContainerElementKindEnum[ContainerElementKindEnum["ActionImport"] = 'actionImport'] = "ActionImport";
        ContainerElementKindEnum[ContainerElementKindEnum["FunctionImport"] = 'functionImport'] = "FunctionImport";
        ContainerElementKindEnum[ContainerElementKindEnum["Singleton"] = 'singleton'] = "Singleton";
    })(ContainerElementKindEnum = MicrosoftODataEdmIEdmEntityContainerElement.ContainerElementKindEnum || (MicrosoftODataEdmIEdmEntityContainerElement.ContainerElementKindEnum = {}));
})(MicrosoftODataEdmIEdmEntityContainerElement = exports.MicrosoftODataEdmIEdmEntityContainerElement || (exports.MicrosoftODataEdmIEdmEntityContainerElement = {}));
class MicrosoftODataEdmIEdmExpression {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmExpression.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmExpression = MicrosoftODataEdmIEdmExpression;
MicrosoftODataEdmIEdmExpression.discriminator = undefined;
MicrosoftODataEdmIEdmExpression.attributeTypeMap = [
    {
        "name": "expressionKind",
        "baseName": "expressionKind",
        "type": "MicrosoftODataEdmIEdmExpression.ExpressionKindEnum"
    }
];
(function (MicrosoftODataEdmIEdmExpression) {
    let ExpressionKindEnum;
    (function (ExpressionKindEnum) {
        ExpressionKindEnum[ExpressionKindEnum["None"] = 'none'] = "None";
        ExpressionKindEnum[ExpressionKindEnum["BinaryConstant"] = 'binaryConstant'] = "BinaryConstant";
        ExpressionKindEnum[ExpressionKindEnum["BooleanConstant"] = 'booleanConstant'] = "BooleanConstant";
        ExpressionKindEnum[ExpressionKindEnum["DateTimeOffsetConstant"] = 'dateTimeOffsetConstant'] = "DateTimeOffsetConstant";
        ExpressionKindEnum[ExpressionKindEnum["DecimalConstant"] = 'decimalConstant'] = "DecimalConstant";
        ExpressionKindEnum[ExpressionKindEnum["FloatingConstant"] = 'floatingConstant'] = "FloatingConstant";
        ExpressionKindEnum[ExpressionKindEnum["GuidConstant"] = 'guidConstant'] = "GuidConstant";
        ExpressionKindEnum[ExpressionKindEnum["IntegerConstant"] = 'integerConstant'] = "IntegerConstant";
        ExpressionKindEnum[ExpressionKindEnum["StringConstant"] = 'stringConstant'] = "StringConstant";
        ExpressionKindEnum[ExpressionKindEnum["DurationConstant"] = 'durationConstant'] = "DurationConstant";
        ExpressionKindEnum[ExpressionKindEnum["Null"] = 'null'] = "Null";
        ExpressionKindEnum[ExpressionKindEnum["Record"] = 'record'] = "Record";
        ExpressionKindEnum[ExpressionKindEnum["Collection"] = 'collection'] = "Collection";
        ExpressionKindEnum[ExpressionKindEnum["Path"] = 'path'] = "Path";
        ExpressionKindEnum[ExpressionKindEnum["If"] = 'if'] = "If";
        ExpressionKindEnum[ExpressionKindEnum["Cast"] = 'cast'] = "Cast";
        ExpressionKindEnum[ExpressionKindEnum["IsType"] = 'isType'] = "IsType";
        ExpressionKindEnum[ExpressionKindEnum["FunctionApplication"] = 'functionApplication'] = "FunctionApplication";
        ExpressionKindEnum[ExpressionKindEnum["LabeledExpressionReference"] = 'labeledExpressionReference'] = "LabeledExpressionReference";
        ExpressionKindEnum[ExpressionKindEnum["Labeled"] = 'labeled'] = "Labeled";
        ExpressionKindEnum[ExpressionKindEnum["PropertyPath"] = 'propertyPath'] = "PropertyPath";
        ExpressionKindEnum[ExpressionKindEnum["NavigationPropertyPath"] = 'navigationPropertyPath'] = "NavigationPropertyPath";
        ExpressionKindEnum[ExpressionKindEnum["DateConstant"] = 'dateConstant'] = "DateConstant";
        ExpressionKindEnum[ExpressionKindEnum["TimeOfDayConstant"] = 'timeOfDayConstant'] = "TimeOfDayConstant";
        ExpressionKindEnum[ExpressionKindEnum["EnumMember"] = 'enumMember'] = "EnumMember";
        ExpressionKindEnum[ExpressionKindEnum["AnnotationPath"] = 'annotationPath'] = "AnnotationPath";
    })(ExpressionKindEnum = MicrosoftODataEdmIEdmExpression.ExpressionKindEnum || (MicrosoftODataEdmIEdmExpression.ExpressionKindEnum = {}));
})(MicrosoftODataEdmIEdmExpression = exports.MicrosoftODataEdmIEdmExpression || (exports.MicrosoftODataEdmIEdmExpression = {}));
class MicrosoftODataEdmIEdmModel {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmModel.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmModel = MicrosoftODataEdmIEdmModel;
MicrosoftODataEdmIEdmModel.discriminator = undefined;
MicrosoftODataEdmIEdmModel.attributeTypeMap = [
    {
        "name": "schemaElements",
        "baseName": "schemaElements",
        "type": "Array<MicrosoftODataEdmIEdmSchemaElement>"
    },
    {
        "name": "vocabularyAnnotations",
        "baseName": "vocabularyAnnotations",
        "type": "Array<MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation>"
    },
    {
        "name": "referencedModels",
        "baseName": "referencedModels",
        "type": "Array<MicrosoftODataEdmIEdmModel>"
    },
    {
        "name": "declaredNamespaces",
        "baseName": "declaredNamespaces",
        "type": "Array<string>"
    },
    {
        "name": "directValueAnnotationsManager",
        "baseName": "directValueAnnotationsManager",
        "type": "MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager"
    },
    {
        "name": "entityContainer",
        "baseName": "entityContainer",
        "type": "MicrosoftODataEdmIEdmEntityContainer"
    }
];
class MicrosoftODataEdmIEdmNavigationProperty {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmNavigationProperty.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmNavigationProperty = MicrosoftODataEdmIEdmNavigationProperty;
MicrosoftODataEdmIEdmNavigationProperty.discriminator = undefined;
MicrosoftODataEdmIEdmNavigationProperty.attributeTypeMap = [
    {
        "name": "partner",
        "baseName": "partner",
        "type": "MicrosoftODataEdmIEdmNavigationProperty"
    },
    {
        "name": "onDelete",
        "baseName": "onDelete",
        "type": "MicrosoftODataEdmIEdmNavigationProperty.OnDeleteEnum"
    },
    {
        "name": "containsTarget",
        "baseName": "containsTarget",
        "type": "boolean"
    },
    {
        "name": "referentialConstraint",
        "baseName": "referentialConstraint",
        "type": "MicrosoftODataEdmIEdmReferentialConstraint"
    },
    {
        "name": "propertyKind",
        "baseName": "propertyKind",
        "type": "MicrosoftODataEdmIEdmNavigationProperty.PropertyKindEnum"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "MicrosoftODataEdmIEdmTypeReference"
    },
    {
        "name": "declaringType",
        "baseName": "declaringType",
        "type": "MicrosoftODataEdmIEdmStructuredType"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];
(function (MicrosoftODataEdmIEdmNavigationProperty) {
    let OnDeleteEnum;
    (function (OnDeleteEnum) {
        OnDeleteEnum[OnDeleteEnum["None"] = 'none'] = "None";
        OnDeleteEnum[OnDeleteEnum["Cascade"] = 'cascade'] = "Cascade";
    })(OnDeleteEnum = MicrosoftODataEdmIEdmNavigationProperty.OnDeleteEnum || (MicrosoftODataEdmIEdmNavigationProperty.OnDeleteEnum = {}));
    let PropertyKindEnum;
    (function (PropertyKindEnum) {
        PropertyKindEnum[PropertyKindEnum["None"] = 'none'] = "None";
        PropertyKindEnum[PropertyKindEnum["Structural"] = 'structural'] = "Structural";
        PropertyKindEnum[PropertyKindEnum["Navigation"] = 'navigation'] = "Navigation";
    })(PropertyKindEnum = MicrosoftODataEdmIEdmNavigationProperty.PropertyKindEnum || (MicrosoftODataEdmIEdmNavigationProperty.PropertyKindEnum = {}));
})(MicrosoftODataEdmIEdmNavigationProperty = exports.MicrosoftODataEdmIEdmNavigationProperty || (exports.MicrosoftODataEdmIEdmNavigationProperty = {}));
class MicrosoftODataEdmIEdmNavigationPropertyBinding {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmNavigationPropertyBinding.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmNavigationPropertyBinding = MicrosoftODataEdmIEdmNavigationPropertyBinding;
MicrosoftODataEdmIEdmNavigationPropertyBinding.discriminator = undefined;
MicrosoftODataEdmIEdmNavigationPropertyBinding.attributeTypeMap = [
    {
        "name": "navigationProperty",
        "baseName": "navigationProperty",
        "type": "MicrosoftODataEdmIEdmNavigationProperty"
    },
    {
        "name": "target",
        "baseName": "target",
        "type": "MicrosoftODataEdmIEdmNavigationSource"
    },
    {
        "name": "path",
        "baseName": "path",
        "type": "MicrosoftODataEdmIEdmPathExpression"
    }
];
class MicrosoftODataEdmIEdmNavigationSource {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmNavigationSource.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmNavigationSource = MicrosoftODataEdmIEdmNavigationSource;
MicrosoftODataEdmIEdmNavigationSource.discriminator = undefined;
MicrosoftODataEdmIEdmNavigationSource.attributeTypeMap = [
    {
        "name": "navigationPropertyBindings",
        "baseName": "navigationPropertyBindings",
        "type": "Array<MicrosoftODataEdmIEdmNavigationPropertyBinding>"
    },
    {
        "name": "path",
        "baseName": "path",
        "type": "MicrosoftODataEdmIEdmPathExpression"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "MicrosoftODataEdmIEdmType"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];
class MicrosoftODataEdmIEdmPathExpression {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmPathExpression.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmPathExpression = MicrosoftODataEdmIEdmPathExpression;
MicrosoftODataEdmIEdmPathExpression.discriminator = undefined;
MicrosoftODataEdmIEdmPathExpression.attributeTypeMap = [
    {
        "name": "pathSegments",
        "baseName": "pathSegments",
        "type": "Array<string>"
    },
    {
        "name": "path",
        "baseName": "path",
        "type": "string"
    },
    {
        "name": "expressionKind",
        "baseName": "expressionKind",
        "type": "MicrosoftODataEdmIEdmPathExpression.ExpressionKindEnum"
    }
];
(function (MicrosoftODataEdmIEdmPathExpression) {
    let ExpressionKindEnum;
    (function (ExpressionKindEnum) {
        ExpressionKindEnum[ExpressionKindEnum["None"] = 'none'] = "None";
        ExpressionKindEnum[ExpressionKindEnum["BinaryConstant"] = 'binaryConstant'] = "BinaryConstant";
        ExpressionKindEnum[ExpressionKindEnum["BooleanConstant"] = 'booleanConstant'] = "BooleanConstant";
        ExpressionKindEnum[ExpressionKindEnum["DateTimeOffsetConstant"] = 'dateTimeOffsetConstant'] = "DateTimeOffsetConstant";
        ExpressionKindEnum[ExpressionKindEnum["DecimalConstant"] = 'decimalConstant'] = "DecimalConstant";
        ExpressionKindEnum[ExpressionKindEnum["FloatingConstant"] = 'floatingConstant'] = "FloatingConstant";
        ExpressionKindEnum[ExpressionKindEnum["GuidConstant"] = 'guidConstant'] = "GuidConstant";
        ExpressionKindEnum[ExpressionKindEnum["IntegerConstant"] = 'integerConstant'] = "IntegerConstant";
        ExpressionKindEnum[ExpressionKindEnum["StringConstant"] = 'stringConstant'] = "StringConstant";
        ExpressionKindEnum[ExpressionKindEnum["DurationConstant"] = 'durationConstant'] = "DurationConstant";
        ExpressionKindEnum[ExpressionKindEnum["Null"] = 'null'] = "Null";
        ExpressionKindEnum[ExpressionKindEnum["Record"] = 'record'] = "Record";
        ExpressionKindEnum[ExpressionKindEnum["Collection"] = 'collection'] = "Collection";
        ExpressionKindEnum[ExpressionKindEnum["Path"] = 'path'] = "Path";
        ExpressionKindEnum[ExpressionKindEnum["If"] = 'if'] = "If";
        ExpressionKindEnum[ExpressionKindEnum["Cast"] = 'cast'] = "Cast";
        ExpressionKindEnum[ExpressionKindEnum["IsType"] = 'isType'] = "IsType";
        ExpressionKindEnum[ExpressionKindEnum["FunctionApplication"] = 'functionApplication'] = "FunctionApplication";
        ExpressionKindEnum[ExpressionKindEnum["LabeledExpressionReference"] = 'labeledExpressionReference'] = "LabeledExpressionReference";
        ExpressionKindEnum[ExpressionKindEnum["Labeled"] = 'labeled'] = "Labeled";
        ExpressionKindEnum[ExpressionKindEnum["PropertyPath"] = 'propertyPath'] = "PropertyPath";
        ExpressionKindEnum[ExpressionKindEnum["NavigationPropertyPath"] = 'navigationPropertyPath'] = "NavigationPropertyPath";
        ExpressionKindEnum[ExpressionKindEnum["DateConstant"] = 'dateConstant'] = "DateConstant";
        ExpressionKindEnum[ExpressionKindEnum["TimeOfDayConstant"] = 'timeOfDayConstant'] = "TimeOfDayConstant";
        ExpressionKindEnum[ExpressionKindEnum["EnumMember"] = 'enumMember'] = "EnumMember";
        ExpressionKindEnum[ExpressionKindEnum["AnnotationPath"] = 'annotationPath'] = "AnnotationPath";
    })(ExpressionKindEnum = MicrosoftODataEdmIEdmPathExpression.ExpressionKindEnum || (MicrosoftODataEdmIEdmPathExpression.ExpressionKindEnum = {}));
})(MicrosoftODataEdmIEdmPathExpression = exports.MicrosoftODataEdmIEdmPathExpression || (exports.MicrosoftODataEdmIEdmPathExpression = {}));
class MicrosoftODataEdmIEdmProperty {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmProperty.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmProperty = MicrosoftODataEdmIEdmProperty;
MicrosoftODataEdmIEdmProperty.discriminator = undefined;
MicrosoftODataEdmIEdmProperty.attributeTypeMap = [
    {
        "name": "propertyKind",
        "baseName": "propertyKind",
        "type": "MicrosoftODataEdmIEdmProperty.PropertyKindEnum"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "MicrosoftODataEdmIEdmTypeReference"
    },
    {
        "name": "declaringType",
        "baseName": "declaringType",
        "type": "MicrosoftODataEdmIEdmStructuredType"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];
(function (MicrosoftODataEdmIEdmProperty) {
    let PropertyKindEnum;
    (function (PropertyKindEnum) {
        PropertyKindEnum[PropertyKindEnum["None"] = 'none'] = "None";
        PropertyKindEnum[PropertyKindEnum["Structural"] = 'structural'] = "Structural";
        PropertyKindEnum[PropertyKindEnum["Navigation"] = 'navigation'] = "Navigation";
    })(PropertyKindEnum = MicrosoftODataEdmIEdmProperty.PropertyKindEnum || (MicrosoftODataEdmIEdmProperty.PropertyKindEnum = {}));
})(MicrosoftODataEdmIEdmProperty = exports.MicrosoftODataEdmIEdmProperty || (exports.MicrosoftODataEdmIEdmProperty = {}));
class MicrosoftODataEdmIEdmReferentialConstraint {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmReferentialConstraint.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmReferentialConstraint = MicrosoftODataEdmIEdmReferentialConstraint;
MicrosoftODataEdmIEdmReferentialConstraint.discriminator = undefined;
MicrosoftODataEdmIEdmReferentialConstraint.attributeTypeMap = [
    {
        "name": "propertyPairs",
        "baseName": "propertyPairs",
        "type": "Array<MicrosoftODataEdmEdmReferentialConstraintPropertyPair>"
    }
];
class MicrosoftODataEdmIEdmSchemaElement {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmSchemaElement.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmSchemaElement = MicrosoftODataEdmIEdmSchemaElement;
MicrosoftODataEdmIEdmSchemaElement.discriminator = undefined;
MicrosoftODataEdmIEdmSchemaElement.attributeTypeMap = [
    {
        "name": "schemaElementKind",
        "baseName": "schemaElementKind",
        "type": "MicrosoftODataEdmIEdmSchemaElement.SchemaElementKindEnum"
    },
    {
        "name": "namespace",
        "baseName": "namespace",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];
(function (MicrosoftODataEdmIEdmSchemaElement) {
    let SchemaElementKindEnum;
    (function (SchemaElementKindEnum) {
        SchemaElementKindEnum[SchemaElementKindEnum["None"] = 'none'] = "None";
        SchemaElementKindEnum[SchemaElementKindEnum["TypeDefinition"] = 'typeDefinition'] = "TypeDefinition";
        SchemaElementKindEnum[SchemaElementKindEnum["Term"] = 'term'] = "Term";
        SchemaElementKindEnum[SchemaElementKindEnum["Action"] = 'action'] = "Action";
        SchemaElementKindEnum[SchemaElementKindEnum["EntityContainer"] = 'entityContainer'] = "EntityContainer";
        SchemaElementKindEnum[SchemaElementKindEnum["Function"] = 'function'] = "Function";
    })(SchemaElementKindEnum = MicrosoftODataEdmIEdmSchemaElement.SchemaElementKindEnum || (MicrosoftODataEdmIEdmSchemaElement.SchemaElementKindEnum = {}));
})(MicrosoftODataEdmIEdmSchemaElement = exports.MicrosoftODataEdmIEdmSchemaElement || (exports.MicrosoftODataEdmIEdmSchemaElement = {}));
class MicrosoftODataEdmIEdmStructuralProperty {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmStructuralProperty.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmStructuralProperty = MicrosoftODataEdmIEdmStructuralProperty;
MicrosoftODataEdmIEdmStructuralProperty.discriminator = undefined;
MicrosoftODataEdmIEdmStructuralProperty.attributeTypeMap = [
    {
        "name": "defaultValueString",
        "baseName": "defaultValueString",
        "type": "string"
    },
    {
        "name": "propertyKind",
        "baseName": "propertyKind",
        "type": "MicrosoftODataEdmIEdmStructuralProperty.PropertyKindEnum"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "MicrosoftODataEdmIEdmTypeReference"
    },
    {
        "name": "declaringType",
        "baseName": "declaringType",
        "type": "MicrosoftODataEdmIEdmStructuredType"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];
(function (MicrosoftODataEdmIEdmStructuralProperty) {
    let PropertyKindEnum;
    (function (PropertyKindEnum) {
        PropertyKindEnum[PropertyKindEnum["None"] = 'none'] = "None";
        PropertyKindEnum[PropertyKindEnum["Structural"] = 'structural'] = "Structural";
        PropertyKindEnum[PropertyKindEnum["Navigation"] = 'navigation'] = "Navigation";
    })(PropertyKindEnum = MicrosoftODataEdmIEdmStructuralProperty.PropertyKindEnum || (MicrosoftODataEdmIEdmStructuralProperty.PropertyKindEnum = {}));
})(MicrosoftODataEdmIEdmStructuralProperty = exports.MicrosoftODataEdmIEdmStructuralProperty || (exports.MicrosoftODataEdmIEdmStructuralProperty = {}));
class MicrosoftODataEdmIEdmStructuredType {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmStructuredType.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmStructuredType = MicrosoftODataEdmIEdmStructuredType;
MicrosoftODataEdmIEdmStructuredType.discriminator = undefined;
MicrosoftODataEdmIEdmStructuredType.attributeTypeMap = [
    {
        "name": "isAbstract",
        "baseName": "isAbstract",
        "type": "boolean"
    },
    {
        "name": "isOpen",
        "baseName": "isOpen",
        "type": "boolean"
    },
    {
        "name": "baseType",
        "baseName": "baseType",
        "type": "MicrosoftODataEdmIEdmStructuredType"
    },
    {
        "name": "declaredProperties",
        "baseName": "declaredProperties",
        "type": "Array<MicrosoftODataEdmIEdmProperty>"
    },
    {
        "name": "typeKind",
        "baseName": "typeKind",
        "type": "MicrosoftODataEdmIEdmStructuredType.TypeKindEnum"
    }
];
(function (MicrosoftODataEdmIEdmStructuredType) {
    let TypeKindEnum;
    (function (TypeKindEnum) {
        TypeKindEnum[TypeKindEnum["None"] = 'none'] = "None";
        TypeKindEnum[TypeKindEnum["Primitive"] = 'primitive'] = "Primitive";
        TypeKindEnum[TypeKindEnum["Entity"] = 'entity'] = "Entity";
        TypeKindEnum[TypeKindEnum["Complex"] = 'complex'] = "Complex";
        TypeKindEnum[TypeKindEnum["Collection"] = 'collection'] = "Collection";
        TypeKindEnum[TypeKindEnum["EntityReference"] = 'entityReference'] = "EntityReference";
        TypeKindEnum[TypeKindEnum["Enum"] = 'enum'] = "Enum";
        TypeKindEnum[TypeKindEnum["TypeDefinition"] = 'typeDefinition'] = "TypeDefinition";
        TypeKindEnum[TypeKindEnum["Untyped"] = 'untyped'] = "Untyped";
        TypeKindEnum[TypeKindEnum["Path"] = 'path'] = "Path";
    })(TypeKindEnum = MicrosoftODataEdmIEdmStructuredType.TypeKindEnum || (MicrosoftODataEdmIEdmStructuredType.TypeKindEnum = {}));
})(MicrosoftODataEdmIEdmStructuredType = exports.MicrosoftODataEdmIEdmStructuredType || (exports.MicrosoftODataEdmIEdmStructuredType = {}));
class MicrosoftODataEdmIEdmType {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmType.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmType = MicrosoftODataEdmIEdmType;
MicrosoftODataEdmIEdmType.discriminator = undefined;
MicrosoftODataEdmIEdmType.attributeTypeMap = [
    {
        "name": "typeKind",
        "baseName": "typeKind",
        "type": "MicrosoftODataEdmIEdmType.TypeKindEnum"
    }
];
(function (MicrosoftODataEdmIEdmType) {
    let TypeKindEnum;
    (function (TypeKindEnum) {
        TypeKindEnum[TypeKindEnum["None"] = 'none'] = "None";
        TypeKindEnum[TypeKindEnum["Primitive"] = 'primitive'] = "Primitive";
        TypeKindEnum[TypeKindEnum["Entity"] = 'entity'] = "Entity";
        TypeKindEnum[TypeKindEnum["Complex"] = 'complex'] = "Complex";
        TypeKindEnum[TypeKindEnum["Collection"] = 'collection'] = "Collection";
        TypeKindEnum[TypeKindEnum["EntityReference"] = 'entityReference'] = "EntityReference";
        TypeKindEnum[TypeKindEnum["Enum"] = 'enum'] = "Enum";
        TypeKindEnum[TypeKindEnum["TypeDefinition"] = 'typeDefinition'] = "TypeDefinition";
        TypeKindEnum[TypeKindEnum["Untyped"] = 'untyped'] = "Untyped";
        TypeKindEnum[TypeKindEnum["Path"] = 'path'] = "Path";
    })(TypeKindEnum = MicrosoftODataEdmIEdmType.TypeKindEnum || (MicrosoftODataEdmIEdmType.TypeKindEnum = {}));
})(MicrosoftODataEdmIEdmType = exports.MicrosoftODataEdmIEdmType || (exports.MicrosoftODataEdmIEdmType = {}));
class MicrosoftODataEdmIEdmTypeReference {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmIEdmTypeReference.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmIEdmTypeReference = MicrosoftODataEdmIEdmTypeReference;
MicrosoftODataEdmIEdmTypeReference.discriminator = undefined;
MicrosoftODataEdmIEdmTypeReference.attributeTypeMap = [
    {
        "name": "isNullable",
        "baseName": "isNullable",
        "type": "boolean"
    },
    {
        "name": "definition",
        "baseName": "definition",
        "type": "MicrosoftODataEdmIEdmType"
    }
];
class MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager = MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager;
MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager.discriminator = undefined;
MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager.attributeTypeMap = [];
class MicrosoftODataEdmVocabulariesIEdmTerm {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmVocabulariesIEdmTerm.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmVocabulariesIEdmTerm = MicrosoftODataEdmVocabulariesIEdmTerm;
MicrosoftODataEdmVocabulariesIEdmTerm.discriminator = undefined;
MicrosoftODataEdmVocabulariesIEdmTerm.attributeTypeMap = [
    {
        "name": "type",
        "baseName": "type",
        "type": "MicrosoftODataEdmIEdmTypeReference"
    },
    {
        "name": "appliesTo",
        "baseName": "appliesTo",
        "type": "string"
    },
    {
        "name": "defaultValue",
        "baseName": "defaultValue",
        "type": "string"
    },
    {
        "name": "schemaElementKind",
        "baseName": "schemaElementKind",
        "type": "MicrosoftODataEdmVocabulariesIEdmTerm.SchemaElementKindEnum"
    },
    {
        "name": "namespace",
        "baseName": "namespace",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    }
];
(function (MicrosoftODataEdmVocabulariesIEdmTerm) {
    let SchemaElementKindEnum;
    (function (SchemaElementKindEnum) {
        SchemaElementKindEnum[SchemaElementKindEnum["None"] = 'none'] = "None";
        SchemaElementKindEnum[SchemaElementKindEnum["TypeDefinition"] = 'typeDefinition'] = "TypeDefinition";
        SchemaElementKindEnum[SchemaElementKindEnum["Term"] = 'term'] = "Term";
        SchemaElementKindEnum[SchemaElementKindEnum["Action"] = 'action'] = "Action";
        SchemaElementKindEnum[SchemaElementKindEnum["EntityContainer"] = 'entityContainer'] = "EntityContainer";
        SchemaElementKindEnum[SchemaElementKindEnum["Function"] = 'function'] = "Function";
    })(SchemaElementKindEnum = MicrosoftODataEdmVocabulariesIEdmTerm.SchemaElementKindEnum || (MicrosoftODataEdmVocabulariesIEdmTerm.SchemaElementKindEnum = {}));
})(MicrosoftODataEdmVocabulariesIEdmTerm = exports.MicrosoftODataEdmVocabulariesIEdmTerm || (exports.MicrosoftODataEdmVocabulariesIEdmTerm = {}));
class MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable = MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable;
MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable.discriminator = undefined;
MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable.attributeTypeMap = [];
class MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation {
    static getAttributeTypeMap() {
        return MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation.attributeTypeMap;
    }
}
exports.MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation = MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation;
MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation.discriminator = undefined;
MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation.attributeTypeMap = [
    {
        "name": "qualifier",
        "baseName": "qualifier",
        "type": "string"
    },
    {
        "name": "term",
        "baseName": "term",
        "type": "MicrosoftODataEdmVocabulariesIEdmTerm"
    },
    {
        "name": "target",
        "baseName": "target",
        "type": "MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "MicrosoftODataEdmIEdmExpression"
    }
];
class MicrosoftODataUriParserAggregationApplyClause {
    static getAttributeTypeMap() {
        return MicrosoftODataUriParserAggregationApplyClause.attributeTypeMap;
    }
}
exports.MicrosoftODataUriParserAggregationApplyClause = MicrosoftODataUriParserAggregationApplyClause;
MicrosoftODataUriParserAggregationApplyClause.discriminator = undefined;
MicrosoftODataUriParserAggregationApplyClause.attributeTypeMap = [
    {
        "name": "transformations",
        "baseName": "transformations",
        "type": "Array<MicrosoftODataUriParserAggregationTransformationNode>"
    }
];
class MicrosoftODataUriParserAggregationTransformationNode {
    static getAttributeTypeMap() {
        return MicrosoftODataUriParserAggregationTransformationNode.attributeTypeMap;
    }
}
exports.MicrosoftODataUriParserAggregationTransformationNode = MicrosoftODataUriParserAggregationTransformationNode;
MicrosoftODataUriParserAggregationTransformationNode.discriminator = undefined;
MicrosoftODataUriParserAggregationTransformationNode.attributeTypeMap = [
    {
        "name": "kind",
        "baseName": "kind",
        "type": "MicrosoftODataUriParserAggregationTransformationNode.KindEnum"
    }
];
(function (MicrosoftODataUriParserAggregationTransformationNode) {
    let KindEnum;
    (function (KindEnum) {
        KindEnum[KindEnum["Aggregate"] = 'aggregate'] = "Aggregate";
        KindEnum[KindEnum["GroupBy"] = 'groupBy'] = "GroupBy";
        KindEnum[KindEnum["Filter"] = 'filter'] = "Filter";
        KindEnum[KindEnum["Compute"] = 'compute'] = "Compute";
        KindEnum[KindEnum["Expand"] = 'expand'] = "Expand";
    })(KindEnum = MicrosoftODataUriParserAggregationTransformationNode.KindEnum || (MicrosoftODataUriParserAggregationTransformationNode.KindEnum = {}));
})(MicrosoftODataUriParserAggregationTransformationNode = exports.MicrosoftODataUriParserAggregationTransformationNode || (exports.MicrosoftODataUriParserAggregationTransformationNode = {}));
class MicrosoftODataUriParserFilterClause {
    static getAttributeTypeMap() {
        return MicrosoftODataUriParserFilterClause.attributeTypeMap;
    }
}
exports.MicrosoftODataUriParserFilterClause = MicrosoftODataUriParserFilterClause;
MicrosoftODataUriParserFilterClause.discriminator = undefined;
MicrosoftODataUriParserFilterClause.attributeTypeMap = [
    {
        "name": "expression",
        "baseName": "expression",
        "type": "MicrosoftODataUriParserSingleValueNode"
    },
    {
        "name": "rangeVariable",
        "baseName": "rangeVariable",
        "type": "MicrosoftODataUriParserRangeVariable"
    },
    {
        "name": "itemType",
        "baseName": "itemType",
        "type": "MicrosoftODataEdmIEdmTypeReference"
    }
];
class MicrosoftODataUriParserODataPathSegment {
    static getAttributeTypeMap() {
        return MicrosoftODataUriParserODataPathSegment.attributeTypeMap;
    }
}
exports.MicrosoftODataUriParserODataPathSegment = MicrosoftODataUriParserODataPathSegment;
MicrosoftODataUriParserODataPathSegment.discriminator = undefined;
MicrosoftODataUriParserODataPathSegment.attributeTypeMap = [
    {
        "name": "edmType",
        "baseName": "edmType",
        "type": "MicrosoftODataEdmIEdmType"
    },
    {
        "name": "identifier",
        "baseName": "identifier",
        "type": "string"
    }
];
class MicrosoftODataUriParserOrderByClause {
    static getAttributeTypeMap() {
        return MicrosoftODataUriParserOrderByClause.attributeTypeMap;
    }
}
exports.MicrosoftODataUriParserOrderByClause = MicrosoftODataUriParserOrderByClause;
MicrosoftODataUriParserOrderByClause.discriminator = undefined;
MicrosoftODataUriParserOrderByClause.attributeTypeMap = [
    {
        "name": "thenBy",
        "baseName": "thenBy",
        "type": "MicrosoftODataUriParserOrderByClause"
    },
    {
        "name": "expression",
        "baseName": "expression",
        "type": "MicrosoftODataUriParserSingleValueNode"
    },
    {
        "name": "direction",
        "baseName": "direction",
        "type": "MicrosoftODataUriParserOrderByClause.DirectionEnum"
    },
    {
        "name": "rangeVariable",
        "baseName": "rangeVariable",
        "type": "MicrosoftODataUriParserRangeVariable"
    },
    {
        "name": "itemType",
        "baseName": "itemType",
        "type": "MicrosoftODataEdmIEdmTypeReference"
    }
];
(function (MicrosoftODataUriParserOrderByClause) {
    let DirectionEnum;
    (function (DirectionEnum) {
        DirectionEnum[DirectionEnum["Ascending"] = 'ascending'] = "Ascending";
        DirectionEnum[DirectionEnum["Descending"] = 'descending'] = "Descending";
    })(DirectionEnum = MicrosoftODataUriParserOrderByClause.DirectionEnum || (MicrosoftODataUriParserOrderByClause.DirectionEnum = {}));
})(MicrosoftODataUriParserOrderByClause = exports.MicrosoftODataUriParserOrderByClause || (exports.MicrosoftODataUriParserOrderByClause = {}));
class MicrosoftODataUriParserRangeVariable {
    static getAttributeTypeMap() {
        return MicrosoftODataUriParserRangeVariable.attributeTypeMap;
    }
}
exports.MicrosoftODataUriParserRangeVariable = MicrosoftODataUriParserRangeVariable;
MicrosoftODataUriParserRangeVariable.discriminator = undefined;
MicrosoftODataUriParserRangeVariable.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "typeReference",
        "baseName": "typeReference",
        "type": "MicrosoftODataEdmIEdmTypeReference"
    },
    {
        "name": "kind",
        "baseName": "kind",
        "type": "number"
    }
];
class MicrosoftODataUriParserSelectExpandClause {
    static getAttributeTypeMap() {
        return MicrosoftODataUriParserSelectExpandClause.attributeTypeMap;
    }
}
exports.MicrosoftODataUriParserSelectExpandClause = MicrosoftODataUriParserSelectExpandClause;
MicrosoftODataUriParserSelectExpandClause.discriminator = undefined;
MicrosoftODataUriParserSelectExpandClause.attributeTypeMap = [
    {
        "name": "selectedItems",
        "baseName": "selectedItems",
        "type": "Array<MicrosoftODataUriParserSelectItem>"
    },
    {
        "name": "allSelected",
        "baseName": "allSelected",
        "type": "boolean"
    }
];
class MicrosoftODataUriParserSelectItem {
    static getAttributeTypeMap() {
        return MicrosoftODataUriParserSelectItem.attributeTypeMap;
    }
}
exports.MicrosoftODataUriParserSelectItem = MicrosoftODataUriParserSelectItem;
MicrosoftODataUriParserSelectItem.discriminator = undefined;
MicrosoftODataUriParserSelectItem.attributeTypeMap = [];
class MicrosoftODataUriParserSingleValueNode {
    static getAttributeTypeMap() {
        return MicrosoftODataUriParserSingleValueNode.attributeTypeMap;
    }
}
exports.MicrosoftODataUriParserSingleValueNode = MicrosoftODataUriParserSingleValueNode;
MicrosoftODataUriParserSingleValueNode.discriminator = undefined;
MicrosoftODataUriParserSingleValueNode.attributeTypeMap = [
    {
        "name": "typeReference",
        "baseName": "typeReference",
        "type": "MicrosoftODataEdmIEdmTypeReference"
    },
    {
        "name": "kind",
        "baseName": "kind",
        "type": "MicrosoftODataUriParserSingleValueNode.KindEnum"
    }
];
(function (MicrosoftODataUriParserSingleValueNode) {
    let KindEnum;
    (function (KindEnum) {
        KindEnum[KindEnum["None"] = 'none'] = "None";
        KindEnum[KindEnum["Constant"] = 'constant'] = "Constant";
        KindEnum[KindEnum["Convert"] = 'convert'] = "Convert";
        KindEnum[KindEnum["NonResourceRangeVariableReference"] = 'nonResourceRangeVariableReference'] = "NonResourceRangeVariableReference";
        KindEnum[KindEnum["BinaryOperator"] = 'binaryOperator'] = "BinaryOperator";
        KindEnum[KindEnum["UnaryOperator"] = 'unaryOperator'] = "UnaryOperator";
        KindEnum[KindEnum["SingleValuePropertyAccess"] = 'singleValuePropertyAccess'] = "SingleValuePropertyAccess";
        KindEnum[KindEnum["CollectionPropertyAccess"] = 'collectionPropertyAccess'] = "CollectionPropertyAccess";
        KindEnum[KindEnum["SingleValueFunctionCall"] = 'singleValueFunctionCall'] = "SingleValueFunctionCall";
        KindEnum[KindEnum["Any"] = 'any'] = "Any";
        KindEnum[KindEnum["CollectionNavigationNode"] = 'collectionNavigationNode'] = "CollectionNavigationNode";
        KindEnum[KindEnum["SingleNavigationNode"] = 'singleNavigationNode'] = "SingleNavigationNode";
        KindEnum[KindEnum["SingleValueOpenPropertyAccess"] = 'singleValueOpenPropertyAccess'] = "SingleValueOpenPropertyAccess";
        KindEnum[KindEnum["SingleResourceCast"] = 'singleResourceCast'] = "SingleResourceCast";
        KindEnum[KindEnum["All"] = 'all'] = "All";
        KindEnum[KindEnum["CollectionResourceCast"] = 'collectionResourceCast'] = "CollectionResourceCast";
        KindEnum[KindEnum["ResourceRangeVariableReference"] = 'resourceRangeVariableReference'] = "ResourceRangeVariableReference";
        KindEnum[KindEnum["SingleResourceFunctionCall"] = 'singleResourceFunctionCall'] = "SingleResourceFunctionCall";
        KindEnum[KindEnum["CollectionFunctionCall"] = 'collectionFunctionCall'] = "CollectionFunctionCall";
        KindEnum[KindEnum["CollectionResourceFunctionCall"] = 'collectionResourceFunctionCall'] = "CollectionResourceFunctionCall";
        KindEnum[KindEnum["NamedFunctionParameter"] = 'namedFunctionParameter'] = "NamedFunctionParameter";
        KindEnum[KindEnum["ParameterAlias"] = 'parameterAlias'] = "ParameterAlias";
        KindEnum[KindEnum["EntitySet"] = 'entitySet'] = "EntitySet";
        KindEnum[KindEnum["KeyLookup"] = 'keyLookup'] = "KeyLookup";
        KindEnum[KindEnum["SearchTerm"] = 'searchTerm'] = "SearchTerm";
        KindEnum[KindEnum["CollectionOpenPropertyAccess"] = 'collectionOpenPropertyAccess'] = "CollectionOpenPropertyAccess";
        KindEnum[KindEnum["CollectionComplexNode"] = 'collectionComplexNode'] = "CollectionComplexNode";
        KindEnum[KindEnum["SingleComplexNode"] = 'singleComplexNode'] = "SingleComplexNode";
        KindEnum[KindEnum["Count"] = 'count'] = "Count";
        KindEnum[KindEnum["SingleValueCast"] = 'singleValueCast'] = "SingleValueCast";
        KindEnum[KindEnum["CollectionPropertyNode"] = 'collectionPropertyNode'] = "CollectionPropertyNode";
        KindEnum[KindEnum["AggregatedCollectionPropertyNode"] = 'aggregatedCollectionPropertyNode'] = "AggregatedCollectionPropertyNode";
        KindEnum[KindEnum["In"] = 'in'] = "In";
        KindEnum[KindEnum["CollectionConstant"] = 'collectionConstant'] = "CollectionConstant";
    })(KindEnum = MicrosoftODataUriParserSingleValueNode.KindEnum || (MicrosoftODataUriParserSingleValueNode.KindEnum = {}));
})(MicrosoftODataUriParserSingleValueNode = exports.MicrosoftODataUriParserSingleValueNode || (exports.MicrosoftODataUriParserSingleValueNode = {}));
class MicrosoftWin32SafeHandlesSafeWaitHandle {
    static getAttributeTypeMap() {
        return MicrosoftWin32SafeHandlesSafeWaitHandle.attributeTypeMap;
    }
}
exports.MicrosoftWin32SafeHandlesSafeWaitHandle = MicrosoftWin32SafeHandlesSafeWaitHandle;
MicrosoftWin32SafeHandlesSafeWaitHandle.discriminator = undefined;
MicrosoftWin32SafeHandlesSafeWaitHandle.attributeTypeMap = [
    {
        "name": "isInvalid",
        "baseName": "isInvalid",
        "type": "boolean"
    },
    {
        "name": "isClosed",
        "baseName": "isClosed",
        "type": "boolean"
    }
];
class SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_ {
    static getAttributeTypeMap() {
        return SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_.attributeTypeMap;
    }
}
exports.SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_ = SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_;
SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_.discriminator = undefined;
SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_.attributeTypeMap = [
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "Array<string>"
    }
];
class SystemCollectionsGenericKeyValuePair2SystemStringSystemString_ {
    static getAttributeTypeMap() {
        return SystemCollectionsGenericKeyValuePair2SystemStringSystemString_.attributeTypeMap;
    }
}
exports.SystemCollectionsGenericKeyValuePair2SystemStringSystemString_ = SystemCollectionsGenericKeyValuePair2SystemStringSystemString_;
SystemCollectionsGenericKeyValuePair2SystemStringSystemString_.discriminator = undefined;
SystemCollectionsGenericKeyValuePair2SystemStringSystemString_.attributeTypeMap = [
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    }
];
class SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_ {
    static getAttributeTypeMap() {
        return SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_.attributeTypeMap;
    }
}
exports.SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_ = SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_;
SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_.discriminator = undefined;
SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_.attributeTypeMap = [
    {
        "name": "key",
        "baseName": "key",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "any"
    }
];
class SystemIOStream {
    static getAttributeTypeMap() {
        return SystemIOStream.attributeTypeMap;
    }
}
exports.SystemIOStream = SystemIOStream;
SystemIOStream.discriminator = undefined;
SystemIOStream.attributeTypeMap = [
    {
        "name": "canRead",
        "baseName": "canRead",
        "type": "boolean"
    },
    {
        "name": "canSeek",
        "baseName": "canSeek",
        "type": "boolean"
    },
    {
        "name": "canTimeout",
        "baseName": "canTimeout",
        "type": "boolean"
    },
    {
        "name": "canWrite",
        "baseName": "canWrite",
        "type": "boolean"
    },
    {
        "name": "length",
        "baseName": "length",
        "type": "number"
    },
    {
        "name": "position",
        "baseName": "position",
        "type": "number"
    },
    {
        "name": "readTimeout",
        "baseName": "readTimeout",
        "type": "number"
    },
    {
        "name": "writeTimeout",
        "baseName": "writeTimeout",
        "type": "number"
    }
];
class SystemIServiceProvider {
    static getAttributeTypeMap() {
        return SystemIServiceProvider.attributeTypeMap;
    }
}
exports.SystemIServiceProvider = SystemIServiceProvider;
SystemIServiceProvider.discriminator = undefined;
SystemIServiceProvider.attributeTypeMap = [];
class SystemNetIPAddress {
    static getAttributeTypeMap() {
        return SystemNetIPAddress.attributeTypeMap;
    }
}
exports.SystemNetIPAddress = SystemNetIPAddress;
SystemNetIPAddress.discriminator = undefined;
SystemNetIPAddress.attributeTypeMap = [
    {
        "name": "address",
        "baseName": "address",
        "type": "number"
    },
    {
        "name": "addressFamily",
        "baseName": "addressFamily",
        "type": "SystemNetIPAddress.AddressFamilyEnum"
    },
    {
        "name": "scopeId",
        "baseName": "scopeId",
        "type": "number"
    },
    {
        "name": "isIPv6Multicast",
        "baseName": "isIPv6Multicast",
        "type": "boolean"
    },
    {
        "name": "isIPv6LinkLocal",
        "baseName": "isIPv6LinkLocal",
        "type": "boolean"
    },
    {
        "name": "isIPv6SiteLocal",
        "baseName": "isIPv6SiteLocal",
        "type": "boolean"
    },
    {
        "name": "isIPv6Teredo",
        "baseName": "isIPv6Teredo",
        "type": "boolean"
    },
    {
        "name": "isIPv4MappedToIPv6",
        "baseName": "isIPv4MappedToIPv6",
        "type": "boolean"
    }
];
(function (SystemNetIPAddress) {
    let AddressFamilyEnum;
    (function (AddressFamilyEnum) {
        AddressFamilyEnum[AddressFamilyEnum["Unknown"] = 'unknown'] = "Unknown";
        AddressFamilyEnum[AddressFamilyEnum["Unspecified"] = 'unspecified'] = "Unspecified";
        AddressFamilyEnum[AddressFamilyEnum["Unix"] = 'unix'] = "Unix";
        AddressFamilyEnum[AddressFamilyEnum["InterNetwork"] = 'interNetwork'] = "InterNetwork";
        AddressFamilyEnum[AddressFamilyEnum["ImpLink"] = 'impLink'] = "ImpLink";
        AddressFamilyEnum[AddressFamilyEnum["Pup"] = 'pup'] = "Pup";
        AddressFamilyEnum[AddressFamilyEnum["Chaos"] = 'chaos'] = "Chaos";
        AddressFamilyEnum[AddressFamilyEnum["NS"] = 'nS'] = "NS";
        AddressFamilyEnum[AddressFamilyEnum["Ipx"] = 'ipx'] = "Ipx";
        AddressFamilyEnum[AddressFamilyEnum["Iso"] = 'iso'] = "Iso";
        AddressFamilyEnum[AddressFamilyEnum["Osi"] = 'osi'] = "Osi";
        AddressFamilyEnum[AddressFamilyEnum["Ecma"] = 'ecma'] = "Ecma";
        AddressFamilyEnum[AddressFamilyEnum["DataKit"] = 'dataKit'] = "DataKit";
        AddressFamilyEnum[AddressFamilyEnum["Ccitt"] = 'ccitt'] = "Ccitt";
        AddressFamilyEnum[AddressFamilyEnum["Sna"] = 'sna'] = "Sna";
        AddressFamilyEnum[AddressFamilyEnum["DecNet"] = 'decNet'] = "DecNet";
        AddressFamilyEnum[AddressFamilyEnum["DataLink"] = 'dataLink'] = "DataLink";
        AddressFamilyEnum[AddressFamilyEnum["Lat"] = 'lat'] = "Lat";
        AddressFamilyEnum[AddressFamilyEnum["HyperChannel"] = 'hyperChannel'] = "HyperChannel";
        AddressFamilyEnum[AddressFamilyEnum["AppleTalk"] = 'appleTalk'] = "AppleTalk";
        AddressFamilyEnum[AddressFamilyEnum["NetBios"] = 'netBios'] = "NetBios";
        AddressFamilyEnum[AddressFamilyEnum["VoiceView"] = 'voiceView'] = "VoiceView";
        AddressFamilyEnum[AddressFamilyEnum["FireFox"] = 'fireFox'] = "FireFox";
        AddressFamilyEnum[AddressFamilyEnum["Banyan"] = 'banyan'] = "Banyan";
        AddressFamilyEnum[AddressFamilyEnum["Atm"] = 'atm'] = "Atm";
        AddressFamilyEnum[AddressFamilyEnum["InterNetworkV6"] = 'interNetworkV6'] = "InterNetworkV6";
        AddressFamilyEnum[AddressFamilyEnum["Cluster"] = 'cluster'] = "Cluster";
        AddressFamilyEnum[AddressFamilyEnum["Ieee12844"] = 'ieee12844'] = "Ieee12844";
        AddressFamilyEnum[AddressFamilyEnum["Irda"] = 'irda'] = "Irda";
        AddressFamilyEnum[AddressFamilyEnum["NetworkDesigners"] = 'networkDesigners'] = "NetworkDesigners";
        AddressFamilyEnum[AddressFamilyEnum["Max"] = 'max'] = "Max";
    })(AddressFamilyEnum = SystemNetIPAddress.AddressFamilyEnum || (SystemNetIPAddress.AddressFamilyEnum = {}));
})(SystemNetIPAddress = exports.SystemNetIPAddress || (exports.SystemNetIPAddress = {}));
class SystemSecurityClaimsClaim {
    static getAttributeTypeMap() {
        return SystemSecurityClaimsClaim.attributeTypeMap;
    }
}
exports.SystemSecurityClaimsClaim = SystemSecurityClaimsClaim;
SystemSecurityClaimsClaim.discriminator = undefined;
SystemSecurityClaimsClaim.attributeTypeMap = [
    {
        "name": "issuer",
        "baseName": "issuer",
        "type": "string"
    },
    {
        "name": "originalIssuer",
        "baseName": "originalIssuer",
        "type": "string"
    },
    {
        "name": "properties",
        "baseName": "properties",
        "type": "{ [key: string]: string; }"
    },
    {
        "name": "subject",
        "baseName": "subject",
        "type": "SystemSecurityClaimsClaimsIdentity"
    },
    {
        "name": "type",
        "baseName": "type",
        "type": "string"
    },
    {
        "name": "value",
        "baseName": "value",
        "type": "string"
    },
    {
        "name": "valueType",
        "baseName": "valueType",
        "type": "string"
    }
];
class SystemSecurityClaimsClaimsIdentity {
    static getAttributeTypeMap() {
        return SystemSecurityClaimsClaimsIdentity.attributeTypeMap;
    }
}
exports.SystemSecurityClaimsClaimsIdentity = SystemSecurityClaimsClaimsIdentity;
SystemSecurityClaimsClaimsIdentity.discriminator = undefined;
SystemSecurityClaimsClaimsIdentity.attributeTypeMap = [
    {
        "name": "authenticationType",
        "baseName": "authenticationType",
        "type": "string"
    },
    {
        "name": "isAuthenticated",
        "baseName": "isAuthenticated",
        "type": "boolean"
    },
    {
        "name": "actor",
        "baseName": "actor",
        "type": "SystemSecurityClaimsClaimsIdentity"
    },
    {
        "name": "bootstrapContext",
        "baseName": "bootstrapContext",
        "type": "any"
    },
    {
        "name": "claims",
        "baseName": "claims",
        "type": "Array<SystemSecurityClaimsClaim>"
    },
    {
        "name": "label",
        "baseName": "label",
        "type": "string"
    },
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "nameClaimType",
        "baseName": "nameClaimType",
        "type": "string"
    },
    {
        "name": "roleClaimType",
        "baseName": "roleClaimType",
        "type": "string"
    }
];
class SystemSecurityClaimsClaimsPrincipal {
    static getAttributeTypeMap() {
        return SystemSecurityClaimsClaimsPrincipal.attributeTypeMap;
    }
}
exports.SystemSecurityClaimsClaimsPrincipal = SystemSecurityClaimsClaimsPrincipal;
SystemSecurityClaimsClaimsPrincipal.discriminator = undefined;
SystemSecurityClaimsClaimsPrincipal.attributeTypeMap = [
    {
        "name": "claims",
        "baseName": "claims",
        "type": "Array<SystemSecurityClaimsClaim>"
    },
    {
        "name": "identities",
        "baseName": "identities",
        "type": "Array<SystemSecurityClaimsClaimsIdentity>"
    },
    {
        "name": "identity",
        "baseName": "identity",
        "type": "SystemSecurityPrincipalIIdentity"
    }
];
class SystemSecurityPrincipalIIdentity {
    static getAttributeTypeMap() {
        return SystemSecurityPrincipalIIdentity.attributeTypeMap;
    }
}
exports.SystemSecurityPrincipalIIdentity = SystemSecurityPrincipalIIdentity;
SystemSecurityPrincipalIIdentity.discriminator = undefined;
SystemSecurityPrincipalIIdentity.attributeTypeMap = [
    {
        "name": "name",
        "baseName": "name",
        "type": "string"
    },
    {
        "name": "authenticationType",
        "baseName": "authenticationType",
        "type": "string"
    },
    {
        "name": "isAuthenticated",
        "baseName": "isAuthenticated",
        "type": "boolean"
    }
];
class SystemThreadingCancellationToken {
    static getAttributeTypeMap() {
        return SystemThreadingCancellationToken.attributeTypeMap;
    }
}
exports.SystemThreadingCancellationToken = SystemThreadingCancellationToken;
SystemThreadingCancellationToken.discriminator = undefined;
SystemThreadingCancellationToken.attributeTypeMap = [
    {
        "name": "isCancellationRequested",
        "baseName": "isCancellationRequested",
        "type": "boolean"
    },
    {
        "name": "canBeCanceled",
        "baseName": "canBeCanceled",
        "type": "boolean"
    },
    {
        "name": "waitHandle",
        "baseName": "waitHandle",
        "type": "SystemThreadingWaitHandle"
    }
];
class SystemThreadingWaitHandle {
    static getAttributeTypeMap() {
        return SystemThreadingWaitHandle.attributeTypeMap;
    }
}
exports.SystemThreadingWaitHandle = SystemThreadingWaitHandle;
SystemThreadingWaitHandle.discriminator = undefined;
SystemThreadingWaitHandle.attributeTypeMap = [
    {
        "name": "handle",
        "baseName": "handle",
        "type": "any"
    },
    {
        "name": "safeWaitHandle",
        "baseName": "safeWaitHandle",
        "type": "MicrosoftWin32SafeHandlesSafeWaitHandle"
    }
];
let enumsMap = {
    "MSEssGatewayClientContractsCipherDetailsMessage.StatusEnum": MSEssGatewayClientContractsCipherDetailsMessage.StatusEnum,
    "MSEssGatewayClientContractsCipherInfo.CipherTypeEnum": MSEssGatewayClientContractsCipherInfo.CipherTypeEnum,
    "MSEssGatewayClientContractsCipherResultMessage.StatusEnum": MSEssGatewayClientContractsCipherResultMessage.StatusEnum,
    "MSEssGatewayClientContractsCryptoFileInfo.HashTypeEnum": MSEssGatewayClientContractsCryptoFileInfo.HashTypeEnum,
    "MSEssGatewayClientContractsCryptoOperation.PrimitiveEnum": MSEssGatewayClientContractsCryptoOperation.PrimitiveEnum,
    "MSEssGatewayClientContractsCryptoRequestMessage.RegionEnum": MSEssGatewayClientContractsCryptoRequestMessage.RegionEnum,
    "MSEssGatewayClientContractsCryptoResultMessage.HashTypeEnum": MSEssGatewayClientContractsCryptoResultMessage.HashTypeEnum,
    "MSEssGatewayClientContractsCryptoResultMessage.StatusEnum": MSEssGatewayClientContractsCryptoResultMessage.StatusEnum,
    "MSEssGatewayClientContractsDigestSignCertificateResultMessage.StatusEnum": MSEssGatewayClientContractsDigestSignCertificateResultMessage.StatusEnum,
    "MSEssGatewayClientContractsDigestSignOperationErrorPatterns.StatusCodeEnum": MSEssGatewayClientContractsDigestSignOperationErrorPatterns.StatusCodeEnum,
    "MSEssGatewayClientContractsFileLocation.TypeEnum": MSEssGatewayClientContractsFileLocation.TypeEnum,
    "MSEssGatewayClientContractsFileTransferFileTransferResultMessage.HashTypeEnum": MSEssGatewayClientContractsFileTransferFileTransferResultMessage.HashTypeEnum,
    "MSEssGatewayClientContractsFileTransferFileTransferResultMessage.StatusEnum": MSEssGatewayClientContractsFileTransferFileTransferResultMessage.StatusEnum,
    "MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.FileStatusEnum": MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult.FileStatusEnum,
    "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.DestinationHashTypeEnum": MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.DestinationHashTypeEnum,
    "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.StatusEnum": MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage.StatusEnum,
    "MSEssGatewayClientContractsIFeature.FeatureTypeEnum": MSEssGatewayClientContractsIFeature.FeatureTypeEnum,
    "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApproverTypeEnum": MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApproverTypeEnum,
    "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApprovalStatusEnum": MSEssGatewayClientContractsPKITACertificateClmApprovalInfo.ApprovalStatusEnum,
    "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.StatusEnum": MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage.StatusEnum,
    "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.ApprovalStatusEnum": MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage.ApprovalStatusEnum,
    "MSEssGatewayClientContractsPolicy.WorkflowExecutionTypeEnum": MSEssGatewayClientContractsPolicy.WorkflowExecutionTypeEnum,
    "MSEssGatewayClientContractsProvisionStorageResultMessage.StatusEnum": MSEssGatewayClientContractsProvisionStorageResultMessage.StatusEnum,
    "MSEssGatewayClientContractsReleaseEditApproverInfo.ActionEnum": MSEssGatewayClientContractsReleaseEditApproverInfo.ActionEnum,
    "MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.ActionEnum": MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo.ActionEnum,
    "MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.ActionEnum": MSEssGatewayClientContractsReleaseEditChannelDownloadEntity.ActionEnum,
    "MSEssGatewayClientContractsReleaseEditOwnerInfo.ActionEnum": MSEssGatewayClientContractsReleaseEditOwnerInfo.ActionEnum,
    "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.StatusCodeEnum": MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.StatusCodeEnum,
    "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.CipherTypeEnum": MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.CipherTypeEnum,
    "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.HashTypeEnum": MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus.HashTypeEnum,
    "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.StatusCodeEnum": MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.StatusCodeEnum,
    "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.HashTypeEnum": MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.HashTypeEnum,
    "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.SecondaryDistributionHashTypeEnum": MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus.SecondaryDistributionHashTypeEnum,
    "MSEssGatewayClientContractsReleaseFileScanStatus.StatusCodeEnum": MSEssGatewayClientContractsReleaseFileScanStatus.StatusCodeEnum,
    "MSEssGatewayClientContractsReleaseFileSignStatus.StatusCodeEnum": MSEssGatewayClientContractsReleaseFileSignStatus.StatusCodeEnum,
    "MSEssGatewayClientContractsReleaseFileSignStatus.HashTypeEnum": MSEssGatewayClientContractsReleaseFileSignStatus.HashTypeEnum,
    "MSEssGatewayClientContractsReleaseFileVaultStatusInfo.StatusEnum": MSEssGatewayClientContractsReleaseFileVaultStatusInfo.StatusEnum,
    "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.SecondaryDistributionHashTypeEnum": MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.SecondaryDistributionHashTypeEnum,
    "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.HashTypeEnum": MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo.HashTypeEnum,
    "MSEssGatewayClientContractsReleaseReleaseFileInfo.SecondaryDistributionHashTypeEnum": MSEssGatewayClientContractsReleaseReleaseFileInfo.SecondaryDistributionHashTypeEnum,
    "MSEssGatewayClientContractsReleaseReleaseFileInfo.HashTypeEnum": MSEssGatewayClientContractsReleaseReleaseFileInfo.HashTypeEnum,
    "MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.StatusEnum": MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo.StatusEnum,
    "MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.ApprovalStatusEnum": MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage.ApprovalStatusEnum,
    "MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.ApprovalStatusEnum": MSEssGatewayClientContractsReleaseResponseApproverInfoDetails.ApprovalStatusEnum,
    "MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.StatusEnum": MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage.StatusEnum,
    "MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.StatusEnum": MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage.StatusEnum,
    "MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.StatusEnum": MSEssGatewayClientContractsReleaseResponseReleaseResultMessage.StatusEnum,
    "MSEssGatewayClientContractsRequestDetails.StatusEnum": MSEssGatewayClientContractsRequestDetails.StatusEnum,
    "MSEssGatewayClientContractsScanFileInfo.HashTypeEnum": MSEssGatewayClientContractsScanFileInfo.HashTypeEnum,
    "MSEssGatewayClientContractsScanGroupResult.ResultEnum": MSEssGatewayClientContractsScanGroupResult.ResultEnum,
    "MSEssGatewayClientContractsScanRequestMessage.RegionEnum": MSEssGatewayClientContractsScanRequestMessage.RegionEnum,
    "MSEssGatewayClientContractsScanResultMessage.HashTypeEnum": MSEssGatewayClientContractsScanResultMessage.HashTypeEnum,
    "MSEssGatewayClientContractsScanResultMessage.WorkflowTypeEnum": MSEssGatewayClientContractsScanResultMessage.WorkflowTypeEnum,
    "MSEssGatewayClientContractsScanResultMessage.StatusEnum": MSEssGatewayClientContractsScanResultMessage.StatusEnum,
    "MSEssGatewayClientContractsSessionResultMessage.StatusEnum": MSEssGatewayClientContractsSessionResultMessage.StatusEnum,
    "MSEssGatewayClientContractsSignFileInfo.HashTypeEnum": MSEssGatewayClientContractsSignFileInfo.HashTypeEnum,
    "MSEssGatewayClientContractsSignRequestMessage.RegionEnum": MSEssGatewayClientContractsSignRequestMessage.RegionEnum,
    "MSEssGatewayClientContractsSignResultMessage.HashTypeEnum": MSEssGatewayClientContractsSignResultMessage.HashTypeEnum,
    "MSEssGatewayClientContractsSignResultMessage.StatusEnum": MSEssGatewayClientContractsSignResultMessage.StatusEnum,
    "MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.StatusEnum": MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_.StatusEnum,
    "MSEssGatewayClientOnPremContractsDigestSignRequestMessage.RegionEnum": MSEssGatewayClientOnPremContractsDigestSignRequestMessage.RegionEnum,
    "MSEssGatewayClientOnPremContractsDigestSignResultMessage.StatusEnum": MSEssGatewayClientOnPremContractsDigestSignResultMessage.StatusEnum,
    "MicrosoftAspNetODataQueryODataQuerySettings.HandleNullPropagationEnum": MicrosoftAspNetODataQueryODataQuerySettings.HandleNullPropagationEnum,
    "MicrosoftAspNetODataQueryOrderByNode.DirectionEnum": MicrosoftAspNetODataQueryOrderByNode.DirectionEnum,
    "MicrosoftODataEdmIEdmEntityContainer.SchemaElementKindEnum": MicrosoftODataEdmIEdmEntityContainer.SchemaElementKindEnum,
    "MicrosoftODataEdmIEdmEntityContainerElement.ContainerElementKindEnum": MicrosoftODataEdmIEdmEntityContainerElement.ContainerElementKindEnum,
    "MicrosoftODataEdmIEdmExpression.ExpressionKindEnum": MicrosoftODataEdmIEdmExpression.ExpressionKindEnum,
    "MicrosoftODataEdmIEdmNavigationProperty.OnDeleteEnum": MicrosoftODataEdmIEdmNavigationProperty.OnDeleteEnum,
    "MicrosoftODataEdmIEdmNavigationProperty.PropertyKindEnum": MicrosoftODataEdmIEdmNavigationProperty.PropertyKindEnum,
    "MicrosoftODataEdmIEdmPathExpression.ExpressionKindEnum": MicrosoftODataEdmIEdmPathExpression.ExpressionKindEnum,
    "MicrosoftODataEdmIEdmProperty.PropertyKindEnum": MicrosoftODataEdmIEdmProperty.PropertyKindEnum,
    "MicrosoftODataEdmIEdmSchemaElement.SchemaElementKindEnum": MicrosoftODataEdmIEdmSchemaElement.SchemaElementKindEnum,
    "MicrosoftODataEdmIEdmStructuralProperty.PropertyKindEnum": MicrosoftODataEdmIEdmStructuralProperty.PropertyKindEnum,
    "MicrosoftODataEdmIEdmStructuredType.TypeKindEnum": MicrosoftODataEdmIEdmStructuredType.TypeKindEnum,
    "MicrosoftODataEdmIEdmType.TypeKindEnum": MicrosoftODataEdmIEdmType.TypeKindEnum,
    "MicrosoftODataEdmVocabulariesIEdmTerm.SchemaElementKindEnum": MicrosoftODataEdmVocabulariesIEdmTerm.SchemaElementKindEnum,
    "MicrosoftODataUriParserAggregationTransformationNode.KindEnum": MicrosoftODataUriParserAggregationTransformationNode.KindEnum,
    "MicrosoftODataUriParserOrderByClause.DirectionEnum": MicrosoftODataUriParserOrderByClause.DirectionEnum,
    "MicrosoftODataUriParserSingleValueNode.KindEnum": MicrosoftODataUriParserSingleValueNode.KindEnum,
    "SystemNetIPAddress.AddressFamilyEnum": SystemNetIPAddress.AddressFamilyEnum,
};
let typeMap = {
    "MSEssGatewayClientContractsCipherDetailsMessage": MSEssGatewayClientContractsCipherDetailsMessage,
    "MSEssGatewayClientContractsCipherInfo": MSEssGatewayClientContractsCipherInfo,
    "MSEssGatewayClientContractsCipherResultMessage": MSEssGatewayClientContractsCipherResultMessage,
    "MSEssGatewayClientContractsCryptoFileInfo": MSEssGatewayClientContractsCryptoFileInfo,
    "MSEssGatewayClientContractsCryptoOperation": MSEssGatewayClientContractsCryptoOperation,
    "MSEssGatewayClientContractsCryptoParameter": MSEssGatewayClientContractsCryptoParameter,
    "MSEssGatewayClientContractsCryptoRequestMessage": MSEssGatewayClientContractsCryptoRequestMessage,
    "MSEssGatewayClientContractsCryptoResultMessage": MSEssGatewayClientContractsCryptoResultMessage,
    "MSEssGatewayClientContractsDigestSignCertificateRequestMessage": MSEssGatewayClientContractsDigestSignCertificateRequestMessage,
    "MSEssGatewayClientContractsDigestSignCertificateResultMessage": MSEssGatewayClientContractsDigestSignCertificateResultMessage,
    "MSEssGatewayClientContractsDigestSignMapping": MSEssGatewayClientContractsDigestSignMapping,
    "MSEssGatewayClientContractsDigestSignOperationErrorPatterns": MSEssGatewayClientContractsDigestSignOperationErrorPatterns,
    "MSEssGatewayClientContractsDynamicSigningOperation": MSEssGatewayClientContractsDynamicSigningOperation,
    "MSEssGatewayClientContractsEsrpClientConfigInfo3": MSEssGatewayClientContractsEsrpClientConfigInfo3,
    "MSEssGatewayClientContractsEventHubTelemetryConnectionShard": MSEssGatewayClientContractsEventHubTelemetryConnectionShard,
    "MSEssGatewayClientContractsFileLocation": MSEssGatewayClientContractsFileLocation,
    "MSEssGatewayClientContractsFileTransferFileTransferResultMessage": MSEssGatewayClientContractsFileTransferFileTransferResultMessage,
    "MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult": MSEssGatewayClientContractsFileTransferPieceHashPieceHashFileResult,
    "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage": MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage,
    "MSEssGatewayClientContractsGatewayError": MSEssGatewayClientContractsGatewayError,
    "MSEssGatewayClientContractsIFeature": MSEssGatewayClientContractsIFeature,
    "MSEssGatewayClientContractsInnerServiceError": MSEssGatewayClientContractsInnerServiceError,
    "MSEssGatewayClientContractsLegacyCopsMappingData": MSEssGatewayClientContractsLegacyCopsMappingData,
    "MSEssGatewayClientContractsOperationResponse": MSEssGatewayClientContractsOperationResponse,
    "MSEssGatewayClientContractsOperationTemplate": MSEssGatewayClientContractsOperationTemplate,
    "MSEssGatewayClientContractsPKITACertificateClmApprovalInfo": MSEssGatewayClientContractsPKITACertificateClmApprovalInfo,
    "MSEssGatewayClientContractsPKITACertificateCsrFile": MSEssGatewayClientContractsPKITACertificateCsrFile,
    "MSEssGatewayClientContractsPKITACertificateFailedCsrFile": MSEssGatewayClientContractsPKITACertificateFailedCsrFile,
    "MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage": MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage,
    "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage": MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage,
    "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage": MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage,
    "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage": MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage,
    "MSEssGatewayClientContractsPKITACertificatePolicyExtension": MSEssGatewayClientContractsPKITACertificatePolicyExtension,
    "MSEssGatewayClientContractsPKITACertificateValidityDuration": MSEssGatewayClientContractsPKITACertificateValidityDuration,
    "MSEssGatewayClientContractsPkitaCertificateCertificateInfo": MSEssGatewayClientContractsPkitaCertificateCertificateInfo,
    "MSEssGatewayClientContractsPolicy": MSEssGatewayClientContractsPolicy,
    "MSEssGatewayClientContractsPolicyResultMessage": MSEssGatewayClientContractsPolicyResultMessage,
    "MSEssGatewayClientContractsProvisionStorageRequest": MSEssGatewayClientContractsProvisionStorageRequest,
    "MSEssGatewayClientContractsProvisionStorageResultMessage": MSEssGatewayClientContractsProvisionStorageResultMessage,
    "MSEssGatewayClientContractsReleaseAccessPermissionsInfo": MSEssGatewayClientContractsReleaseAccessPermissionsInfo,
    "MSEssGatewayClientContractsReleaseApproverInfo": MSEssGatewayClientContractsReleaseApproverInfo,
    "MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo": MSEssGatewayClientContractsReleaseAuthorizedDownloadUserInfo,
    "MSEssGatewayClientContractsReleaseEditApproverInfo": MSEssGatewayClientContractsReleaseEditApproverInfo,
    "MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo": MSEssGatewayClientContractsReleaseEditAuthorizedDownloadUserInfo,
    "MSEssGatewayClientContractsReleaseEditChannelDownloadEntity": MSEssGatewayClientContractsReleaseEditChannelDownloadEntity,
    "MSEssGatewayClientContractsReleaseEditOwnerInfo": MSEssGatewayClientContractsReleaseEditOwnerInfo,
    "MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus": MSEssGatewayClientContractsReleaseFileEncryptedDistributionBlobStatus,
    "MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus": MSEssGatewayClientContractsReleaseFilePreEncryptedDistributionBlobStatus,
    "MSEssGatewayClientContractsReleaseFileScanStatus": MSEssGatewayClientContractsReleaseFileScanStatus,
    "MSEssGatewayClientContractsReleaseFileSignStatus": MSEssGatewayClientContractsReleaseFileSignStatus,
    "MSEssGatewayClientContractsReleaseFileVaultStatusInfo": MSEssGatewayClientContractsReleaseFileVaultStatusInfo,
    "MSEssGatewayClientContractsReleaseOwnerInfo": MSEssGatewayClientContractsReleaseOwnerInfo,
    "MSEssGatewayClientContractsReleaseProductInfo": MSEssGatewayClientContractsReleaseProductInfo,
    "MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo": MSEssGatewayClientContractsReleaseReleaseDetailsFileInfo,
    "MSEssGatewayClientContractsReleaseReleaseFileInfo": MSEssGatewayClientContractsReleaseReleaseFileInfo,
    "MSEssGatewayClientContractsReleaseReleaseInfo": MSEssGatewayClientContractsReleaseReleaseInfo,
    "MSEssGatewayClientContractsReleaseReleaseInfoProperties": MSEssGatewayClientContractsReleaseReleaseInfoProperties,
    "MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo": MSEssGatewayClientContractsReleaseRequestNotificationMessageInfo,
    "MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage": MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage,
    "MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage": MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage,
    "MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage": MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage,
    "MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage": MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage,
    "MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage": MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage,
    "MSEssGatewayClientContractsReleaseResponseApproverInfoDetails": MSEssGatewayClientContractsReleaseResponseApproverInfoDetails,
    "MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo": MSEssGatewayClientContractsReleaseResponseReleaseActivityInfo,
    "MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage": MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage,
    "MSEssGatewayClientContractsReleaseResponseReleaseEditResponse": MSEssGatewayClientContractsReleaseResponseReleaseEditResponse,
    "MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage": MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage,
    "MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo": MSEssGatewayClientContractsReleaseResponseReleaseEditSectionInfo,
    "MSEssGatewayClientContractsReleaseResponseReleaseError": MSEssGatewayClientContractsReleaseResponseReleaseError,
    "MSEssGatewayClientContractsReleaseResponseReleaseResultMessage": MSEssGatewayClientContractsReleaseResponseReleaseResultMessage,
    "MSEssGatewayClientContractsReleaseUserInfo": MSEssGatewayClientContractsReleaseUserInfo,
    "MSEssGatewayClientContractsRequestDetails": MSEssGatewayClientContractsRequestDetails,
    "MSEssGatewayClientContractsRoutingInfo": MSEssGatewayClientContractsRoutingInfo,
    "MSEssGatewayClientContractsScanFileInfo": MSEssGatewayClientContractsScanFileInfo,
    "MSEssGatewayClientContractsScanGroupResult": MSEssGatewayClientContractsScanGroupResult,
    "MSEssGatewayClientContractsScanRequestMessage": MSEssGatewayClientContractsScanRequestMessage,
    "MSEssGatewayClientContractsScanResultMessage": MSEssGatewayClientContractsScanResultMessage,
    "MSEssGatewayClientContractsSessionRequestMessage": MSEssGatewayClientContractsSessionRequestMessage,
    "MSEssGatewayClientContractsSessionResultMessage": MSEssGatewayClientContractsSessionResultMessage,
    "MSEssGatewayClientContractsSignFileInfo": MSEssGatewayClientContractsSignFileInfo,
    "MSEssGatewayClientContractsSignRequestMessage": MSEssGatewayClientContractsSignRequestMessage,
    "MSEssGatewayClientContractsSignResultMessage": MSEssGatewayClientContractsSignResultMessage,
    "MSEssGatewayClientContractsSigningParameter": MSEssGatewayClientContractsSigningParameter,
    "MSEssGatewayClientContractsSlkRequestSlkRequestMessage": MSEssGatewayClientContractsSlkRequestSlkRequestMessage,
    "MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse": MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse,
    "MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_": MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_,
    "MSEssGatewayClientContractsStaticSigningOperation": MSEssGatewayClientContractsStaticSigningOperation,
    "MSEssGatewayClientContractsStorageShard": MSEssGatewayClientContractsStorageShard,
    "MSEssGatewayClientOnPremContractsDigestSignRequestMessage": MSEssGatewayClientOnPremContractsDigestSignRequestMessage,
    "MSEssGatewayClientOnPremContractsDigestSignResultMessage": MSEssGatewayClientOnPremContractsDigestSignResultMessage,
    "MSEssGatewayClientOnPremContractsHashInfo": MSEssGatewayClientOnPremContractsHashInfo,
    "MSEssGatewayClientOnPremContractsSignedDigest": MSEssGatewayClientOnPremContractsSignedDigest,
    "MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager": MicrosoftAspNetCoreHttpAuthenticationAuthenticationManager,
    "MicrosoftAspNetCoreHttpConnectionInfo": MicrosoftAspNetCoreHttpConnectionInfo,
    "MicrosoftAspNetCoreHttpHostString": MicrosoftAspNetCoreHttpHostString,
    "MicrosoftAspNetCoreHttpHttpContext": MicrosoftAspNetCoreHttpHttpContext,
    "MicrosoftAspNetCoreHttpHttpRequest": MicrosoftAspNetCoreHttpHttpRequest,
    "MicrosoftAspNetCoreHttpHttpResponse": MicrosoftAspNetCoreHttpHttpResponse,
    "MicrosoftAspNetCoreHttpIResponseCookies": MicrosoftAspNetCoreHttpIResponseCookies,
    "MicrosoftAspNetCoreHttpISession": MicrosoftAspNetCoreHttpISession,
    "MicrosoftAspNetCoreHttpQueryString": MicrosoftAspNetCoreHttpQueryString,
    "MicrosoftAspNetCoreHttpWebSocketManager": MicrosoftAspNetCoreHttpWebSocketManager,
    "MicrosoftAspNetODataODataQueryContext": MicrosoftAspNetODataODataQueryContext,
    "MicrosoftAspNetODataQueryApplyQueryOption": MicrosoftAspNetODataQueryApplyQueryOption,
    "MicrosoftAspNetODataQueryCountQueryOption": MicrosoftAspNetODataQueryCountQueryOption,
    "MicrosoftAspNetODataQueryDefaultQuerySettings": MicrosoftAspNetODataQueryDefaultQuerySettings,
    "MicrosoftAspNetODataQueryFilterQueryOption": MicrosoftAspNetODataQueryFilterQueryOption,
    "MicrosoftAspNetODataQueryODataQueryOptions": MicrosoftAspNetODataQueryODataQueryOptions,
    "MicrosoftAspNetODataQueryODataQuerySettings": MicrosoftAspNetODataQueryODataQuerySettings,
    "MicrosoftAspNetODataQueryODataRawQueryOptions": MicrosoftAspNetODataQueryODataRawQueryOptions,
    "MicrosoftAspNetODataQueryOrderByNode": MicrosoftAspNetODataQueryOrderByNode,
    "MicrosoftAspNetODataQueryOrderByQueryOption": MicrosoftAspNetODataQueryOrderByQueryOption,
    "MicrosoftAspNetODataQuerySelectExpandQueryOption": MicrosoftAspNetODataQuerySelectExpandQueryOption,
    "MicrosoftAspNetODataQuerySkipQueryOption": MicrosoftAspNetODataQuerySkipQueryOption,
    "MicrosoftAspNetODataQuerySkipTokenQueryOption": MicrosoftAspNetODataQuerySkipTokenQueryOption,
    "MicrosoftAspNetODataQueryTopQueryOption": MicrosoftAspNetODataQueryTopQueryOption,
    "MicrosoftAspNetODataQueryValidatorsCountQueryValidator": MicrosoftAspNetODataQueryValidatorsCountQueryValidator,
    "MicrosoftAspNetODataQueryValidatorsFilterQueryValidator": MicrosoftAspNetODataQueryValidatorsFilterQueryValidator,
    "MicrosoftAspNetODataQueryValidatorsODataQueryValidator": MicrosoftAspNetODataQueryValidatorsODataQueryValidator,
    "MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator": MicrosoftAspNetODataQueryValidatorsOrderByQueryValidator,
    "MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator": MicrosoftAspNetODataQueryValidatorsSelectExpandQueryValidator,
    "MicrosoftAspNetODataQueryValidatorsSkipQueryValidator": MicrosoftAspNetODataQueryValidatorsSkipQueryValidator,
    "MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator": MicrosoftAspNetODataQueryValidatorsSkipTokenQueryValidator,
    "MicrosoftAspNetODataQueryValidatorsTopQueryValidator": MicrosoftAspNetODataQueryValidatorsTopQueryValidator,
    "MicrosoftAspNetODataRoutingODataPath": MicrosoftAspNetODataRoutingODataPath,
    "MicrosoftODataEdmEdmReferentialConstraintPropertyPair": MicrosoftODataEdmEdmReferentialConstraintPropertyPair,
    "MicrosoftODataEdmIEdmEntityContainer": MicrosoftODataEdmIEdmEntityContainer,
    "MicrosoftODataEdmIEdmEntityContainerElement": MicrosoftODataEdmIEdmEntityContainerElement,
    "MicrosoftODataEdmIEdmExpression": MicrosoftODataEdmIEdmExpression,
    "MicrosoftODataEdmIEdmModel": MicrosoftODataEdmIEdmModel,
    "MicrosoftODataEdmIEdmNavigationProperty": MicrosoftODataEdmIEdmNavigationProperty,
    "MicrosoftODataEdmIEdmNavigationPropertyBinding": MicrosoftODataEdmIEdmNavigationPropertyBinding,
    "MicrosoftODataEdmIEdmNavigationSource": MicrosoftODataEdmIEdmNavigationSource,
    "MicrosoftODataEdmIEdmPathExpression": MicrosoftODataEdmIEdmPathExpression,
    "MicrosoftODataEdmIEdmProperty": MicrosoftODataEdmIEdmProperty,
    "MicrosoftODataEdmIEdmReferentialConstraint": MicrosoftODataEdmIEdmReferentialConstraint,
    "MicrosoftODataEdmIEdmSchemaElement": MicrosoftODataEdmIEdmSchemaElement,
    "MicrosoftODataEdmIEdmStructuralProperty": MicrosoftODataEdmIEdmStructuralProperty,
    "MicrosoftODataEdmIEdmStructuredType": MicrosoftODataEdmIEdmStructuredType,
    "MicrosoftODataEdmIEdmType": MicrosoftODataEdmIEdmType,
    "MicrosoftODataEdmIEdmTypeReference": MicrosoftODataEdmIEdmTypeReference,
    "MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager": MicrosoftODataEdmVocabulariesIEdmDirectValueAnnotationsManager,
    "MicrosoftODataEdmVocabulariesIEdmTerm": MicrosoftODataEdmVocabulariesIEdmTerm,
    "MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable": MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotatable,
    "MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation": MicrosoftODataEdmVocabulariesIEdmVocabularyAnnotation,
    "MicrosoftODataUriParserAggregationApplyClause": MicrosoftODataUriParserAggregationApplyClause,
    "MicrosoftODataUriParserAggregationTransformationNode": MicrosoftODataUriParserAggregationTransformationNode,
    "MicrosoftODataUriParserFilterClause": MicrosoftODataUriParserFilterClause,
    "MicrosoftODataUriParserODataPathSegment": MicrosoftODataUriParserODataPathSegment,
    "MicrosoftODataUriParserOrderByClause": MicrosoftODataUriParserOrderByClause,
    "MicrosoftODataUriParserRangeVariable": MicrosoftODataUriParserRangeVariable,
    "MicrosoftODataUriParserSelectExpandClause": MicrosoftODataUriParserSelectExpandClause,
    "MicrosoftODataUriParserSelectItem": MicrosoftODataUriParserSelectItem,
    "MicrosoftODataUriParserSingleValueNode": MicrosoftODataUriParserSingleValueNode,
    "MicrosoftWin32SafeHandlesSafeWaitHandle": MicrosoftWin32SafeHandlesSafeWaitHandle,
    "SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_": SystemCollectionsGenericKeyValuePair2SystemStringMicrosoftExtensionsPrimitivesStringValues_,
    "SystemCollectionsGenericKeyValuePair2SystemStringSystemString_": SystemCollectionsGenericKeyValuePair2SystemStringSystemString_,
    "SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_": SystemCollectionsGenericKeyValuePair2SystemTypeSystemObject_,
    "SystemIOStream": SystemIOStream,
    "SystemIServiceProvider": SystemIServiceProvider,
    "SystemNetIPAddress": SystemNetIPAddress,
    "SystemSecurityClaimsClaim": SystemSecurityClaimsClaim,
    "SystemSecurityClaimsClaimsIdentity": SystemSecurityClaimsClaimsIdentity,
    "SystemSecurityClaimsClaimsPrincipal": SystemSecurityClaimsClaimsPrincipal,
    "SystemSecurityPrincipalIIdentity": SystemSecurityPrincipalIIdentity,
    "SystemThreadingCancellationToken": SystemThreadingCancellationToken,
    "SystemThreadingWaitHandle": SystemThreadingWaitHandle,
};
class HttpBasicAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    constructor() {
        this.accessToken = '';
    }
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    constructor() {
        this.username = '';
        this.password = '';
    }
    applyToRequest(_) {
        // Do nothing
    }
}
exports.VoidAuth = VoidAuth;
var CryptoApiApiKeys;
(function (CryptoApiApiKeys) {
})(CryptoApiApiKeys = exports.CryptoApiApiKeys || (exports.CryptoApiApiKeys = {}));
class CryptoApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[CryptoApiApiKeys[key]].apiKey = value;
    }
    /**
     * When crypto cipher operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
     * @summary Gets the details of cipher workflow.
     * @param operationid OperationId value for a cipher workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    cryptoGetCipherDetailsByOperationIdAsync(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/cipher/details/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling cryptoGetCipherDetailsByOperationIdAsync.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling cryptoGetCipherDetailsByOperationIdAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling cryptoGetCipherDetailsByOperationIdAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsCipherDetailsMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * When crypto cipher operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
     * @summary Gets the current status of cipher workflow.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    cryptoGetcipherstatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/cipher/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling cryptoGetcipherstatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling cryptoGetcipherstatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling cryptoGetcipherstatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsCipherResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * When crypto operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
     * @summary Gets the current status of crypto workflow.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    cryptoGetcryptostatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/crypto/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling cryptoGetcryptostatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling cryptoGetcryptostatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling cryptoGetcryptostatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsCryptoResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Needs to be added
     * @summary Initiates crypto cipher request for given input files.
     * @param clientid client application AAD Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    cryptoPostCipherAsync(clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/cipher'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling cryptoPostCipherAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling cryptoPostCipherAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Needs to be added
     * @summary Initiates crypto request for given input files.
     * @param clientid client application AAD Id
     * @param version
     * @param cryptoRequestMessage crypto request message
     * @param {*} [options] Override http request options.
     */
    cryptoPostCryptoAsync(clientid, version, cryptoRequestMessage, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/crypto'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling cryptoPostCryptoAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling cryptoPostCryptoAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cryptoRequestMessage, "MSEssGatewayClientContractsCryptoRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.CryptoApi = CryptoApi;
var DigestSignApiApiKeys;
(function (DigestSignApiApiKeys) {
})(DigestSignApiApiKeys = exports.DigestSignApiApiKeys || (exports.DigestSignApiApiKeys = {}));
class DigestSignApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DigestSignApiApiKeys[key]].apiKey = value;
    }
    /**
     * Gets the mapping of key codes for digest signing on client side
     * @summary Gets the mapping of key codes for digest signing on client side
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    digestSignGetDigestSignKeyCodeMappingsAsync(clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign/keycodes'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling digestSignGetDigestSignKeyCodeMappingsAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling digestSignGetDigestSignKeyCodeMappingsAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * When signing operation is successful, the response from this call contains certificate.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.
     * @summary Gets the current status of DigestSign Ceritificate workflow.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    digestSignGetdigestsigncertificatestatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign/certificate/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling digestSignGetdigestsigncertificatestatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling digestSignGetdigestsigncertificatestatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling digestSignGetdigestsigncertificatestatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsDigestSignCertificateResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
     * @summary Gets the current status of DigestSign workflow.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    digestSignGetdigestsignstatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling digestSignGetdigestsignstatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling digestSignGetdigestsignstatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling digestSignGetdigestsignstatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientOnPremContractsDigestSignResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A signed file is returned only after scanning is passed. This operation initiates a stepwise long running operation on server.              \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id              upon successful acceptace of payload and expected to check status of the workflow at later time.
     * @summary Initiates digest signing for given input.
     * @param clientid client application AAD Id
     * @param version
     * @param request digestSign request.
     * @param {*} [options] Override http request options.
     */
    digestSignPostDigestSignAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling digestSignPostDigestSignAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling digestSignPostDigestSignAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientOnPremContractsDigestSignRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A digestsign certificate will be returned if the job passed. This operation initiates a stepwise long running operation on server.              \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id              upon successful acceptace of payload and expected to check status of the workflow at later time.
     * @summary Initiates digest sign certificate request for given input.
     * @param clientid client application AAD Id
     * @param version
     * @param request digestSign request certificate message.
     * @param {*} [options] Override http request options.
     */
    digestSignPostDigestSignCertificateAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/digestsign/certificate'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling digestSignPostDigestSignCertificateAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling digestSignPostDigestSignCertificateAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsDigestSignCertificateRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DigestSignApi = DigestSignApi;
var FileTransferApiApiKeys;
(function (FileTransferApiApiKeys) {
})(FileTransferApiApiKeys = exports.FileTransferApiApiKeys || (exports.FileTransferApiApiKeys = {}));
class FileTransferApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[FileTransferApiApiKeys[key]].apiKey = value;
    }
    /**
     * When file transfer/copying operation is finished, the response from this call contains the status or result of the operation.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully transferedcopied to destination location.
     * @summary Gets the current status of file transfer/copy workflow using operation Id given at the time of submission.
     * @param operationid OperationId value for a file transfer/copy.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    fileTransferGetfiletransferstatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/filetransfer/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling fileTransferGetfiletransferstatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling fileTransferGetfiletransferstatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling fileTransferGetfiletransferstatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsFileTransferFileTransferResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * When piece hash operation is finished, the response from this call contains the status or result of the operation.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and piece hash operation can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates that the file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates that the piece hash files are generated and uploaded to the destination locations.
     * @summary Gets the current status of piece hash workflow using operation Id given at the time of submission.
     * @param operationid OperationId value for piece hash.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    fileTransferGetpiecehashstatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/filetransfer/piecehash/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling fileTransferGetpiecehashstatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling fileTransferGetpiecehashstatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling fileTransferGetpiecehashstatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsFileTransferPieceHashPieceHashResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This operation initiates a stepwise long running operation on server.             \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id             upon successful acceptance of payload and user is expected to check status of the workflow at later time.
     * @summary Initiates file copy from source location to destination location provided in the payload.
     * @param clientid client application AAD Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    fileTransferPostFileTransfer(clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/filetransfer'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling fileTransferPostFileTransfer.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling fileTransferPostFileTransfer.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This operation initiates a stepwise long running operation on server.             \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id             upon successful acceptance of payload and user is expected to check status of the workflow at later time.
     * @summary Initiates Piece Hash file generation for a given source file (mentioned in source location) and upload the same to the destination locations provided in the payload.
     * @param clientid client application AAD Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    fileTransferPostPieceHash(clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/filetransfer/piecehash'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling fileTransferPostPieceHash.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling fileTransferPostPieceHash.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.FileTransferApi = FileTransferApi;
var GroupApiApiKeys;
(function (GroupApiApiKeys) {
})(GroupApiApiKeys = exports.GroupApiApiKeys || (exports.GroupApiApiKeys = {}));
class GroupApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[GroupApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @param clientid
     * @param id
     * @param version
     * @param {*} [options] Override http request options.
     */
    groupCloseGroupId(clientid, id, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/groups/{id}'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling groupCloseGroupId.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling groupCloseGroupId.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling groupCloseGroupId.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @param clientid
     * @param id
     * @param version
     * @param queryOptions
     * @param {*} [options] Override http request options.
     */
    groupGetScanResultForGroup(clientid, id, version, queryOptions, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/groups/{id}/workflows/scan/result'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling groupGetScanResultForGroup.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling groupGetScanResultForGroup.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling groupGetScanResultForGroup.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(queryOptions, "MicrosoftAspNetODataQueryODataQueryOptions")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MSEssGatewayClientContractsScanGroupResult>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.GroupApi = GroupApi;
var HealthApiApiKeys;
(function (HealthApiApiKeys) {
})(HealthApiApiKeys = exports.HealthApiApiKeys || (exports.HealthApiApiKeys = {}));
class HealthApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[HealthApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @param version
     * @param {*} [options] Override http request options.
     */
    healthHealthCheck(version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/healthcheck'
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling healthHealthCheck.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.HealthApi = HealthApi;
var KeyFulfilmentApiApiKeys;
(function (KeyFulfilmentApiApiKeys) {
})(KeyFulfilmentApiApiKeys = exports.KeyFulfilmentApiApiKeys || (exports.KeyFulfilmentApiApiKeys = {}));
class KeyFulfilmentApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[KeyFulfilmentApiApiKeys[key]].apiKey = value;
    }
    /**
     * This requests is sent by Slk Portal.
     * @summary Get pending key fulfilment requests that might need approval or retry
     * @param clientid client application AAD Id
     * @param version
     * @param userEmailId
     * @param keyFulfilmentRequestId
     * @param status
     * @param limit
     * @param pageNumber
     * @param startDate
     * @param endDate
     * @param sortByStatus
     * @param {*} [options] Override http request options.
     */
    keyFulfilmentGetKeyFulfilmentAsync(clientid, version, userEmailId, keyFulfilmentRequestId, status, limit, pageNumber, startDate, endDate, sortByStatus, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyfulfilment/pending-requests'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling keyFulfilmentGetKeyFulfilmentAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling keyFulfilmentGetKeyFulfilmentAsync.');
        }
        if (userEmailId !== undefined) {
            localVarQueryParameters['UserEmailId'] = ObjectSerializer.serialize(userEmailId, "string");
        }
        if (keyFulfilmentRequestId !== undefined) {
            localVarQueryParameters['KeyFulfilmentRequestId'] = ObjectSerializer.serialize(keyFulfilmentRequestId, "string");
        }
        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'NotStarted' | 'InProgress' | 'WaitingForRanges' | 'WaitingForApproval' | 'Failed' | 'Completed' | 'Cancelled' | 'Rejected'");
        }
        if (limit !== undefined) {
            localVarQueryParameters['Limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (pageNumber !== undefined) {
            localVarQueryParameters['PageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
        }
        if (startDate !== undefined) {
            localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
        }
        if (endDate !== undefined) {
            localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
        }
        if (sortByStatus !== undefined) {
            localVarQueryParameters['SortByStatus'] = ObjectSerializer.serialize(sortByStatus, "'Asc' | 'Desc'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This requests is sent by Slk tenants. It sends the request to Slk to generate Key which is then sent back to tenants.
     * @summary Initiates Key fulfilment request for Slk
     * @param clientid client application AAD Id
     * @param version
     * @param request Request Information
     * @param {*} [options] Override http request options.
     */
    keyFulfilmentRequestKeyFulfilmentAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyfulfilment'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling keyFulfilmentRequestKeyFulfilmentAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling keyFulfilmentRequestKeyFulfilmentAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This requests is sent by Slk Portal and generated by slk buisness
     * @summary Update key fulfilment request. All update requires KeyFulfilmentRequestId.  To approve or reject, set ApprovalStatus as approve/reject  To cancel or complete, set WorkflowStatus as Cancelled or Completed.  To retry, just set the KeyFulfilmentRequestId.  No other operations or status change is allowed.
     * @param clientid client application AAD Id
     * @param version
     * @param request Request Information
     * @param {*} [options] Override http request options.
     */
    keyFulfilmentUpdateKeyFulfilmentAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyfulfilment'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling keyFulfilmentUpdateKeyFulfilmentAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling keyFulfilmentUpdateKeyFulfilmentAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.KeyFulfilmentApi = KeyFulfilmentApi;
var KeyValidationApiApiKeys;
(function (KeyValidationApiApiKeys) {
})(KeyValidationApiApiKeys = exports.KeyValidationApiApiKeys || (exports.KeyValidationApiApiKeys = {}));
class KeyValidationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[KeyValidationApiApiKeys[key]].apiKey = value;
    }
    /**
     * This requests is sent by Slk Portal.
     * @summary Gets all keyvalidation request depending on the query request. (Paginated)
     * @param clientid client application AAD Id
     * @param version
     * @param userEmailId
     * @param keyValidationRequestId
     * @param status
     * @param limit
     * @param pageNumber
     * @param startDate
     * @param endDate
     * @param {*} [options] Override http request options.
     */
    keyValidationGetKeyValidationsAsync(clientid, version, userEmailId, keyValidationRequestId, status, limit, pageNumber, startDate, endDate, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyvalidations'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling keyValidationGetKeyValidationsAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling keyValidationGetKeyValidationsAsync.');
        }
        if (userEmailId !== undefined) {
            localVarQueryParameters['UserEmailId'] = ObjectSerializer.serialize(userEmailId, "string");
        }
        if (keyValidationRequestId !== undefined) {
            localVarQueryParameters['KeyValidationRequestId'] = ObjectSerializer.serialize(keyValidationRequestId, "string");
        }
        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'NotStarted' | 'InProgress' | 'Completed' | 'Cancelled' | 'PartialCompleted' | 'Failed'");
        }
        if (limit !== undefined) {
            localVarQueryParameters['Limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (pageNumber !== undefined) {
            localVarQueryParameters['PageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
        }
        if (startDate !== undefined) {
            localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
        }
        if (endDate !== undefined) {
            localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This requests is sent by Slk Portal.
     * @summary Gets all pending keyvalidation request depending on the query request. (Paginated)
     * @param clientid client application AAD Id
     * @param version
     * @param userEmailId
     * @param keyValidationRequestId
     * @param status
     * @param limit
     * @param pageNumber
     * @param startDate
     * @param endDate
     * @param {*} [options] Override http request options.
     */
    keyValidationGetPendingKeyValidationsAsync(clientid, version, userEmailId, keyValidationRequestId, status, limit, pageNumber, startDate, endDate, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyvalidations/pending-requests'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling keyValidationGetPendingKeyValidationsAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling keyValidationGetPendingKeyValidationsAsync.');
        }
        if (userEmailId !== undefined) {
            localVarQueryParameters['UserEmailId'] = ObjectSerializer.serialize(userEmailId, "string");
        }
        if (keyValidationRequestId !== undefined) {
            localVarQueryParameters['KeyValidationRequestId'] = ObjectSerializer.serialize(keyValidationRequestId, "string");
        }
        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'NotStarted' | 'InProgress' | 'Completed' | 'Cancelled' | 'PartialCompleted' | 'Failed'");
        }
        if (limit !== undefined) {
            localVarQueryParameters['Limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (pageNumber !== undefined) {
            localVarQueryParameters['PageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
        }
        if (startDate !== undefined) {
            localVarQueryParameters['StartDate'] = ObjectSerializer.serialize(startDate, "Date");
        }
        if (endDate !== undefined) {
            localVarQueryParameters['EndDate'] = ObjectSerializer.serialize(endDate, "Date");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This requests is sent by Slk Portal. It sends the request to Slk to validate Key which is then notified back
     * @summary Submits a new Key validation request
     * @param clientid client application AAD Id
     * @param version
     * @param request Request Information
     * @param {*} [options] Override http request options.
     */
    keyValidationSubmitKeyValidationAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyvalidation'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling keyValidationSubmitKeyValidationAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling keyValidationSubmitKeyValidationAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This requests is sent by Slk Portal.
     * @summary Submits an update request for an existing key validation request  To cancel, set KeyValidationRequestStatus as Cancelled and KeyValidationRequestId   To retry, just set the KeyValidationRequestId.  No other operations or status change is allowed.
     * @param clientid client application AAD Id
     * @param version
     * @param request request Information
     * @param {*} [options] Override http request options.
     */
    keyValidationUpdateKeyValidationAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/keyvalidation'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling keyValidationUpdateKeyValidationAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling keyValidationUpdateKeyValidationAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.KeyValidationApi = KeyValidationApi;
var PkitaCLMCertificateApiApiKeys;
(function (PkitaCLMCertificateApiApiKeys) {
})(PkitaCLMCertificateApiApiKeys = exports.PkitaCLMCertificateApiApiKeys || (exports.PkitaCLMCertificateApiApiKeys = {}));
class PkitaCLMCertificateApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PkitaCLMCertificateApiApiKeys[key]].apiKey = value;
    }
    /**
     * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
     * @summary Gets the current status of pkita clm certificate request workflow.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    pkitaCLMCertificateGetclmcertificatestatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/clmcertificate/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling pkitaCLMCertificateGetclmcertificatestatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling pkitaCLMCertificateGetclmcertificatestatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling pkitaCLMCertificateGetclmcertificatestatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Request pkita clm to generate a certificate.
     * @summary Initiates pkita clm certificate request.
     * @param clientid client application AAD Id
     * @param version
     * @param request pkita clm certificate request.
     * @param {*} [options] Override http request options.
     */
    pkitaCLMCertificatePostCertificateAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/clmcertificate'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling pkitaCLMCertificatePostCertificateAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling pkitaCLMCertificatePostCertificateAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PkitaCLMCertificateApi = PkitaCLMCertificateApi;
var PkitaCLMCertificateApprovalApiApiKeys;
(function (PkitaCLMCertificateApprovalApiApiKeys) {
})(PkitaCLMCertificateApprovalApiApiKeys = exports.PkitaCLMCertificateApprovalApiApiKeys || (exports.PkitaCLMCertificateApprovalApiApiKeys = {}));
class PkitaCLMCertificateApprovalApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PkitaCLMCertificateApprovalApiApiKeys[key]].apiKey = value;
    }
    /**
     * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
     * @summary Gets the current status of pkita clm certificate request approval workflow.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    pkitaCLMCertificateApprovalGetclmcertificateapprovalstatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/clmcertificateapproval/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling pkitaCLMCertificateApprovalGetclmcertificateapprovalstatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling pkitaCLMCertificateApprovalGetclmcertificateapprovalstatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling pkitaCLMCertificateApprovalGetclmcertificateapprovalstatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Request pkita clm to generate a certificate request approval.
     * @summary Initiates pkita clm certificate request approval.
     * @param clientid client application AAD Id
     * @param version
     * @param request pkita clm certificate request approval.
     * @param {*} [options] Override http request options.
     */
    pkitaCLMCertificateApprovalPostCertificateAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/clmcertificateapproval'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling pkitaCLMCertificateApprovalPostCertificateAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling pkitaCLMCertificateApprovalPostCertificateAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsPKITACertificatePkitaClmCertificateRequestApprovalMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PkitaCLMCertificateApprovalApi = PkitaCLMCertificateApprovalApi;
var PkitaCertificateApiApiKeys;
(function (PkitaCertificateApiApiKeys) {
})(PkitaCertificateApiApiKeys = exports.PkitaCertificateApiApiKeys || (exports.PkitaCertificateApiApiKeys = {}));
class PkitaCertificateApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PkitaCertificateApiApiKeys[key]].apiKey = value;
    }
    /**
     * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
     * @summary Gets the current status of pkita certificate request workflow.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    pkitaCertificateGetcertificatestatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/certificate/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling pkitaCertificateGetcertificatestatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling pkitaCertificateGetcertificatestatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling pkitaCertificateGetcertificatestatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsPKITACertificatePkitaCertificateResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Request pkita to generate a certificate.
     * @summary Initiates pkita certificate request.
     * @param clientid client application AAD Id
     * @param version
     * @param request pkita certificate request.
     * @param {*} [options] Override http request options.
     */
    pkitaCertificatePostCertificateAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/certificate'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling pkitaCertificatePostCertificateAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling pkitaCertificatePostCertificateAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsPKITACertificatePkitaCertificateRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PkitaCertificateApi = PkitaCertificateApi;
var PolicyApiApiKeys;
(function (PolicyApiApiKeys) {
})(PolicyApiApiKeys = exports.PolicyApiApiKeys || (exports.PolicyApiApiKeys = {}));
class PolicyApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PolicyApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Get the policy based upon the policy request
     * @param clientid
     * @param version
     * @param commandName
     * @param audience
     * @param contentOrigin
     * @param contentType
     * @param intent
     * @param productState
     * @param {*} [options] Override http request options.
     */
    policyGetPolicyAsync(clientid, version, commandName, audience, contentOrigin, contentType, intent, productState, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/policy'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling policyGetPolicyAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling policyGetPolicyAsync.');
        }
        if (commandName !== undefined) {
            localVarQueryParameters['commandName'] = ObjectSerializer.serialize(commandName, "string");
        }
        if (audience !== undefined) {
            localVarQueryParameters['audience'] = ObjectSerializer.serialize(audience, "string");
        }
        if (contentOrigin !== undefined) {
            localVarQueryParameters['contentOrigin'] = ObjectSerializer.serialize(contentOrigin, "string");
        }
        if (contentType !== undefined) {
            localVarQueryParameters['contentType'] = ObjectSerializer.serialize(contentType, "string");
        }
        if (intent !== undefined) {
            localVarQueryParameters['intent'] = ObjectSerializer.serialize(intent, "string");
        }
        if (productState !== undefined) {
            localVarQueryParameters['productState'] = ObjectSerializer.serialize(productState, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PolicyApi = PolicyApi;
var ProductOnboardingApiApiKeys;
(function (ProductOnboardingApiApiKeys) {
})(ProductOnboardingApiApiKeys = exports.ProductOnboardingApiApiKeys || (exports.ProductOnboardingApiApiKeys = {}));
class ProductOnboardingApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ProductOnboardingApiApiKeys[key]].apiKey = value;
    }
    /**
     * This request comes from PPP to onboard a new PKPN into SLK V2
     * @summary Initiates pkpn onboarding request
     * @param clientid client application AAD Id
     * @param version
     * @param request Pkpn Information
     * @param {*} [options] Override http request options.
     */
    productOnboardingOnboardPkpn(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/productonboarding'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling productOnboardingOnboardPkpn.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling productOnboardingOnboardPkpn.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsSlkResponseSlkResponseMessage1MSEssGatewayClientContractsSlkResponsePkpnProvisionResponse_");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ProductOnboardingApi = ProductOnboardingApi;
var ProvisionStorageApiApiKeys;
(function (ProvisionStorageApiApiKeys) {
})(ProvisionStorageApiApiKeys = exports.ProvisionStorageApiApiKeys || (exports.ProvisionStorageApiApiKeys = {}));
class ProvisionStorageApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ProvisionStorageApiApiKeys[key]].apiKey = value;
    }
    /**
     * it returns a list of blob storage shards so that user could decide which one to choose, either round robin or random partition.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates storage is created successfully
     * @summary Gets results of a storage shards for a given operation id.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    provisionStorageGetstoragestatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/storage/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling provisionStorageGetstoragestatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling provisionStorageGetstoragestatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling provisionStorageGetstoragestatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsProvisionStorageResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Initiates creating storage provisioning request as a workflow with a stepwise long running operation. A stepwise operation is one that takes a long, and often unpredictable, length of time to complete, and doesnt offer state transition modeled in the resource.  \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id  upon successful acceptace of payload and expected to check status of the workflow at later time.
     * @summary Provisions the temporary storage for users to stage their files which will be ingested in ESRP system.   This API will return storage shards with read and write access to the caller for a specified duration.
     * @param clientid client application AAD Id
     * @param version
     * @param provisionApiRequest Payload for storage provision with details like routing parameters and duration of access needed. check ProvisionStorageRequest type for details
     * @param {*} [options] Override http request options.
     */
    provisionStoragePostStorageAsync(clientid, version, provisionApiRequest, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/storage'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling provisionStoragePostStorageAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling provisionStoragePostStorageAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(provisionApiRequest, "MSEssGatewayClientContractsProvisionStorageRequest")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ProvisionStorageApi = ProvisionStorageApi;
var ReleaseApiApiKeys;
(function (ReleaseApiApiKeys) {
})(ReleaseApiApiKeys = exports.ReleaseApiApiKeys || (exports.ReleaseApiApiKeys = {}));
class ReleaseApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ReleaseApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary To cancel the release process.
     * @param clientid client application AAD Id
     * @param version
     * @param requests List of Release Information
     * @param {*} [options] Override http request options.
     */
    releaseCancelReleaseAsync(clientid, version, requests, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling releaseCancelReleaseAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling releaseCancelReleaseAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requests, "Array<MSEssGatewayClientContractsReleaseRequestReleaseCancelRequestMessage>")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * the response from this call contains complete release object and the various activities that are performed as part of the release workflow.                The release details will contain all metadata and also contain list of activities that were performed as part of the release workflow               <br /><b>\"Name\"</b>: Name / type of the activity that was performed.               <br /><b>\"IsComplete\"</b>: Whether the activity was completed or not               The release status will also contain error object which will contain detailed error in case the release processing fails               <br /><b>\"Code\"</b>: Error code indicating cause of failure               <br /><b>\"Message\"</b>: details error description
     * @summary Gets the complete details of a submitted release and it's workflow details.
     * @param operationid Release Id value for the release workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    releaseGetReleaseDetailsByReleaseIdAsync(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release/details/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling releaseGetReleaseDetailsByReleaseIdAsync.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling releaseGetReleaseDetailsByReleaseIdAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling releaseGetReleaseDetailsByReleaseIdAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsReleaseResponseReleaseDetailsMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @param operationid
     * @param clientid
     * @param version
     * @param {*} [options] Override http request options.
     */
    releaseGetReleaseEditStatusByOperationIdAsync(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release/operations/edit/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling releaseGetReleaseEditStatusByOperationIdAsync.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling releaseGetReleaseEditStatusByOperationIdAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling releaseGetReleaseEditStatusByOperationIdAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsReleaseResponseReleaseEditResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @param operationid
     * @param clientid
     * @param version
     * @param {*} [options] Override http request options.
     */
    releaseGetreleasestatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling releaseGetreleasestatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling releaseGetreleasestatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling releaseGetreleasestatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsReleaseResponseReleaseResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A Release is completed only after the release workflow is completed. Release workflow is decided based on the input payload, tenant and routing information. Post Release operation initiates a stepwise long running operation on server.               \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id               upon successful acceptance of payload and expected to check status of the Release at later time.
     * @summary Initiates Release Processing based on the input payload.
     * @param clientid client application AAD Id
     * @param version
     * @param requestMessage
     * @param {*} [options] Override http request options.
     */
    releasePostRelease2Async(clientid, version, requestMessage, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling releasePostRelease2Async.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling releasePostRelease2Async.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requestMessage, "MSEssGatewayClientContractsReleaseRequestReleaseRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsOperationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary To cancel the release process.
     * @param clientid client application AAD Id
     * @param version
     * @param operationid
     * @param request A ReleaseEditRequestMessage
     * @param {*} [options] Override http request options.
     */
    releaseReleaseEditAsync(clientid, version, operationid, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release/operations/edit/{operationid}'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)))
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling releaseReleaseEditAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling releaseReleaseEditAsync.');
        }
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling releaseReleaseEditAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsReleaseRequestReleaseEditRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsReleaseResponseReleaseEditResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Approve or reject the release requests.
     * @param clientid client application AAD Id
     * @param version
     * @param requests List of Release Information
     * @param {*} [options] Override http request options.
     */
    releaseSignOffReleaseAsync(clientid, version, requests, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/release'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling releaseSignOffReleaseAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling releaseSignOffReleaseAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requests, "Array<MSEssGatewayClientContractsReleaseRequestReleaseSignOffRequestMessage>")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MSEssGatewayClientContractsOperationResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ReleaseApi = ReleaseApi;
var ScanApiApiKeys;
(function (ScanApiApiKeys) {
})(ScanApiApiKeys = exports.ScanApiApiKeys || (exports.ScanApiApiKeys = {}));
class ScanApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ScanApiApiKeys[key]].apiKey = value;
    }
    /**
     * When malware scanning operation is finished, the response from this call contains the status or result of the operation.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and determined clean.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
     * @summary Gets the current status of malware scanning workflow.
     * @param operationid OperationId value for a malware scanning workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    scanGetscanstatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/scan/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling scanGetscanstatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling scanGetscanstatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling scanGetscanstatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsScanResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This operation initiates a stepwise long running operation on server.             \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id             upon successful acceptace of payload and expected to check status of the workflow at later time.
     * @summary Initiates malware scanning of a given input files.
     * @param clientid client application AAD Id
     * @param version
     * @param requests list of files to malware scan.
     * @param {*} [options] Override http request options.
     */
    scanPostScan2Async(clientid, version, requests, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/scan'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling scanPostScan2Async.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling scanPostScan2Async.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requests, "Array<MSEssGatewayClientContractsScanRequestMessage>")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MSEssGatewayClientContractsOperationResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ScanApi = ScanApi;
var ScanDetectionApiApiApiKeys;
(function (ScanDetectionApiApiApiKeys) {
})(ScanDetectionApiApiApiKeys = exports.ScanDetectionApiApiApiKeys || (exports.ScanDetectionApiApiApiKeys = {}));
class ScanDetectionApiApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ScanDetectionApiApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @param operationId
     * @param clientId
     * @param version
     * @param {*} [options] Override http request options.
     */
    scanDetectionApiGetdetectionresults(operationId, clientId, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientId}/workflows/scan/detection/operations/{operationId}'
            .replace('{' + 'operationId' + '}', encodeURIComponent(String(operationId)))
            .replace('{' + 'clientId' + '}', encodeURIComponent(String(clientId)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationId' is not null or undefined
        if (operationId === null || operationId === undefined) {
            throw new Error('Required parameter operationId was null or undefined when calling scanDetectionApiGetdetectionresults.');
        }
        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling scanDetectionApiGetdetectionresults.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling scanDetectionApiGetdetectionresults.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ScanDetectionApiApi = ScanDetectionApiApi;
var SessionApiApiKeys;
(function (SessionApiApiKeys) {
})(SessionApiApiKeys = exports.SessionApiApiKeys || (exports.SessionApiApiKeys = {}));
class SessionApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SessionApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Create a session with policy, config, digesign mapping and storage containers for the client
     * @param clientid
     * @param version
     * @param request
     * @param {*} [options] Override http request options.
     */
    sessionCreateSessionAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/session'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling sessionCreateSessionAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling sessionCreateSessionAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSessionRequestMessage")
        };
        //console.log(localVarRequestOptions.body);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * it returns a policy, config, digestsign mapping data and list of blob storage shards so that user could decide which one to choose, either round robin or random partition.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates storage is created successfully
     * @summary Gets results of a session for a given operation id.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    sessionGetSessionByOperationIdAsync(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/session/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling sessionGetSessionByOperationIdAsync.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling sessionGetSessionByOperationIdAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling sessionGetSessionByOperationIdAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsSessionResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SessionApi = SessionApi;
var SignApiApiKeys;
(function (SignApiApiKeys) {
})(SignApiApiKeys = exports.SignApiApiKeys || (exports.SignApiApiKeys = {}));
class SignApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[SignApiApiKeys[key]].apiKey = value;
    }
    /**
     * When signing operation is successful, the response from this call contains the sha256 hash value of the signed file.              Caller is expected to calculate hash of the signed file during download and match it with the value in this payload.              The possible status values for a given file are below.              <br /><b>\"failCanRetry\"</b>: This status indicates there are service internal errors so file must be resubmitted.              <br /><b>\"failDoNotRetry\"</b>: This status indicates the input file or payload was invalid and scanning can not be performed using user inputs provided. Do not resubmit same file with same payload again, you will have to inspect file errors and fix errors accordingly.              <br /><b>\"inprogress\"</b>: This status indicates file is still processing, caller can check status later.              <br /><b>\"pass\"</b>: This status indicates file is successfully scanned and signed. Caller can now download the signed file.              <br /><b>\"pendingAnalysis\"</b>: This status indicates file is flagged for potential malware and scan analyst will be inspecting results. Caller must not resubmit same file again because it will likely result same state.              File can stay in this status for long duration until scan analyst makes final determination of pass or fail.
     * @summary Gets the current status of sign workflow.
     * @param operationid OperationId value for a signing workflow.
     * @param clientid Client AAD Application Id
     * @param version
     * @param {*} [options] Override http request options.
     */
    signGetsignstatus(operationid, clientid, version, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/sign/operations/{operationid}'
            .replace('{' + 'operationid' + '}', encodeURIComponent(String(operationid)))
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'operationid' is not null or undefined
        if (operationid === null || operationid === undefined) {
            throw new Error('Required parameter operationid was null or undefined when calling signGetsignstatus.');
        }
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling signGetsignstatus.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling signGetsignstatus.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "MSEssGatewayClientContractsSignResultMessage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A signed file is returned only after scanning is passed. This operation initiates a stepwise long running operation on server.              \"stepwise long running\" operation is often long running and have unpredictable duration. User is given operation id              upon successful acceptace of payload and expected to check status of the workflow at later time.
     * @summary Initiates code signing and malware scanning of a given input files.
     * @param clientid client application AAD Id
     * @param version
     * @param requests list of files to codesign.
     * @param {*} [options] Override http request options.
     */
    signPostSign2Async(clientid, version, requests, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/sign'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling signPostSign2Async.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling signPostSign2Async.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(requests, "Array<MSEssGatewayClientContractsSignRequestMessage>")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MSEssGatewayClientContractsOperationResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.SignApi = SignApi;
var TenantOnboardingApiApiKeys;
(function (TenantOnboardingApiApiKeys) {
})(TenantOnboardingApiApiKeys = exports.TenantOnboardingApiApiKeys || (exports.TenantOnboardingApiApiKeys = {}));
class TenantOnboardingApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[TenantOnboardingApiApiKeys[key]].apiKey = value;
    }
    /**
     * This requests is sent by Slk Portal.
     * @summary Gets all the onboarded Tenants of SLK
     * @param clientid client application AAD Id
     * @param version
     * @param tenantCode
     * @param typeOfTenant
     * @param {*} [options] Override http request options.
     */
    tenantOnboardingGetAllTenants(clientid, version, tenantCode, typeOfTenant, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/tenantonboarding/gettenants'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling tenantOnboardingGetAllTenants.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling tenantOnboardingGetAllTenants.');
        }
        if (tenantCode !== undefined) {
            localVarQueryParameters['TenantCode'] = ObjectSerializer.serialize(tenantCode, "string");
        }
        if (typeOfTenant !== undefined) {
            localVarQueryParameters['TypeOfTenant'] = ObjectSerializer.serialize(typeOfTenant, "'SLK' | 'RSM' | 'JIT'");
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This requests is sent by Slk Portal. It sends tenant onboardin request to slk api to persist the onboarding request.
     * @summary Creates Tenant Onboarding request for Slk
     * @param clientid client application AAD Id
     * @param version
     * @param request Request Information
     * @param {*} [options] Override http request options.
     */
    tenantOnboardingRequestTenantOnboardingAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/tenantonboarding'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling tenantOnboardingRequestTenantOnboardingAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling tenantOnboardingRequestTenantOnboardingAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This requests is sent by Slk Portal. It sends update request to update the tenant onboarded to SLK
     * @summary Updates Tenant details for SLK tenant
     * @param clientid client application AAD Id
     * @param version
     * @param request Request Information
     * @param {*} [options] Override http request options.
     */
    tenantOnboardingRequestTenantOnboardingUpdateAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/tenantonboarding/updatetenant'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling tenantOnboardingRequestTenantOnboardingUpdateAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling tenantOnboardingRequestTenantOnboardingUpdateAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsSlkRequestSlkRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.TenantOnboardingApi = TenantOnboardingApi;
var VaultCallbackApiApiKeys;
(function (VaultCallbackApiApiKeys) {
})(VaultCallbackApiApiKeys = exports.VaultCallbackApiApiKeys || (exports.VaultCallbackApiApiKeys = {}));
class VaultCallbackApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[VaultCallbackApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Callback notification for a file in a release.
     * @param clientid client application AAD Id
     * @param version
     * @param request File callback information
     * @param {*} [options] Override http request options.
     */
    vaultCallbackPostVaultCallbackAsync(clientid, version, request, options = {}) {
        const localVarPath = this.basePath + '/api/v{version}/{clientid}/workflows/vaultcallback'
            .replace('{' + 'clientid' + '}', encodeURIComponent(String(clientid)))
            .replace('{' + 'version' + '}', encodeURIComponent(String(version)));
        let localVarQueryParameters = {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};
        // verify required parameter 'clientid' is not null or undefined
        if (clientid === null || clientid === undefined) {
            throw new Error('Required parameter clientid was null or undefined when calling vaultCallbackPostVaultCallbackAsync.');
        }
        // verify required parameter 'version' is not null or undefined
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling vaultCallbackPostVaultCallbackAsync.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;
        let localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "MSEssGatewayClientContractsReleaseRequestVaultCallbackRequestMessage")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.VaultCallbackApi = VaultCallbackApi;
